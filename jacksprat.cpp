// jacksprat.cpp : Defines the entry point for the console application.
//
#include <utility>
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include "windows.h"


#define KING_VALUE 25000
/*
#define PAWN_VALUE 100
#define KNIGHT_VALUE 320
#define BISHOP_VALUE 330
#define ROOK_VALUE 500
#define QUEEN_VALUE 900
#define KING_CASTLING_BONUS 15
*/
#define PAWN_VALUE 100
#define KNIGHT_VALUE 420
#define BISHOP_VALUE 428
#define ROOK_VALUE 643
#define QUEEN_VALUE 1283
#define KING_CASTLING_BONUS 15


#define LOGGING
#define INF (1<<28)

#define UP -10
#define DOWN 10
#define LEFT -1
#define RIGHT 1

#define MAX_PLY 32
//approximate max branching factor
#define MAX_MOVES_PER_PLY 128

//no more than 400 moves per game
#define MAX_MOVES 400


#define REPRODUCABLE_HASH
#define REPLACE_BY_DEPTH
//for debugging
//#define DISABLE_TIME

#define HASH_TABLE
bool DisableBook=false;
int FakeLen = 0;
const int BOARD_SIZE = 120;
bool CheckForEndgame;
int MoveNumber = 0;

#ifdef NDEBUG
#define PARAMLINE 
#define DEFLINE
#define INITLINE
#define ATLINE 
#define COPYLINE 
#define SETLINE 
#else

#define PARAMLINE ,int _line
#define DEFLINE int line;
#define INITLINE ,line(_line)
#define ATLINE ,__LINE__
#define COPYLINE ,line(m.line)
#define SETLINE line=m.line;
#endif

enum Colors { LIGHT, DARK, NUM_COLORS = 2, NO_COLOR = 2 };

inline Colors other_color(Colors n)
{
	return (Colors)(1 - (int)n);
}

Colors computer_side;

enum PieceType : signed char {
	EMPTY = 0,
	KING_NOT_MOVED = 1,
	KING = 2,
	KING_CASTLED = 3,
	PAWN = 4,
	PAWN_JUST_ADVANCED = 5,
	KNIGHT = 6,
	BISHOP = 7,
	ROOK_NOT_MOVED = 8,
	ROOK = 9,
	QUEEN = 10,
	NUM_PIECE_TYPES = 11,
};


inline bool is_rook(PieceType p)
{
	return p == ROOK || p == ROOK_NOT_MOVED;
}
inline bool is_sliding_type(PieceType p)
{
	return p >= BISHOP;
}

inline bool is_king(PieceType p)
{
	return p > EMPTY && p<= KING_CASTLED;
}

inline bool is_pawn(PieceType p)
{
	return p == PAWN || p == PAWN_JUST_ADVANCED;
}

inline bool is_piece(PieceType p)
{
	return p != EMPTY;
}

enum PieceSlotType : signed char {
	LIGHT_SLOT = 0,
	PAWN1 = 0,	
	LIGHT_PAWN1 = 0,	
	PAWN2 = 1,	
	LIGHT_PAWN2 = 1,	
	PAWN3 = 2,	
	LIGHT_PAWN3 = 2,	
	PAWN4 = 3,	
	LIGHT_PAWN4 = 3,	
	PAWN5 = 4,	
	LIGHT_PAWN5 = 4,	
	PAWN6 = 5,	
	LIGHT_PAWN6 = 5,	
	PAWN7 = 6,	
	LIGHT_PAWN7 = 6,	
	PAWN8 = 7,	
	LIGHT_PAWN8 = 7,	
	KNIGHT1 = 8,	
	LIGHT_KNIGHT1 = 8,	
	KNIGHT2 = 9,	
	LIGHT_KNIGHT2 = 9,	
	BISHOP1 = 10, 
	LIGHT_BISHOP1 = 10, 
	BISHOP2 = 11, 
	LIGHT_BISHOP2 = 11, 
	ROOK1 = 12,	
	LIGHT_ROOK1 = 12,	
	ROOK2 = 13,	
	LIGHT_ROOK2 = 13,	
	QUEENP = 14,	
	LIGHT_QUEENP = 14,	
	KINGP = 15,	
	LIGHT_KINGP = 15,	
	UNCOLORED_SLOT_MASK = 15,
	NUM_UNCOLORED_PIECE_SLOTS = 16,
	DARK_SLOT = 16,
	DARK_PAWN1 = 16,
	DARK_PAWN2 = 17,
	DARK_PAWN3 = 18,
	DARK_PAWN4 = 19,
	DARK_PAWN5 = 20,
	DARK_PAWN6 = 21,
	DARK_PAWN7 = 22,
	DARK_PAWN8 = 23,
	DARK_KNIGHT1 = 24,
	DARK_KNIGHT2 = 25,
	DARK_BISHOP1 = 26,
	DARK_BISHOP2 = 27,
	DARK_ROOK1 = 28,
	DARK_ROOK2 = 29,
	DARK_QUEENP = 30,
	DARK_KINGP = 31,
	NO_SLOT = 32,
	OFF_BOARD = 33,
	NUM_PIECE_SLOTS = 32,
};

inline bool is_piece(PieceSlotType p)
{
	return p != NO_SLOT && p != OFF_BOARD;
}


typedef PieceSlotType BoardArray[BOARD_SIZE];
BoardArray Board;

inline Colors color(PieceSlotType p)
{
	if ((p & 16) != 0) return DARK;
	return LIGHT;
}

inline PieceSlotType as_light(PieceSlotType p)
{
	return (PieceSlotType)(p & 15);
}

inline PieceSlotType as_dark(PieceSlotType p)
{
	return (PieceSlotType)(p | 16);
}

inline PieceSlotType base_by_color(Colors c)
{
	if (c == LIGHT) return LIGHT_SLOT;
	return DARK_SLOT;
}

typedef signed char Pos;
Pos En_passant_history[MAX_MOVES + MAX_PLY];
typedef Pos PlayersPositions[NUM_PIECE_SLOTS + 2];
typedef int PlayersEnpassant[NUM_PIECE_SLOTS + 2];
typedef PieceType PlayersPieces[NUM_PIECE_SLOTS + 2];//The +2 is so that NO_SLOT and OFF_BOARD can map to EMPTY
enum PinTypes { NotPinned, PartiallyPinned, Pinned };
struct PlayersType {
	PlayersPieces pieces;
	PlayersPositions positions;
	PinTypes pinned[NUM_PIECE_SLOTS+2];
};

#define a1 91
#define b1 92
#define c1 93
#define d1 94
#define e1 95
#define f1 96
#define g1 97
#define h1 98
#define a2 81
#define b2 82
#define c2 83
#define d2 84
#define e2 85
#define f2 86
#define g2 87
#define h2 88
#define a3 71
#define b3 72
#define c3 73
#define d3 74
#define e3 75
#define f3 76
#define g3 77
#define h3 78
#define a4 61
#define b4 62
#define c4 63
#define d4 64
#define e4 65
#define f4 66
#define g4 67
#define h4 68
#define a5 51
#define b5 52
#define c5 53
#define d5 54
#define e5 55
#define f5 56
#define g5 57
#define h5 58
#define a6 41
#define b6 42
#define c6 43
#define d6 44
#define e6 45
#define f6 46
#define g6 47
#define h6 48
#define a7 31
#define b7 32
#define c7 33
#define d7 34
#define e7 35
#define f7 36
#define g7 37
#define h7 38
#define a8 21
#define b8 22
#define c8 23
#define d8 24
#define e8 25
#define f8 26
#define g8 27
#define h8 28

const int ValuePerPiece[NUM_PIECE_TYPES] = {
	0,
	KING_VALUE,
	KING_VALUE,
	KING_VALUE + KING_CASTLING_BONUS,
	PAWN_VALUE,
	PAWN_VALUE,
	KNIGHT_VALUE,
	BISHOP_VALUE,
	ROOK_VALUE,
	ROOK_VALUE,
	QUEEN_VALUE,
};

const char PieceCharL[] = ".KKKPPNBRRQ";
const char PieceCharD[] = ".kkkppnbrrq";
const char piece_char(Colors c, PieceType p)
{
	if (c == LIGHT) return PieceCharL[p];
	return PieceCharD[p];
}

const PieceType ChangePieceOnMove[] =
{
	EMPTY,
	KING,
	KING,
	KING_CASTLED,
	PAWN,
	PAWN,
	KNIGHT,
	BISHOP,
	ROOK,
	ROOK,
	QUEEN,
};

//

enum MaterialIndexes { DONT_COUNT=0, PAWN_COUNT=1,MAJOR_MINOR_COUNT =2, NUM_MATERIAL_INDEXES=3 };

const MaterialIndexes PieceCountIndex[] =
{
	DONT_COUNT,
	DONT_COUNT,
	DONT_COUNT,
	DONT_COUNT,
	PAWN_COUNT,
	PAWN_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
};

int MaterialSums[NUM_COLORS][NUM_MATERIAL_INDEXES];

const Pos enpassant_table[BOARD_SIZE] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	// 8
	0,0,0,0,0,0,0,0,0,0,
	// 7
	0,0,0,0,0,0,0,0,0,0,
	// 6
	0,a5,b5,c5,d5,e5,f5,g5,h5,0,
	// 5
	0,0,0,0,0,0,0,0,0,0,
	// 4
	0,0,0,0,0,0,0,0,0,0,
	// 3
	0,a4,b4,c4,d4,e4,f4,g4,h4,0,
	// 2
	0,0,0,0,0,0,0,0,0,0,
	// 1
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};


const char * const PosToStandard[] = {
	"Off 0","Off 1","Off 2","Off 3","Off 4","Off 5","Off 6","Off 7","Off 8","Off 9",
	"Off 10","Off 11","Off 12","Off 13","Off 14","Off 15","Off 16","Off 17","Off 18","Off 19",
	"Off 20","a8","b8","c8","d8","e8","f8","g8","h8","Off29",
	"Off 30","a7","b7","c7","d7","e7","f7","g7","h7","Off39",
	"Off 40","a6","b6","c6","d6","e6","f6","g6","h6","Off49",
	"Off 50","a5","b5","c5","d5","e5","f5","g5","h5","Off59",
	"Off 60","a4","b4","c4","d4","e4","f4","g4","h4","Off69",
	"Off 70","a3","b3","c3","d3","e3","f3","g3","h3","Off79",
	"Off 80","a2","b2","c2","d2","e2","f2","g2","h2","Off89",
	"Off 90","a1","b1","c1","d1","e1","f1","g1","h1","Off99",
	"Off 100","Off 101","Off 102","Off 103","Off 104","Off 105","Off 106","Off 107","Off 108","Off 109",
	"Off 110","Off 111","Off 112","Off 113","Off 114","Off 115","Off 116","Off 117","Off 118","Off 119",
};


#ifdef LOGGING
using namespace std;
ofstream Log;
void init_log()
{
	Log.open("chess.txt");
}
void close_log()
{
	Log.close();
}
#define LOG(x) x
#else
#define LOG(X)
void init_log()
{
}
void close_log()
{
}

#endif

bool PawnsDirty;
int PawnsValue;

const PieceType Initial_Pieces[] = {
	PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,
	KNIGHT,KNIGHT,BISHOP,BISHOP, ROOK_NOT_MOVED ,ROOK_NOT_MOVED, QUEEN,KING_NOT_MOVED,
	PAWN,PAWN,PAWN,PAWN,PAWN,PAWN ,PAWN,PAWN,
	KNIGHT, KNIGHT,BISHOP,BISHOP, ROOK_NOT_MOVED,ROOK_NOT_MOVED, QUEEN,KING_NOT_MOVED,
	EMPTY
};

const PlayersPositions Initial_Pos =
{
	a2,b2,c2,d2,e2,f2,g2,h2,
	b1,g1,c1,f1,a1,h1,d1,e1,
	a7,b7,c7,d7,e7,f7,g7,h7,
	b8,g8,c8,f8,a8,h8,d8,e8
};

typedef int PieceSquareTable[BOARD_SIZE];
const PieceSquareTable EmptySquareTable =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

#define SCALE_PST 

const PieceSquareTable KingEndSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,42 SCALE_PST, 46 SCALE_PST, 48 SCALE_PST, 50 SCALE_PST, 50 SCALE_PST, 48 SCALE_PST, 46 SCALE_PST, 42 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,38 SCALE_PST, 41 SCALE_PST, 44 SCALE_PST, 45 SCALE_PST, 45 SCALE_PST, 44 SCALE_PST, 41 SCALE_PST, 38 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,31 SCALE_PST, 34 SCALE_PST, 37 SCALE_PST, 38 SCALE_PST, 38 SCALE_PST, 37 SCALE_PST, 34 SCALE_PST, 31 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,22 SCALE_PST, 26 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 26 SCALE_PST, 22 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,11 SCALE_PST, 15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST, 11 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 2 SCALE_PST, 4 SCALE_PST, 5 SCALE_PST, 5 SCALE_PST, 4 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,-17 SCALE_PST, -13 SCALE_PST, -11 SCALE_PST, -10 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, -13 SCALE_PST, -17 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-34 SCALE_PST, -30 SCALE_PST, -28 SCALE_PST, -27 SCALE_PST, -27 SCALE_PST, -28 SCALE_PST, -30 SCALE_PST, -34 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingEndSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-34 SCALE_PST, -30 SCALE_PST, -28 SCALE_PST, -27 SCALE_PST, -27 SCALE_PST, -28 SCALE_PST, -30 SCALE_PST, -34 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-17 SCALE_PST, -13 SCALE_PST, -11 SCALE_PST, -10 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, -13 SCALE_PST, -17 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 2 SCALE_PST, 4 SCALE_PST, 5 SCALE_PST, 5 SCALE_PST, 4 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,11 SCALE_PST, 15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST, 11 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,22 SCALE_PST, 26 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 26 SCALE_PST, 22 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,31 SCALE_PST, 34 SCALE_PST, 37 SCALE_PST, 38 SCALE_PST, 38 SCALE_PST, 37 SCALE_PST, 34 SCALE_PST, 31 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,38 SCALE_PST, 41 SCALE_PST, 44 SCALE_PST, 45 SCALE_PST, 45 SCALE_PST, 44 SCALE_PST, 41 SCALE_PST, 38 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,42 SCALE_PST, 46 SCALE_PST, 48 SCALE_PST, 50 SCALE_PST, 50 SCALE_PST, 48 SCALE_PST, 46 SCALE_PST, 42 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingMidSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 25 SCALE_PST, 0 SCALE_PST,      0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingMidSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 25 SCALE_PST, 0 SCALE_PST,      0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameQueenSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,	12 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 12 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	21 SCALE_PST, 26 SCALE_PST, 30 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 30 SCALE_PST, 26 SCALE_PST, 21 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	23 SCALE_PST, 28 SCALE_PST, 32 SCALE_PST, 34 SCALE_PST, 34 SCALE_PST, 32 SCALE_PST, 28 SCALE_PST, 23 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	19 SCALE_PST, 24 SCALE_PST, 28 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 28 SCALE_PST, 24 SCALE_PST, 19 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	  9 SCALE_PST, 14 SCALE_PST, 17 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 17 SCALE_PST, 14 SCALE_PST, 9 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	-8 SCALE_PST, -3 SCALE_PST, 1 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, -3 SCALE_PST, -8 SCALE_PST,			   0 SCALE_PST,
	0 SCALE_PST,	-31 SCALE_PST, -26 SCALE_PST, -22 SCALE_PST, -21 SCALE_PST, -21 SCALE_PST, -22 SCALE_PST, -26 SCALE_PST, -31 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-61 SCALE_PST, -55 SCALE_PST, -52 SCALE_PST, -50 SCALE_PST, -50 SCALE_PST, -52 SCALE_PST, -55 SCALE_PST, -61 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};
const PieceSquareTable EndgameQueenSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,	-61 SCALE_PST, -55 SCALE_PST, -52 SCALE_PST, -50 SCALE_PST, -50 SCALE_PST, -52 SCALE_PST, -55 SCALE_PST, -61 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-31 SCALE_PST, -26 SCALE_PST, -22 SCALE_PST, -21 SCALE_PST, -21 SCALE_PST, -22 SCALE_PST, -26 SCALE_PST, -31 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-8 SCALE_PST, -3 SCALE_PST, 1 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, -3 SCALE_PST, -8 SCALE_PST,			   0 SCALE_PST,
	0 SCALE_PST,	  9 SCALE_PST, 14 SCALE_PST, 17 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 17 SCALE_PST, 14 SCALE_PST, 9 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	19 SCALE_PST, 24 SCALE_PST, 28 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 28 SCALE_PST, 24 SCALE_PST, 19 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	23 SCALE_PST, 28 SCALE_PST, 32 SCALE_PST, 34 SCALE_PST, 34 SCALE_PST, 32 SCALE_PST, 28 SCALE_PST, 23 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	21 SCALE_PST, 26 SCALE_PST, 30 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 30 SCALE_PST, 26 SCALE_PST, 21 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	12 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 12 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable QueenSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, 3 SCALE_PST, -15 SCALE_PST, -51 SCALE_PST, -83 SCALE_PST, -13 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-7 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 5 SCALE_PST, -1 SCALE_PST, -10 SCALE_PST, -7 SCALE_PST, -2 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-11 SCALE_PST, 0 SCALE_PST, 12 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 11 SCALE_PST, 7 SCALE_PST, -6 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, 5 SCALE_PST, 7 SCALE_PST, 9 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 26 SCALE_PST, 4 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-6 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST, 25 SCALE_PST, 32 SCALE_PST, 9 SCALE_PST, 26 SCALE_PST, 12 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 10 SCALE_PST, 13 SCALE_PST, 25 SCALE_PST, 37 SCALE_PST, 30 SCALE_PST, 15 SCALE_PST, 26 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 11 SCALE_PST, 35 SCALE_PST, 0 SCALE_PST, 16 SCALE_PST, 55 SCALE_PST, 39 SCALE_PST, 57 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-13 SCALE_PST, 6 SCALE_PST, -42 SCALE_PST, 0 SCALE_PST, 29 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 102 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable QueenSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, 3 SCALE_PST, -15 SCALE_PST, -51 SCALE_PST, -83 SCALE_PST, -13 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-7 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 5 SCALE_PST, -1 SCALE_PST, -10 SCALE_PST, -7 SCALE_PST, -2 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-11 SCALE_PST, 0 SCALE_PST, 12 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 11 SCALE_PST, 7 SCALE_PST, -6 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, 5 SCALE_PST, 7 SCALE_PST, 9 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 26 SCALE_PST, 4 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-6 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST, 25 SCALE_PST, 32 SCALE_PST, 9 SCALE_PST, 26 SCALE_PST, 12 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 10 SCALE_PST, 13 SCALE_PST, 25 SCALE_PST, 37 SCALE_PST, 30 SCALE_PST, 15 SCALE_PST, 26 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 11 SCALE_PST, 35 SCALE_PST, 0 SCALE_PST, 16 SCALE_PST, 55 SCALE_PST, 39 SCALE_PST, 57 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-13 SCALE_PST, 6 SCALE_PST, -42 SCALE_PST, 0 SCALE_PST, 29 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 102 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameRookSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,16 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 16 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,27 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,25 SCALE_PST, 27 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST, 25 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST, 4 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,-15 SCALE_PST, -13 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -13 SCALE_PST, -15 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-27 SCALE_PST, -25 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -25 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-32 SCALE_PST, -31 SCALE_PST, -30 SCALE_PST, -29 SCALE_PST, -29 SCALE_PST, -30 SCALE_PST, -31 SCALE_PST, -32 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameRookSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-32 SCALE_PST, -31 SCALE_PST, -30 SCALE_PST, -29 SCALE_PST, -29 SCALE_PST, -30 SCALE_PST, -31 SCALE_PST, -32 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-27 SCALE_PST, -25 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -25 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-15 SCALE_PST, -13 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -13 SCALE_PST, -15 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST, 4 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,25 SCALE_PST, 27 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST, 25 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,27 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,16 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 16 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable RookSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,84 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 37 SCALE_PST, 124 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 153 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,46 SCALE_PST, 33 SCALE_PST, 64 SCALE_PST, 62 SCALE_PST, 91 SCALE_PST, 89 SCALE_PST, 70 SCALE_PST, 104 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,24 SCALE_PST, 83 SCALE_PST, 54 SCALE_PST, 75 SCALE_PST, 134 SCALE_PST, 144 SCALE_PST, 85 SCALE_PST, 75 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,19 SCALE_PST, 33 SCALE_PST, 46 SCALE_PST, 57 SCALE_PST, 53 SCALE_PST, 39 SCALE_PST, 53 SCALE_PST, 16 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -5 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, -17 SCALE_PST, 13 SCALE_PST, -13 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 0 SCALE_PST, 3 SCALE_PST, -3 SCALE_PST, 8 SCALE_PST, -1 SCALE_PST, 12 SCALE_PST, 3 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,-26 SCALE_PST, -6 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST, 2 SCALE_PST, -10 SCALE_PST, -1 SCALE_PST, -29 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST, 4 SCALE_PST, -8 SCALE_PST,       0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable RookSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST, 4 SCALE_PST, -8 SCALE_PST,       0 SCALE_PST,
	0 SCALE_PST,-26 SCALE_PST, -6 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST, 2 SCALE_PST, -10 SCALE_PST, -1 SCALE_PST, -29 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 0 SCALE_PST, 3 SCALE_PST, -3 SCALE_PST, 8 SCALE_PST, -1 SCALE_PST, 12 SCALE_PST, 3 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -5 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, -17 SCALE_PST, 13 SCALE_PST, -13 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,19 SCALE_PST, 33 SCALE_PST, 46 SCALE_PST, 57 SCALE_PST, 53 SCALE_PST, 39 SCALE_PST, 53 SCALE_PST, 16 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST,24 SCALE_PST, 83 SCALE_PST, 54 SCALE_PST, 75 SCALE_PST, 134 SCALE_PST, 144 SCALE_PST, 85 SCALE_PST, 75 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,46 SCALE_PST, 33 SCALE_PST, 64 SCALE_PST, 62 SCALE_PST, 91 SCALE_PST, 89 SCALE_PST, 70 SCALE_PST, 104 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,84 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 37 SCALE_PST, 124 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 153 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameBishopSquareTableL = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 4 SCALE_PST, 8 SCALE_PST, 10 SCALE_PST, 10 SCALE_PST, 8 SCALE_PST, 4 SCALE_PST, -2 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, 20 SCALE_PST, 20 SCALE_PST, 18 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 13 SCALE_PST, 19 SCALE_PST, 23 SCALE_PST, 25 SCALE_PST, 25 SCALE_PST, 23 SCALE_PST, 19 SCALE_PST, 13 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 14 SCALE_PST, 20 SCALE_PST, 24 SCALE_PST, 26 SCALE_PST, 26 SCALE_PST, 24 SCALE_PST, 20 SCALE_PST, 14 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 11 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 11 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 14 SCALE_PST, 12 SCALE_PST, 8 SCALE_PST, 2 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, -10 SCALE_PST, -4 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, -4 SCALE_PST, -10 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -27 SCALE_PST, -21 SCALE_PST, -17 SCALE_PST, -15 SCALE_PST, -15 SCALE_PST, -17 SCALE_PST, -21 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameBishopSquareTableD = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -27 SCALE_PST, -21 SCALE_PST, -17 SCALE_PST, -15 SCALE_PST, -15 SCALE_PST, -17 SCALE_PST, -21 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, -10 SCALE_PST, -4 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, -4 SCALE_PST, -10 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 14 SCALE_PST, 12 SCALE_PST, 8 SCALE_PST, 2 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, 11 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 11 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 14 SCALE_PST, 20 SCALE_PST, 24 SCALE_PST, 26 SCALE_PST, 26 SCALE_PST, 24 SCALE_PST, 20 SCALE_PST, 14 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 13 SCALE_PST, 19 SCALE_PST, 23 SCALE_PST, 25 SCALE_PST, 25 SCALE_PST, 23 SCALE_PST, 19 SCALE_PST, 13 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, 20 SCALE_PST, 20 SCALE_PST, 18 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 4 SCALE_PST, 8 SCALE_PST, 10 SCALE_PST, 10 SCALE_PST, 8 SCALE_PST, 4 SCALE_PST, -2 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable BishopSquareTableL = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, -24 SCALE_PST, -23 SCALE_PST, 30 SCALE_PST, 58 SCALE_PST, 65 SCALE_PST, 61 SCALE_PST, 69 SCALE_PST, 11 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 7 SCALE_PST, 27 SCALE_PST, 20 SCALE_PST, 56 SCALE_PST, 91 SCALE_PST, 108 SCALE_PST, 53 SCALE_PST, 44 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, -1 SCALE_PST, 16 SCALE_PST, 29 SCALE_PST, 27 SCALE_PST, 37 SCALE_PST, 27 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, 1 SCALE_PST, 5 SCALE_PST, 23 SCALE_PST, 32 SCALE_PST, 21 SCALE_PST, 8 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 5 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 13 SCALE_PST, 10 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 15 SCALE_PST, 5 SCALE_PST, 13 SCALE_PST, -10 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, -8 SCALE_PST, -37 SCALE_PST, -31 SCALE_PST, -8 SCALE_PST, -45 SCALE_PST, -67 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable BishopSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, -8 SCALE_PST, -37 SCALE_PST, -31 SCALE_PST, -8 SCALE_PST, -45 SCALE_PST, -67 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 15 SCALE_PST, 5 SCALE_PST, 13 SCALE_PST, -10 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 5 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 13 SCALE_PST, 10 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 1 SCALE_PST, 5 SCALE_PST, 23 SCALE_PST, 32 SCALE_PST, 21 SCALE_PST, 8 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -1 SCALE_PST, 16 SCALE_PST, 29 SCALE_PST, 27 SCALE_PST, 37 SCALE_PST, 27 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, 7 SCALE_PST, 27 SCALE_PST, 20 SCALE_PST, 56 SCALE_PST, 91 SCALE_PST, 108 SCALE_PST, 53 SCALE_PST, 44 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, -24 SCALE_PST, -23 SCALE_PST, 30 SCALE_PST, 58 SCALE_PST, 65 SCALE_PST, 61 SCALE_PST, 69 SCALE_PST, 11 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameKnightSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -21 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -21		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -2 SCALE_PST, 17 SCALE_PST, 30 SCALE_PST, 36 SCALE_PST, 36 SCALE_PST, 30 SCALE_PST, 17 SCALE_PST, -2			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -22			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -46 SCALE_PST, -27 SCALE_PST, -15 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -15 SCALE_PST, -27 SCALE_PST, -46		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -81 SCALE_PST, -62 SCALE_PST, -49 SCALE_PST, -43 SCALE_PST, -43 SCALE_PST, -49 SCALE_PST, -62 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 	-99 SCALE_PST, -99 SCALE_PST, -94 SCALE_PST, -88 SCALE_PST, -88 SCALE_PST, -94 SCALE_PST, -99 SCALE_PST, -99 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameKnightSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 	-99 SCALE_PST, -99 SCALE_PST, -94 SCALE_PST, -88 SCALE_PST, -88 SCALE_PST, -94 SCALE_PST, -99 SCALE_PST, -99 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -81 SCALE_PST, -62 SCALE_PST, -49 SCALE_PST, -43 SCALE_PST, -43 SCALE_PST, -49 SCALE_PST, -62 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -46 SCALE_PST, -27 SCALE_PST, -15 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -15 SCALE_PST, -27 SCALE_PST, -46		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -22			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -2 SCALE_PST, 17 SCALE_PST, 30 SCALE_PST, 36 SCALE_PST, 36 SCALE_PST, 30 SCALE_PST, 17 SCALE_PST, -2			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -21 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -21		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable KnightSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -60 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0			       SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -34 SCALE_PST, 24 SCALE_PST, 54 SCALE_PST, 74 SCALE_PST, 60 SCALE_PST, 122 SCALE_PST, 2 SCALE_PST, 29		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, 18 SCALE_PST, 60 SCALE_PST, 64 SCALE_PST, 124 SCALE_PST, 143 SCALE_PST, 55 SCALE_PST, 6		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, -4 SCALE_PST, 25 SCALE_PST, 33 SCALE_PST, 10 SCALE_PST, 33 SCALE_PST, 14 SCALE_PST, 43		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 19 SCALE_PST, 12 SCALE_PST, 33 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -38 SCALE_PST, -16 SCALE_PST, 0 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, -42		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -56 SCALE_PST, -31 SCALE_PST, -28 SCALE_PST, -1 SCALE_PST, -7 SCALE_PST, -20 SCALE_PST, -42 SCALE_PST, -11	   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -99 SCALE_PST, -30 SCALE_PST, -66 SCALE_PST, -64 SCALE_PST, -29 SCALE_PST, -19 SCALE_PST, -61 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KnightSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -99 SCALE_PST, -30 SCALE_PST, -66 SCALE_PST, -64 SCALE_PST, -29 SCALE_PST, -19 SCALE_PST, -61 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -56 SCALE_PST, -31 SCALE_PST, -28 SCALE_PST, -1 SCALE_PST, -7 SCALE_PST, -20 SCALE_PST, -42 SCALE_PST, -11	   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -38 SCALE_PST, -16 SCALE_PST, 0 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, -42		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 19 SCALE_PST, 12 SCALE_PST, 33 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, -4 SCALE_PST, 25 SCALE_PST, 33 SCALE_PST, 10 SCALE_PST, 33 SCALE_PST, 14 SCALE_PST, 43		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, 18 SCALE_PST, 60 SCALE_PST, 64 SCALE_PST, 124 SCALE_PST, 143 SCALE_PST, 55 SCALE_PST, 6		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -34 SCALE_PST, 24 SCALE_PST, 54 SCALE_PST, 74 SCALE_PST, 60 SCALE_PST, 122 SCALE_PST, 2 SCALE_PST, 29		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -60 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

#define PAWN_SCALE /2

#define HAIR_PAWNS

#ifndef HAIR_PAWNS
const PieceSquareTable PawnSquareTableL =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable EndgamePawnSquareTableL =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable PawnSquareTableD =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable EndgamePawnSquareTableD =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
#else
const PieceSquareTable PawnSquareTableL =
{
	//A1                                H1
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0                 PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 118 PAWN_SCALE, 121 PAWN_SCALE, 173 PAWN_SCALE, 168 PAWN_SCALE, 107 PAWN_SCALE, 82 PAWN_SCALE, -16 PAWN_SCALE, 22	  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 21 PAWN_SCALE, 54 PAWN_SCALE, 72 PAWN_SCALE, 56 PAWN_SCALE, 77 PAWN_SCALE, 95 PAWN_SCALE, 71 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 9 PAWN_SCALE, 30 PAWN_SCALE, 23 PAWN_SCALE, 31 PAWN_SCALE, 31 PAWN_SCALE, 23 PAWN_SCALE, 17 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 14 PAWN_SCALE, 8 PAWN_SCALE, 4 PAWN_SCALE, 5 PAWN_SCALE, 4 PAWN_SCALE, 10 PAWN_SCALE, 7				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 1 PAWN_SCALE, -6 PAWN_SCALE, -19 PAWN_SCALE, -6 PAWN_SCALE, -7 PAWN_SCALE, -4 PAWN_SCALE, 10		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, -1 PAWN_SCALE, -7 PAWN_SCALE, -11 PAWN_SCALE, -35 PAWN_SCALE, -13 PAWN_SCALE, 5 PAWN_SCALE, 3 PAWN_SCALE, -5		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	//A8                                H8
};

const PieceSquareTable PawnSquareTableD =
{
	//A1                                H1
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0                 PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, -1 PAWN_SCALE, -7 PAWN_SCALE, -11 PAWN_SCALE, -35 PAWN_SCALE, -13 PAWN_SCALE, 5 PAWN_SCALE, 3 PAWN_SCALE, -5		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 1 PAWN_SCALE, -6 PAWN_SCALE, -19 PAWN_SCALE, -6 PAWN_SCALE, -7 PAWN_SCALE, -4 PAWN_SCALE, 10		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 14 PAWN_SCALE, 8 PAWN_SCALE, 4 PAWN_SCALE, 5 PAWN_SCALE, 4 PAWN_SCALE, 10 PAWN_SCALE, 7				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 9 PAWN_SCALE, 30 PAWN_SCALE, 23 PAWN_SCALE, 31 PAWN_SCALE, 31 PAWN_SCALE, 23 PAWN_SCALE, 17 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 21 PAWN_SCALE, 54 PAWN_SCALE, 72 PAWN_SCALE, 56 PAWN_SCALE, 77 PAWN_SCALE, 95 PAWN_SCALE, 71 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 118 PAWN_SCALE, 121 PAWN_SCALE, 173 PAWN_SCALE, 168 PAWN_SCALE, 107 PAWN_SCALE, 82 PAWN_SCALE, -16 PAWN_SCALE, 22	  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	//A8                                H8
};

#define END_PAWN_SCALE +30
const PieceSquareTable EndgamePawnSquareTableL =
{
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
};

const PieceSquareTable EndgamePawnSquareTableD =
{
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
};
#endif
const signed int * SquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingMidSquareTableL,
	KingMidSquareTableL,
	KingMidSquareTableL,
	PawnSquareTableL,
	PawnSquareTableL,
	KnightSquareTableL,
	BishopSquareTableL,
	RookSquareTableL,
	RookSquareTableL,
	EmptySquareTable,//QueenSquareTableL, bad
};
const signed int * SquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingMidSquareTableD,
	KingMidSquareTableD,
	KingMidSquareTableD,
	PawnSquareTableD,
	PawnSquareTableD,
	KnightSquareTableD,
	BishopSquareTableD,
	RookSquareTableD,
	RookSquareTableD,
	EmptySquareTable,//QueenSquareTableD, bad
};

const signed int * EndgameSquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
		KingEndSquareTableL, 
		KingEndSquareTableL,  
		KingEndSquareTableL, 
		EndgamePawnSquareTableL,
		EndgamePawnSquareTableL,
		EndgameKnightSquareTableL, 
		EndgameBishopSquareTableL,
		EndgameRookSquareTableL,
		EndgameRookSquareTableL,
	EndgameQueenSquareTableL, //ok
};

const signed int * EndgameSquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
		KingEndSquareTableD, 
		KingEndSquareTableD,  
		KingEndSquareTableD, 
		EndgamePawnSquareTableD,
		EndgamePawnSquareTableD,
		EndgameKnightSquareTableD, 
		EndgameBishopSquareTableD,
		EndgameRookSquareTableD,
		EndgameRookSquareTableD,
	EndgameQueenSquareTableD, //ok
};

const Pos HomeRow[2][8] = { { a1,b1,c1,d1,e1,f1,g1,h1 } ,{ a8,b8,c8,d8,e8,f8,g8,h8 } };
const Pos PawnsRow[2][8] = { { a2,b2,c2,d2,e2,f2,g2,h2 } ,{ a7,b7,c7,d7,e7,f7,g7,h7 } };

#define POINT_THREATS 0
#define EXPANDING_THREATS 1

const Pos PAWN_L_THREAT_DESC[] = { POINT_THREATS,2,-9,-11 };
const Pos PAWN_D_THREAT_DESC[] = { POINT_THREATS,2,9,11 };
const Pos KNIGHT_THREAT_DESC[] = { POINT_THREATS,8,-21,-19, -12, -8, +12, +8, +21, +19 };
const Pos QUEEN_THREAT_DESC[] = { EXPANDING_THREATS,8,-10,+10, -1, +1,+9,+11,-9,-11 };
const Pos KING_THREAT_DESC[] = { POINT_THREATS,8,-10,+10, -1, +1,+9,+11,-9,-11 };
const Pos ROOK_THREAT_DESC[] = { EXPANDING_THREATS,4,-10,+10, -1, +1 };
const Pos BISHOP_THREAT_DESC[] = { EXPANDING_THREATS,4,+9,+11,-9,-11 };

int PersistantValue;
int EphemeralValue;

int CurrentPly=0;
PlayersType Players;
#ifdef NDEBUG
#define board_consistent()
#define massert(a) 
#else

void print_board();
void log_board();

void do_assertion(const char *n)
{
	printf("\nFailed %s\n", n);
	LOG(Log << "\n**** Failed " << n << endl);
	//	log_board();
	print_board();
	//	abort();
}

#define massert(a) if (!(a)) do_assertion(#a)

int PlayersReferences[NUM_PIECE_SLOTS];

void board_consistent()
{
	for (int i = 0;i < NUM_PIECE_SLOTS;++i)PlayersReferences[i] = 0;
	for (Pos i = a8;i <= h1;++i) {
		if (Board[i] != NO_SLOT && Board[i] != OFF_BOARD) {
			massert(i == Players.positions[Board[i]]);
			massert(Players.pieces[Board[i]] != EMPTY);
			if (Board[i] != NO_SLOT && Board[i] != OFF_BOARD) {
				++PlayersReferences[Board[i]];
				massert(PlayersReferences[Board[i]] == 1);
			}
		}
	}
	for (PieceSlotType i = LIGHT_PAWN1; i <= LIGHT_KINGP;i = (PieceSlotType)(i + 1))
	{
		massert(Players.pieces[i] >= EMPTY && Players.pieces[i] < NUM_PIECE_TYPES);
		if (Players.pieces[i] != EMPTY) { massert(Board[Players.positions[i]] == i); }
	}
	for (PieceSlotType i = DARK_PAWN1; i <= DARK_KINGP;i = (PieceSlotType)(i + 1))
	{
		massert(Players.pieces[i] >= EMPTY && Players.pieces[i] < NUM_PIECE_TYPES);
		if (Players.pieces[i] != EMPTY) { massert(Board[Players.positions[i]] == i); }
	}
	//	eval();
}

#endif

inline void set_position(Pos p, PieceSlotType s)
{
	Board[p] = s;
	Players.positions[s] = p;
}


inline bool is_piece(Pos p)
{
	return is_piece(Board[p]);
}

int brand()
{
	int j = rand() & 15;
	while (j--)rand();
	return rand();
}
uint64_t rand64() {

	return brand() ^ ((uint64_t)brand() << 15) ^ ((uint64_t)brand() << 30) ^ ((uint64_t)brand() << 45) ^ ((uint64_t)brand() << 60);
}

#define SMALL_HASH

#ifdef SMALL_HASH
struct HashType
{
	uint64_t low;
	void rand() {
		low = rand64();
	}
	int high_mask() { return (int)(low >> 32); }
	void clear()
	{
		low = 0;
	}
	void operator ^=(const HashType &o)
	{
		low ^= o.low;
	}
	HashType operator ^ (const HashType &o)
	{
		return HashType{ low ^ o.low };
	}

	bool operator == (const HashType & o) const
	{
		return low == o.low;
	}
	bool is_zero() const
	{
		return low == 0;
	}
};
#else
struct HashType
{
	uint64_t low;
	uint64_t high;
	void rand() {
		low = rand64();
		high = rand64();
	}
	int high_mask() { return (int)high; }
	void clear()
	{
		low = high = 0;
	}
	void operator ^=(const HashType &o)
	{
		low ^= o.low;
		high ^= o.high;
	}
	HashType operator ^ (const HashType &o)
	{
		return HashType{ low ^ o.low, high ^ o.high };
	}

	bool operator == (const HashType & o) const
	{
		return low == o.low && high == o.high;
	}
	bool is_zero() const
	{
		return low == 0 && high == 0;
	}
};

#endif
HashType Hash;
//one clears the hash by incrementing this by the maximum number of moves per game
int ClearHash = 0;
Colors _PlySide = LIGHT;
HashType LightHash;
inline Colors PlySide()
{
	return _PlySide;
}
inline void set_PlySide(Colors c)
{
	if (c != _PlySide) {
		_PlySide = c;
		Hash ^= LightHash;
	}
}

const Pos SquareToRowIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1,1,0,
	0,2,2,2,2,2,2,2,2,0,
	0,3,3,3,3,3,3,3,3,0,
	0,4,4,4,4,4,4,4,4,0,
	0,5,5,5,5,5,5,5,5,0,
	0,6,6,6,6,6,6,6,6,0,
	0,7,7,7,7,7,7,7,7,0,
	0,8,8,8,8,8,8,8,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,

};
//for increments +/-10
const Pos SquareToColIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

const Pos SquareToDiagLeftIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,8,9,10,11,12,13,14,15,0,
	0,7,8,9,10,11,12,13,14,0,
	0,6,7,8,9,10,11,12,13,0,
	0,5,6,7,8,9,10,11,12,0,
	0,4,5,6,7,8,9,10,11,0,
	0,3,4,5,6,7,8,9,10,0,
	0,2,3,4,5,6,7,8,9,0,
	0,1,2,3,4,5,6,7,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

//for increments +/-9
const Pos SquareToDiagRightIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,2,3,4,5,6,7,8,0,
	0,2,3,4,5,6,7,8,9,0,
	0,3,4,5,6,7,8,9,10,0,
	0,4,5,6,7,8,9,10,11,0,
	0,5,6,7,8,9,10,11,12,0,
	0,6,7,8,9,10,11,12,13,0,
	0,7,8,9,10,11,12,13,14,0,
	0,8,9,10,11,12,13,14,15,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

Pos RookDirection[h1 + 1][h1 + 1];
Pos BishopDirection[h1 + 1][h1 + 1];
Pos QueenDirection[h1 + 1][h1 + 1];
Pos KingDirection[h1 + 1][h1 + 1];
Pos KnightDirection[h1 + 1][h1 + 1];

void init_direction_tables()
{
	for (int i = 0;i <= h1;++i)
		for (int j = 0;j <= h1;++j)
			RookDirection[i][j] = BishopDirection[i][j] = QueenDirection[i][j] = KingDirection[i][j] = KnightDirection[i][j] = 0;

	for (int i = 0;i <= h1;++i) {
		if (SquareToRowIndex[i] == 0) continue;
		for (int j = 0;j <= h1;++j) {
			if (SquareToRowIndex[j] == 0) continue;
			if (SquareToColIndex[i] != 0 && SquareToColIndex[i] == SquareToColIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -10;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 10;
			}
			if (SquareToRowIndex[i] != 0 && SquareToRowIndex[i] == SquareToRowIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -1;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 1;
			}
			if (SquareToDiagLeftIndex[i] != 0 && SquareToDiagLeftIndex[i] == SquareToDiagLeftIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -11;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 11;
			}
			if (SquareToDiagRightIndex[i] != 0 && SquareToDiagRightIndex[i] == SquareToDiagRightIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -9;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 9;
			}
			if (abs(SquareToRowIndex[i] - SquareToRowIndex[j]) <= 1
				&& abs(SquareToColIndex[i] - SquareToColIndex[j]) <= 1
				&& i != j) {
				KingDirection[i][j] = j - i;
			}
			if ((abs(SquareToRowIndex[i] - SquareToRowIndex[j]) == 3
				&& abs(SquareToColIndex[i] - SquareToColIndex[j]) == 2)
				|| (abs(SquareToRowIndex[i] - SquareToRowIndex[j]) == 2
					&& abs(SquareToColIndex[i] - SquareToColIndex[j]) == 3)) {
				KnightDirection[i][j] = j - i;
			}
		}
	}

}



bool in_front_of_king(PieceSlotType s)
{
	if (!is_piece(s)) return false;
	if (color(s) == LIGHT) {
		return SquareToRowIndex[Players.positions[s]] < SquareToRowIndex[Players.positions[KINGP + base_by_color(color(s))]];
	}
	else {
		return SquareToRowIndex[Players.positions[s]] > SquareToRowIndex[Players.positions[KINGP + base_by_color(color(s))]];
	}
}
int horizontal_distance_from_king(PieceSlotType s)
{
	return abs(SquareToColIndex[Players.positions[s]] - SquareToColIndex[Players.positions[KINGP + base_by_color(color(s))]]);
}
int horizontal_distance_from_king(PieceSlotType s,Pos p)
{
	return abs(SquareToColIndex[p] - SquareToColIndex[Players.positions[KINGP + base_by_color(color(s))]]);
}

//return 0 for directly in front, 1 for one away, >1 for not shielding king
int shielding_king(PieceSlotType s)
{
	if (in_front_of_king(s)) return horizontal_distance_from_king(s);
	return 8;
}

int shielding_king(PieceSlotType s, Pos p)
{
	if (in_front_of_king(s)) return horizontal_distance_from_king(s,p);
	return 8;
}

inline void add_bonus(Colors side, short bonus)
{
	if (side == PlySide()) EphemeralValue += bonus;
	else EphemeralValue -= bonus;
}

int ways_can_castle(Colors side)
{
	if (Players.pieces[KINGP + base_by_color(side)] != KING_NOT_MOVED) return 0;
	return (Players.pieces[ROOK1 + base_by_color(side)] == ROOK_NOT_MOVED ? 1 : 0) + (Players.pieces[ROOK2 + base_by_color(side)] == ROOK_NOT_MOVED ? 1 : 0);
}

inline int count_slot(int s)
{
	return  Players.pieces[s] == EMPTY ? 0 : 1;
}


bool SideInEndgame(Colors s)
{
	//return MaterialSums[other_color(s)][MAJOR_MINOR_COUNT] <= (QUEEN_VALUE + KNIGHT_VALUE);
	
	PieceSlotType base = base_by_color(other_color(s));
	return Players.pieces[QUEENP + base] == EMPTY || (
	2 > count_slot(ROOK1 + base) + count_slot(ROOK2 + base) + count_slot(QUEENP + base)
	&& 2 > count_slot(BISHOP1 + base) + count_slot(BISHOP2 + base)
	+ count_slot(KNIGHT1 + base) + count_slot(KNIGHT1 + base));
	
}


struct Move
{
	enum CheckForEnpassantEnum { CheckForEnpassant, DoEnpassant };
	enum Castling : char { NotCastling, CastleLeft, CastleRight };

	Pos from;
	Pos to;
	Pos taken_at; //different than to in case of enpassant
	PieceType initial;
	PieceType became;  //promotion or transition
	PieceSlotType slot_taken;
	PieceType piece_taken;
	Castling castling;
//	int see;
	short bonus;
//	short perm_bonus;
//	HashType hash;
	DEFLINE
	Move &set_bonus(short b) { bonus = b; return *this; }

	void movement_bonuses()
	{
		const Colors my_side = color(Board[from]);
		if (//my_side == computer_side && 
			piece_taken != EMPTY) bonus += 5;//transaction bonus to make computer aggressive
		const Colors other_side = other_color(my_side);
		/*
		int material_threat = MaterialSums[other_side][MAJOR_MINOR_COUNT];
		if (is_pawn(piece_taken)) {
			switch (shielding_king(slot_taken)) {
			case 0: bonus += 40* material_threat>>12; break;
			case 1: bonus += 20 * material_threat >> 12;
			}
		}
		if (is_pawn(initial)) {
			int shielding = shielding_king(Board[from]);
			if (shielding < 2) {
				int to_shielding = shielding_king(Board[from], to);
				if (to_shielding > shielding) {
					switch (shielding) {
					case 0: bonus -= 20 * material_threat >> 12; break;
					case 1: bonus -= 40 * material_threat >> 12;
					}
				}
				else {
					switch (shielding) {
					case 0: bonus -= 20 * material_threat >> 12; break;
					case 1: bonus -= 10 * material_threat >> 12;
					}
				}
			}
		}
*/
		if (!SideInEndgame(my_side)) {
			int material_threat = MaterialSums[other_side][MAJOR_MINOR_COUNT];
			if (castling == NotCastling) {
				if (initial == KING_NOT_MOVED || initial == ROOK_NOT_MOVED) {
					switch (ways_can_castle(color(Board[from]))) {
					case 1: bonus -= 30* material_threat>>11; break;
					case 2: if (initial == KING_NOT_MOVED) bonus -= 60 * material_threat >> 11; else bonus -= 30 * material_threat >> 11;
					}
				}
				else if (became == KING || became == KING_CASTLED) bonus -= 5* material_threat >> 11;
			}
		}
	}
	void clear() { from = 0; }
	bool operator == (const Move &o) {
		if (from != o.from) return false;
		return (to == o.to && became == o.became)|| from == 0;
	}
	bool empty() const {
		return from == 0;
	}
	Move():from(0) {}
	//	Move(Pos f, Pos t) :from(f), to(t), initial(EMPTY), promotion(EMPTY) {}
	Move(Pos f, Pos t PARAMLINE);
	Move(Pos f, Pos t, Castling c PARAMLINE);
	Move(Pos f, Pos t, PieceType type PARAMLINE);

	bool is_enpassant() { return to != taken_at; }
	Move(Pos f, Pos t, Pos enpassant_pos, CheckForEnpassantEnum PARAMLINE);
	//from other player
	Move(Pos f, Pos t, CheckForEnpassantEnum PARAMLINE);

	Move(const Move &m);
	void operator = (const Move &m);
	Move(Move &&m);
	void make();
	void unmake();
	//in place moves used to change pawn type to mark vulnerablity to enpassant
	//and transition to endgame (changing king type)
	bool not_move() { return from == to; }
};

struct RelativeMove
{
	PieceSlotType from;
	PieceSlotType slot_taken;
	Pos from_pos;
	Pos to;
	PieceType promotion;
	RelativeMove(const Move &m) :from(m.from==0?NO_SLOT:Board[m.from]), from_pos(m.from), to(m.to), promotion(m.became),
		slot_taken(m.slot_taken){}
	void operator = (const RelativeMove &m)
	{
		from = m.from;
		slot_taken = m.slot_taken;
		from_pos = m.from_pos;
		to = m.to;
		promotion = m.promotion;
	}

	void operator = (const Move &m) 
	{
		from_pos = m.from;
		slot_taken = m.slot_taken;
		from = m.from == 0 ? NO_SLOT : Board[m.from];
		to = m.to; 
		promotion = m.became;
	}
	RelativeMove() :from(NO_SLOT) {}
	RelativeMove(const RelativeMove &m) :from(m.from),from_pos(m.from_pos), to(m.to), promotion(m.promotion) {}
	bool operator == (const RelativeMove &m) const
	{
		return (from == NO_SLOT && m.from == NO_SLOT) || (from == m.from && from_pos==m.from_pos && to == m.to && slot_taken==m.slot_taken 
			&& promotion == m.promotion);
	}
	bool operator == (const Move &m) const
	{
		return (from == NO_SLOT && m.from == 0) || (from != NO_SLOT && from_pos==m.from &&  slot_taken == m.slot_taken 
			&& from == Board[m.from] && to == m.to && promotion == m.became);
	}
	bool empty() const { return from == NO_SLOT; }
	void clear() { from = NO_SLOT; }
};

struct ImmediateMoveList {
	Move moves[MAX_MOVES_PER_PLY];
	//	int delta[MAX_MOVES_PER_PLY];
	int base; //clear in order_moves()
	ImmediateMoveList() :base(0) {}
	void clear()
	{
		base = 0;
	}
	void push(Move m)
	{
		moves[base++] = m;
	}
	Move &back()
	{
		return moves[base - 1];
	}
	bool empty() const { return base == 0; }
	void pop() { --base; }
};

struct SortingMoveList {
	struct Entry {
		int index;
		int key;
	};
	Entry entries[MAX_MOVES_PER_PLY];
	Move moves[MAX_MOVES_PER_PLY];
	int base; //clear in order_moves()
	SortingMoveList() :base(0) {}
	void clear()
	{
		base = 0;
	}
	void push(Move m, int key)
	{
		moves[base] = m;
//		moves[base].see = key;
		entries[base].index = base;
		entries[base++].key = key;
	}
	int back_value()
	{
		return entries[base - 1].key;
	}
	Move &back()
	{
		return moves[entries[base - 1].index];
	}
	static int comp(const void * elem1, const void * elem2)
	{
		const Entry * const f = ((Entry*)elem1);
		const Entry * const s = ((Entry*)elem2);
		return s->key - f->key;//reversed
	}
	void sort()
	{
		if (base > 1)
			qsort(&entries[0], base, sizeof(entries) / MAX_MOVES_PER_PLY, comp);
	}
	bool empty() const { return base == 0; }
	void pop() { --base; }
};

int history_len=0;

struct HH
{
	int time;
	long long value;
	void set(int v)
	{
		if (time != history_len + ClearHash) value = v;//v*v;
		else value += v;
		time = history_len + ClearHash;
	}
	long long get()
	{
		if (time != history_len + ClearHash) return 0;
		return value;
	}
	HH()
	{
		time = -1;
		value = 0;
	}
};



HH EmptyHH;
HH HHTable[(NUM_PIECE_SLOTS+1)*(NUM_PIECE_SLOTS+1)*(h1 - a8 + 1) * 2 * (h1 - a8 + 1)];
HH &GetHH(bool quiescent, RelativeMove &r)
{
	if (r.from == NO_SLOT) return EmptyHH;
	//	return CounterMoveTable[s + (h1 - a8 + 1)*(from - a8) + ((h1 - a8 + 1)*(h1 - a8 + 1))*(to - a8)];
	HH & h = HHTable[(r.to - a8) + (h1 - a8 + 1)*((r.from_pos - a8) + (h1 - a8 + 1)*(r.from + NUM_PIECE_SLOTS*(r.slot_taken + (quiescent ? NUM_PIECE_SLOTS : 0)
		)))];
	//massert(h.magic == 1238972149);
	return h;
}

Move EmptyM;
#define LONGINF ((long long)1<<59)
struct MoveList {
	struct Entry {
		int index;
		int key;
	};
	Move moves[MAX_MOVES_PER_PLY*MAX_PLY];
	long long value[MAX_MOVES_PER_PLY*MAX_PLY];
	int base[MAX_PLY];
	int best_index[MAX_PLY];
	int second_best_index[MAX_PLY];
	int third_best_index[MAX_PLY];
	int fourth_best_index[MAX_PLY];
	int ply;
	MoveList() :ply(0) { base[0] = 0; }
	void inc_ply()
	{
		base[ply + 1] = base[ply];
		ply = ply + 1;
		best_index[ply] = -1;
		second_best_index[ply] = -1;
		third_best_index[ply] = -1;
		fourth_best_index[ply] = -1;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void dec_ply() { ply = ply - 1; }
	void push(Move m)
	{
		moves[base[ply]++] = m;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void push(Move m, int v)
	{
		value[base[ply]] = v;
		moves[base[ply]++] = m;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void push_list(ImmediateMoveList &i)
	{
		while (!i.empty()) {
			push(i.back());
			i.pop();
		}
	}
	void push_list(SortingMoveList &i)
	{
		i.sort();
		while (!i.empty()) {
			push(i.back(),i.back_value());
			i.pop();
		}
	}
	int index() 
	{
		return base[ply];
	}
	void add_history(bool q)
	{
//		if (CurrentPly > 10) return;
		for (int i = first();i < base[ply]; ++i) {
			if (!moves[i].empty()) {
				value[i] += GetHH(q, RelativeMove(moves[i])).get()<<10;
			}
		}
		best_index[ply] = second_best_index[ply] = third_best_index[ply] = fourth_best_index[ply] = -1;
	}
	bool find_best()
	{
		if (best_index[ply] != -1) {
			best().clear();
		}
		if (second_best_index[ply] != -1) {
			best_index[ply] = second_best_index[ply];
			second_best_index[ply] = -1;
			return true;
		}
		if (third_best_index[ply] != -1) {
			best_index[ply] = third_best_index[ply];
			third_best_index[ply] = -1;
			return true;
		}
		if (fourth_best_index[ply] != -1) {
			best_index[ply] = fourth_best_index[ply];
			fourth_best_index[ply] = -1;
			return true;
		}
		while (!empty() && back().empty()) pop();
		if (empty()) return false;
		long long v = -LONGINF;
		int index = -1;
		int second = -1;
		int third = -1;
		int fourth = -1;
		for (int i = first();i < base[ply]; ++i) {
			if (!moves[i].empty() && value[i] > v) {
				fourth = third;
				third = second;
				second = index;
				index = i;
				v = value[i];
			}
		}
		best_index[ply] = index;
		second_best_index[ply] = second;
		third_best_index[ply] = third;
		fourth_best_index[ply] = fourth;
		return v != -LONGINF;
	}
	bool no_best()
	{
		return best_index[ply] == -1;
	}
	Move &best()
	{
		if (best_index[ply] == -1) return EmptyM;
		return moves[best_index[ply]];
	}
	int best_value()
	{
		return value[best_index[ply]];
	}
	int back_value()
	{
		return value[base[ply] - 1];
	}
	Move &back()
	{
		return moves[base[ply] - 1];
	}
	bool empty() const { return base[ply] == 0 || (ply != 0 && base[ply] == base[ply - 1]); }
	void pop() { --base[ply]; }
	void clear() {
		ply = 0;
		base[0] = 0;
		best_index[0] = -1;
		second_best_index[0] = -1;
		third_best_index[0] = -1;
		fourth_best_index[0] = -1;
	}
	int first()
	{
		if (ply > 0) return base[ply - 1];
		return 0;
	}
	int end()
	{
		return base[ply];
	}
	Move &operator [] (int i) { return moves[i]; }
};


HashType ZobristSource[NUM_PIECE_TYPES*NUM_COLORS*BOARD_SIZE];
//HashType ColorsZobrist[NUM_COLORS];
inline int ZobristIndex(Colors c, PieceType p, Pos b)
{
	return c + (p << 1) + b*(NUM_COLORS*NUM_PIECE_TYPES);
}

inline int ZobristIndex(PieceSlotType s)
{
	return ZobristIndex(color(s), Players.pieces[s], Players.positions[s]);
}

inline void update_hash(PieceSlotType s)
{
	Hash ^= ZobristSource[ZobristIndex(s)];
}

void update_hash(Pos p)
{
	update_hash(Board[p]);
	assert(is_piece(Players.pieces[Board[p]]) || ZobristSource[ZobristIndex(Board[p])].is_zero());
#ifndef NDEBUG
	if (Board[p] == OFF_BOARD || Board[p] == NO_SLOT) assert(ZobristSource[ZobristIndex(Board[p])].is_zero());
#endif
}


void init_zobrist()
{

	LightHash.rand();
	//ColorsZobrist[LIGHT].rand();
	//ColorsZobrist[DARK].rand();

	for (int i = 0;i < NUM_PIECE_TYPES;++i)
		for (int c = 0;c < NUM_COLORS;++c) {
			for (int j = 0;j < BOARD_SIZE;++j)
				if (is_piece((PieceType)i)) ZobristSource[ZobristIndex((Colors)c,(PieceType)i,(Pos)j)].rand();
				else ZobristSource[ZobristIndex((Colors)c, (PieceType)i, (Pos)j)].clear();
#ifdef GEN_ZOBRIST			
				Log << "\n uint64_t ZobristSource[NUM_PIECE_TYPES][BOARD_SIZE] = \n{\n" << hex;
				for (int i = 0;i < NUM_PIECE_TYPES;++i) {
					Log << "{";
					for (int j = 0;j < BOARD_SIZE;++j) {
						if (j % 10 == 0) Log << endl;
						Log << "0x" << ZobristSource[i][j] << ", ";
					}
					Log << "},\n";
				}
				Log << "}\n" << dec;
#endif
		}
}

ImmediateMoveList Promotions;
ImmediateMoveList KingThreats;
SortingMoveList Captures;
ImmediateMoveList VanillaMoves;
MoveList MovesOrdered;
MoveList MovesIID;

bool sort_pv(Move &m)
{
	const int first = MovesOrdered.first(), end = MovesOrdered.end();
	for (int i = first; i < end; ++i)
		if (MovesOrdered[i].from == m.from && MovesOrdered[i].to == m.to) {
			MovesOrdered.push(MovesOrdered[i],MovesOrdered.value[i]);
			MovesOrdered[i].clear();
			return true;
		}
	return false;
}


Move History[MAX_MOVES];

#define REPEAT_BINS_LN2 12
#define REPEAT_BIN_LEN_LN2 4

#define REPEAT_BINS (1<<REPEAT_BINS_LN2)
#define REPEAT_BIN_LEN (1<<REPEAT_BIN_LEN_LN2)

struct RepeatBin
{
	int len;
	HashType list[REPEAT_BIN_LEN];
	RepeatBin() { clear(); }

	void clear() {
		len = 0;
	}
	int count(HashType hash) const
	{
		int sum = 0;
		for (int i = 0;i < len;++i) if (hash == list[i]) ++sum;
		return sum;
	}
	bool full() const { return len == REPEAT_BIN_LEN; }
	void add(HashType hash)
	{
		list[len++] = hash;
	}
	HashType back()
	{
		return list[len - 1];
	}
	void remove()
	{
		--len;
		massert(len >= 0);
	}
};


struct RepeatListStruct {
	int bin_history[MAX_MOVES];
	int history;
	RepeatBin bins[REPEAT_BINS];

	struct RepeatListStruct() {
		clear();
	}
	void clear()
	{
		for (int i = 0;i < REPEAT_BINS;++i) bins[i].clear();
		history = 0;
	}
	void add(HashType hash)
	{
		int bin = ((int)hash.low & (REPEAT_BINS - 1));
		while (bins[bin].full()) bin = ((bin + 1) & (REPEAT_BINS - 1));
		bins[bin].add(hash);
		bin_history[history++] = bin;
	//	assert(bins[bin_history[history - 1]].back() == Hash);
	}
	void add(Colors c)
	{
		if (PlySide() != c) add(Hash ^ LightHash);
		else add(Hash);
	}

	void remove()
	{
//		assert(bins[bin_history[history - 1]].back() == Hash);
		massert(history > 0);
		bins[bin_history[--history]].remove();
	}
	int count(HashType hash)
	{
		int sum = 0;
		int bin = ((int)hash.low & (REPEAT_BINS - 1));
		do {
			sum += bins[bin].count(hash);
			if (!bins[bin].full()) {
				//if (sum >= 3) cout << "%";
				return sum;
			}
			bin = ((bin + 1) & (REPEAT_BINS - 1));
		} while (true);
	}
	int count(Colors c)
	{
		if (PlySide() != c) return count(Hash ^ LightHash);
		return count(Hash);
	}

};

RepeatListStruct RepeatList;
Pos RankCalc[NUM_COLORS][BOARD_SIZE] = {
	{
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,1,1,1,0,
		0,2,2,2,2,2,2,2,2,0,
		0,3,3,3,3,3,3,3,3,0,
		0,4,4,4,4,4,4,4,4,0,
		0,5,5,5,5,5,5,5,5,0,
		0,6,6,6,6,6,6,6,6,0,
		0,7,7,7,7,7,7,7,7,0,
		0,8,8,8,8,8,8,8,8,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,

	},
	{
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,8,8,8,8,8,8,8,8,0,
		0,7,7,7,7,7,7,7,7,0,
		0,6,6,6,6,6,6,6,6,0,
		0,5,5,5,5,5,5,5,5,0,
		0,4,4,4,4,4,4,4,4,0,
		0,3,3,3,3,3,3,3,3,0,
		0,2,2,2,2,2,2,2,2,0,
		0,1,1,1,1,1,1,1,1,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,

	}
};

const Pos CenterManhattanDistance[BOARD_SIZE] = { // char is sufficient as well, also unsigned
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0, 6, 5, 4, 3, 3, 4, 5, 6, 0,
	0, 5, 4, 3, 2, 2, 3, 4, 5, 0,
	0, 4, 3, 2, 1, 1, 2, 3, 4, 0,
	0, 3, 2, 1, 0, 0, 1, 2, 3, 0,
	0, 3, 2, 1, 0, 0, 1, 2, 3, 0,
	0, 4, 3, 2, 1, 1, 2, 3, 4, 0,
	0, 5, 4, 3, 2, 2, 3, 4, 5, 0,
	0, 6, 5, 4, 3, 3, 4, 5, 6, 0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

int ManhattanDistance(Pos a, Pos b)
{
	return abs(SquareToRowIndex[a] - SquareToRowIndex[b]) + abs(SquareToColIndex[a] - SquareToColIndex[b]);
}

int ChebyshevDistance(Pos a, Pos b)
{
	const int rank_distance = abs(SquareToRowIndex[a] - SquareToRowIndex[b]);
	const int file_distance = abs(SquareToColIndex[a] - SquareToColIndex[b]);
	return __max(rank_distance, file_distance);
}


//47*CenterManhattanDistance[Players.posision[KINGP+other_base]]+16*(14-ManhattanDistance(Players.posision[KINGP_DARK],Players.posision[KINGP_LIGHT]);
//int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner)
//NumPins[c]=calc_pins(c, Players[KINGP+base].positions,Pins[c],Pinners[c]);
PieceSlotType Pinners[NUM_COLORS][8];
PieceSlotType Pins[NUM_COLORS][8];
int NumPins[NUM_COLORS];

Pos PawnsRank[NUM_COLORS][10];
int PawnsTemp[NUM_COLORS];
int NumPinMoves[NUM_COLORS];
Pos PinMoves[NUM_COLORS][64];


const int * pawn_tables[NUM_COLORS] = { EndgamePawnSquareTableL,EndgamePawnSquareTableD };

#define KP_SCALE 1.2

int eval_kp(Colors c, Colors o, Pos f)
{
	int r;

	if (PawnsRank[c][f] == 7)
		r = 0;
	else if (PawnsRank[c][f] == 6)
		r = (int)(-13* KP_SCALE);
	else if (PawnsRank[c][f] != 0)
		r = (int)(-26*KP_SCALE);
	else
		r = (int)(-33*KP_SCALE);

	if (PawnsRank[o][f] == 0)
		return r - (int)(20*KP_SCALE);
	else if (PawnsRank[o][f] == 2)
		return r - (int)(13*KP_SCALE);
	else if (PawnsRank[o][f] == 3)
		return r - (int)(7*KP_SCALE);
	return r;
}

int eval_king(Pos kc, Colors c, Colors o)
{
	int r = 0;
	if (kc < 4) {
		r = eval_kp(c, o, 1) + eval_kp(c, o, 2) + (eval_kp(c, o, 3) >> 1);
	}
	else if (kc > 5) {
		r = eval_kp(c, o, 8) + eval_kp(c, o, 7) + (eval_kp(c, o, 6) >> 1);
	}
	else {
		for (int i = kc - 1;i <= kc + 1;++i) {
			if (PawnsRank[o][i] == 0 && PawnsRank[c][i] == 0) r -= 13;
		}
	}
	return r*MaterialSums[o][MAJOR_MINOR_COUNT] >> 12;
}
int mobility(PieceSlotType s);
int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner);

int LowestPassed[NUM_COLORS];

bool Threatened(Colors c, Pos p);

bool KP_END[NUM_COLORS];
int pawn_weight[NUM_COLORS][8];
Colors PromotionTempo[10];
int SEE(Pos);
void calc_pawns()
{
	PawnsDirty = false;
	for (int i = 0;i < 10;++i) PromotionTempo[i] = NUM_COLORS;
	for (int i = PAWN1;i < NUM_PIECE_SLOTS;++i) Players.pinned[i] = NotPinned;
	PawnsTemp[LIGHT] = PawnsTemp[DARK] = 0;
	for (int c = LIGHT;c < NUM_COLORS;++c) {
/*
		int base = base_by_color((Colors)c);
		for (int r = PAWN1;r < NUM_UNCOLORED_PIECE_SLOTS;++r) {
			if (Players.pieces[base + r] != EMPTY) {
				PawnsTemp[c] += SEE(Players.positions[base+r]);
			}
		}
*/
		KP_END[c] = MaterialSums[c][MAJOR_MINOR_COUNT] == 0;
		LowestPassed[c] = 0;
		for (int r = PAWN1;r <= PAWN8 + 2;++r) {
			if (Players.pieces[base_by_color((Colors)c)+r] == EMPTY) {
				pawn_weight[c][r] = 0;
			}
			else pawn_weight[c][r] = 2;
			PawnsRank[c][r] = 0;
		}
	}
	for (int c = LIGHT;c < NUM_COLORS;++c) {
		int base = base_by_color((Colors)c);
		for (int r = PAWN1;r <= PAWN8;++r) {
			const Pos pp = Players.positions[r + base];
			if (pp != 0 && is_pawn(Players.pieces[r + base])) {
				const Pos pr = RankCalc[c][pp];
				const Pos col = SquareToColIndex[pp];
				if (pr > PawnsRank[c][col]) PawnsRank[c][col] = pr;
			}
		}
		if (Players.pieces[BISHOP1 + base] != EMPTY && Players.pieces[BISHOP2 + base] != EMPTY) PawnsTemp[c] += 30;
		if (Players.pieces[KNIGHT1 + base] != EMPTY && Players.pieces[KNIGHT2 + base] != EMPTY) PawnsTemp[c] += 30;
		NumPins[c] = calc_pins((Colors)c, Players.positions[KINGP + base], Pins[c], Pinners[c]);
		
		for (int j = NumPins[c]-1;j >=0;--j) {
			PawnsTemp[c] -= __max(ValuePerPiece[Players.pieces[Pins[c][j]]] - ValuePerPiece[Players.pieces[Pinners[c][j]]], 0) >> 4;
		}
		for (int r = KNIGHT1;r <= QUEENP;++r) {
			if (Players.pinned[r] != NotPinned) PawnsTemp[c] += mobility((PieceSlotType)(r + base));
		}
	}

	for (int c = LIGHT;c < NUM_COLORS;++c) {
		int base = base_by_color((Colors)c);
		int oc = other_color((Colors)c);
		int other_base = base_by_color((Colors)oc);

		// /*
		for (int r = PAWN1;r <= PAWN8;++r) {
			const Pos pp = Players.positions[r + base];
			if (pp != 0 && is_pawn(Players.pieces[r + base])) {
				const Pos pr = RankCalc[c][pp];
				const Pos col = SquareToColIndex[pp];
				if (PawnsRank[c][col] != pr) PawnsTemp[c] -= 10;//double pawn penalty
				if (PawnsRank[c][col - 1] == 0 && PawnsRank[c][col + 1] == 0) PawnsTemp[c] -= 20; //isolated pawn penalty
				else if (PawnsRank[c][col - 1] < pr && PawnsRank[c][col + 1] < pr) {
					PawnsTemp[c] -= 8; //backward pawn penalty
					pawn_weight[c][r] = 3;
				}
				if (9 - PawnsRank[oc][col - 1] >= pr && 9 - PawnsRank[oc][col] >= pr && 9 - PawnsRank[oc][col + 1] >= pr) {
					//pr is a passed pawn
					//if king can't reach pawn, then count promotion early
					pawn_weight[c][r] = 6;
					if (KP_END[oc] && __min(5, pr - 1) < ChebyshevDistance(pp + 10 * (pr - 1)*(c == LIGHT ? -1 : 1), Players.positions[KINGP + other_base]) - (PlySide() == oc ? 1 : 0))
						PromotionTempo[(__min(4, pr - 2) << 1) + (PlySide() == oc ? 1 : 0)] = (Colors)c;//PawnsTemp[c] += QUEEN_VALUE-(82+30+90);
					PawnsTemp[c] += //pawn_tables[c][pp] + 9;//
						(7 - pr) * 10;
					if (LowestPassed[c] < pr) LowestPassed[c] = pr;//calculate nearest passed pawn for bonus for rook on other side of passed pawn
				}
			}
		}

		//		*/
		const Pos king_col = SquareToColIndex[Players.pieces[KINGP + base]];
		PawnsTemp[c] += eval_king(king_col, (Colors)c, (Colors)oc);
		for (int r = ROOK1;r <= ROOK2;++r) {
			if (is_piece(Players.pieces[r + base])) {
				const Pos rook_pos = Players.positions[r + base];
				const Pos rook_col = SquareToColIndex[rook_pos];
				if (PawnsRank[c][rook_col] == 0)
					if (PawnsRank[oc][rook_col] == 0) PawnsTemp[c] += 15;//open file
					else PawnsTemp[c] += 10; //semi open
					if (RankCalc[c][rook_pos]<LowestPassed[c]) PawnsTemp[c] += 35;
					else if (RankCalc[c][rook_pos] == 1)PawnsTemp[c] += 20;//rook attacking last row
			}
		}

	}

	for (int i = 0;i < 10;++i) {
		if (PromotionTempo[i] != NUM_COLORS) {
			PawnsTemp[PromotionTempo[i]] += QUEEN_VALUE - (82 + 30 + 90);
			break;
		}
	}

	for (int kc = LIGHT;kc < NUM_COLORS;++kc) {
		if (MaterialSums[kc][MAJOR_MINOR_COUNT] <= BISHOP_VALUE+KNIGHT_VALUE && MaterialSums[other_color((Colors)kc)][MAJOR_MINOR_COUNT] <= BISHOP_VALUE) {
			int king_base = base_by_color((Colors)kc);
			const Pos kpos = Players.positions[KINGP + king_base];
			int kp_tropism = 0;
			int pawn_count = 0;
			for (int pc = LIGHT;pc < NUM_COLORS;++pc) {
				int pawn_base = base_by_color((Colors)pc);
				for (int index = PAWN1; index <= PAWN8;++index) {
					if (pawn_weight[pc][index] != 0) {
						++pawn_count;
						kp_tropism += pawn_weight[pc][index] * ChebyshevDistance(kpos, Players.positions[index + pawn_base]);
					}
				}
			}
			PawnsTemp[kc] -= kp_tropism;
		}
	}
	///*
	//mop up should handle knights differently
	if (MaterialSums[LIGHT][PAWN_COUNT] == 0 && MaterialSums[DARK][PAWN_COUNT] == 0 &&
		Players.pieces[DARK_KNIGHT1]==EMPTY && Players.pieces[DARK_KNIGHT2] == EMPTY &&
		Players.pieces[LIGHT_KNIGHT1] == EMPTY && Players.pieces[LIGHT_KNIGHT2] == EMPTY) {
		if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] != MaterialSums[DARK][MAJOR_MINOR_COUNT]) {
			if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] > MaterialSums[DARK][MAJOR_MINOR_COUNT])
				if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT]<2 * ROOK_VALUE)
					PawnsTemp[LIGHT] += 3*47 * CenterManhattanDistance[Players.positions[DARK_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP]));
			else
				if (MaterialSums[DARK][MAJOR_MINOR_COUNT]<2 * ROOK_VALUE)
					PawnsTemp[DARK] += 3* 47 * CenterManhattanDistance[Players.positions[LIGHT_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP]));
		}
	}
	//*/

	if (PlySide() == LIGHT) PawnsValue = PawnsTemp[LIGHT] - PawnsTemp[DARK];
	else PawnsValue = PawnsTemp[DARK] - PawnsTemp[LIGHT];
}

inline int positive_square_value_of_piece(Colors c, PieceType p, Pos s)
{
	if (!is_piece(p)) return 0;
	//{}{}{} make more efficient later
	return (!SideInEndgame(c) ? (c == LIGHT ? SquareTableL : SquareTableD)[p][s] : (c == LIGHT ? EndgameSquareTableL : EndgameSquareTableD)[p][s]);
}


inline int square_value_of_piece(Colors side, Colors c, PieceType p, Pos s)
{
	if (!is_piece(p)) return 0;
	//{}{}{} make more efficient later
	const int v = positive_square_value_of_piece(c, p, s);
	if (c == side) return v;
	return -v;
}

inline int simple_eval()
{
	const Colors o = other_color(_PlySide);
	const int material_count = MaterialSums[_PlySide][DONT_COUNT] + MaterialSums[_PlySide][PAWN_COUNT] + MaterialSums[_PlySide][MAJOR_MINOR_COUNT] - MaterialSums[o][PAWN_COUNT] - MaterialSums[o][MAJOR_MINOR_COUNT] - MaterialSums[o][DONT_COUNT];
	return  material_count +
		PersistantValue + EphemeralValue;
}
inline int eval()
{
	if (PawnsDirty) calc_pawns();
	const Colors o = other_color(_PlySide);
	const int material_count = MaterialSums[_PlySide][DONT_COUNT] + MaterialSums[_PlySide][PAWN_COUNT] + MaterialSums[_PlySide][MAJOR_MINOR_COUNT] - MaterialSums[o][PAWN_COUNT] - MaterialSums[o][MAJOR_MINOR_COUNT]- MaterialSums[o][DONT_COUNT];
	int silly = (Hash.high_mask() & 7);
	if (_PlySide == DARK) silly = -silly;
	return  material_count +
		PersistantValue + EphemeralValue + PawnsValue+silly;
}


inline int eval(Colors c)
{
	if (PlySide() == c) return eval();
	return -eval();
}
/*enum PieceType : signed char {
	EMPTY = 0,
	KING_NOT_MOVED = 1,
	KING = 2,
	KING_CASTLED = 3,
	PAWN = 4,
	PAWN_JUST_ADVANCED = 5,
	KNIGHT = 6,
	BISHOP = 7,
	ROOK_NOT_MOVED = 8,
	ROOK = 9,
	QUEEN = 10,
	NUM_PIECE_TYPES = 11,
};
*/
const bool IsSufficient[NUM_PIECE_TYPES] = 
{
	false,//empty
	false,false,//king
	true,true,//pawn
	false,false,//knight, bishop
	true,true,//rook
	true //queen
};
const bool IsMinor[NUM_PIECE_TYPES] =
{
	false,//empty
	false,false,//king
	false,false,//pawn
	true,true,//knight, bishop
	false,false,//rook
	false //queen
};

int SufficientPieces;
int MinorPieces[NUM_COLORS];


inline void add_value(Colors side, PieceSlotType s)
{
	const Pos p = Players.positions[s];
	const PieceType t = Players.pieces[s];
	const Colors slot_side = color(s);
	
	SufficientPieces += IsSufficient[t]?1:0;
	MinorPieces[slot_side] += IsMinor[t];
	MaterialSums[slot_side][PieceCountIndex[t]] += ValuePerPiece[t];

	PersistantValue += square_value_of_piece(side, slot_side, t, p);
	update_hash(s);
}
inline void sub_value(Colors side, PieceSlotType s)
{
	const Pos p = Players.positions[s];
	const PieceType t = Players.pieces[s];
	const Colors slot_side = color(s);

	SufficientPieces -= IsSufficient[t]?1:0;
	MinorPieces[slot_side] -= IsMinor[t];
	MaterialSums[slot_side][PieceCountIndex[t]] -= ValuePerPiece[t];

	PersistantValue -= square_value_of_piece(side, slot_side, t, p);
	update_hash(s);
}

Move::Move(Pos f, Pos t PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became((PieceType)ChangePieceOnMove[initial]),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
castling(NotCastling),
//see(0),
bonus(0)
INITLINE
{
	//	assert(t!=h1);//find bug
	massert(color(Board[f]) != OFF_BOARD);
	massert(color(Board[f]) != NO_SLOT);
	massert(slot_taken == NO_SLOT || color(slot_taken) != color(Board[f]));
	massert(slot_taken == NO_SLOT || Players.pieces[slot_taken] != EMPTY);
	movement_bonuses();
}

//assume that c is CastleLeft or CastleRight
Move::Move(Pos f, Pos t, Castling c PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became(ChangePieceOnMove[initial]),
slot_taken(NO_SLOT),
piece_taken(EMPTY),
castling(c),
//see(0),
bonus(0)
INITLINE
{
	if (initial == KING_NOT_MOVED) became = KING_CASTLED;
	movement_bonuses();
}

Move::Move(Pos f, Pos t, PieceType type PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became(type),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
castling(NotCastling),
//see(0),
bonus(0)
INITLINE
{
	massert(color(Board[f]) != OFF_BOARD);
	massert(color(Board[f]) != NO_SLOT);
	massert(slot_taken == NO_SLOT || color(slot_taken) != color(Board[f]) || from == to);
	movement_bonuses();
}

Move::Move(Pos f, Pos t, Pos enpassant_pos, CheckForEnpassantEnum PARAMLINE) :from(f),
to(t),
taken_at(enpassant_pos),
initial(Players.pieces[Board[f]]),
became(initial),
slot_taken(Board[enpassant_pos]),
piece_taken(Players.pieces[Board[enpassant_pos]]),
castling(NotCastling),
//see(0),
bonus(0)
INITLINE
{
	movement_bonuses();
}

//from other player
Move::Move(Pos f, Pos t, CheckForEnpassantEnum PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became(ChangePieceOnMove[initial]),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
castling(NotCastling),
//see(0),
bonus(0)
INITLINE
{
	if (initial == PAWN && color(Board[f])==LIGHT && piece_taken == EMPTY && to != from + UP && to != from + UP + UP) {
		assert(Players.pieces[Board[to + DOWN]] == PAWN_JUST_ADVANCED);
		taken_at = to + DOWN;
		slot_taken = Board[taken_at];
		piece_taken = Players.pieces[slot_taken];
	}
	else if (initial == PAWN && color(Board[f]) == DARK && piece_taken == EMPTY && to != from + DOWN && to != from + DOWN + DOWN) {
		assert(Players.pieces[Board[to + UP]] == PAWN_JUST_ADVANCED);
		taken_at = to + UP;
		slot_taken = Board[taken_at];
		piece_taken = Players.pieces[slot_taken];
	}
	else if (initial == PAWN && abs(to-from)>11) {
		became = PAWN_JUST_ADVANCED;
	}
	else if (initial == KING_NOT_MOVED && color(Board[f]) == LIGHT)
	{
		if (to == c1) castling = CastleLeft;
		else if (to == g1) castling = CastleRight;
		became = KING_CASTLED;
	}
	else if (initial == KING_NOT_MOVED && color(Board[f]) == DARK)
	{
		if (to == c8) castling = CastleLeft;
		else if (to == g8) castling = CastleRight;
		became = KING_CASTLED;
	}
	movement_bonuses();
}

Move::Move(const Move &m) :
	from(m.from),
	to(m.to),
	taken_at(m.taken_at),
	initial(m.initial),
	became(m.became),
	slot_taken(m.slot_taken),
	piece_taken(m.piece_taken),
	castling(m.castling),
	//see(m.see),
	bonus(m.bonus)
	//,hash(m.hash)
	COPYLINE
{}
void Move::operator = (const Move &m)
{
	from = m.from;
	to = m.to;
	taken_at = m.taken_at;
	initial = m.initial;
	became = m.became;
	slot_taken = m.slot_taken;
	piece_taken = m.piece_taken;
	castling = m.castling;
	//see = m.see;
	bonus = m.bonus;
	//hash = m.hash;
	SETLINE
}
Move::Move(Move &&m) :from(std::move(m.from)),
to(std::move(m.to)),
taken_at(std::move(m.taken_at)),
initial(std::move(m.initial)),
became(std::move(m.became)),
slot_taken(std::move(m.slot_taken)),
piece_taken(std::move(m.piece_taken)),
castling(std::move(m.castling)),
//see(std::move(m.see)),
bonus(std::move(m.bonus))
//,hash(std::move(m.hash))
COPYLINE
{}

void Move::make()
{
//	hash = Hash;
	massert(!empty());
	massert(slot_taken==NO_SLOT || Players.pieces[slot_taken]!=EMPTY);
	board_consistent();
	if (empty()) return;

	//	if (taken_at != to) {
	//		printf("move %s to %s taking at %s\n", PosToStandard[from], PosToStandard[to], PosToStandard[taken_at]);
	//	}
///*
	if (MoveNumber + history_len > 1
		&& Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] == PAWN_JUST_ADVANCED) {
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] = PAWN;
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		//		cout << "- "<< MoveNumber + history_len - 2<<" " <<PosToStandard[En_passant_history[MoveNumber + history_len - 2]];
		board_consistent();
	}
//*/
	if (became == PAWN_JUST_ADVANCED) {
		En_passant_history[MoveNumber + history_len] = to;
//		cout << "* "<< MoveNumber + history_len << " " <<PosToStandard[to];
	}
	else En_passant_history[MoveNumber + history_len] = 0;

	const PieceSlotType slot_moving = Board[from];
	add_bonus(color(slot_moving), bonus);
	Colors side = PlySide();//color(slot_moving);
//	if (not_move()) {
//		sub_value(side,slot_moving);
//		Players.pieces[Board[from]]= became; //Players.pieces[Board()[from]] = became;
//		add_value(side,slot_moving);
//		piece_threats(color(became));
//		RepeatList.add();
//		return;
//	}
	sub_value(side,slot_moving);
	sub_value(side,slot_taken);
	switch (castling) {
	case CastleLeft:
		if (color(slot_moving) == LIGHT) {
			sub_value(side,LIGHT_ROOK1);
			Players.pieces[LIGHT_ROOK1] = ROOK;
			set_position(d1, LIGHT_ROOK1);
			Board[a1]=NO_SLOT;
			add_value(side,LIGHT_ROOK1);
			board_consistent();
		}
		else {
			sub_value(side,DARK_ROOK1);
			Players.pieces[DARK_ROOK1] = ROOK;
			set_position(d8, DARK_ROOK1);
			Board[a8] = NO_SLOT;
			add_value(side,DARK_ROOK1);
			board_consistent();
		}
		break;
	case CastleRight:
		if (color(slot_moving) == LIGHT) {
			sub_value(side,LIGHT_ROOK2);
			Players.pieces[LIGHT_ROOK2] = ROOK;
			set_position(f1, LIGHT_ROOK2);
			Board[h1] = NO_SLOT;
			add_value(side,LIGHT_ROOK2);
			board_consistent();
		}
		else {
			sub_value(side,DARK_ROOK2);
			Players.pieces[DARK_ROOK2] = ROOK;
			set_position(f8, DARK_ROOK2);
			Board[h8] = NO_SLOT;
			add_value(side,DARK_ROOK2);
			board_consistent();
		}
		break;
	}
	Players.pieces[slot_moving] = became;
	set_position(to, slot_moving);
	if (taken_at != to) {
		//Players.en_passant[slot_taken] = MoveNumber+history_len+1;
		Board[taken_at] = NO_SLOT;
	}
	Players.pieces[slot_taken] = EMPTY;
	Players.positions[slot_taken] = 0;
										   //Board()[to] = slot_moving;
	Board[from] = NO_SLOT;
	add_value(side,slot_moving);
//	piece_threats();
//	board_consistent();
	//if (is_pawn(initial) || is_king(initial) || is_pawn(piece_taken)) 
		PawnsDirty = true;

	RepeatList.add(color(slot_moving));
	board_consistent();
}

void Move::unmake()
{
	board_consistent();
	if (empty()) return;
	RepeatList.remove();

	const PieceSlotType slot_moving = Board[to];
	Colors side = PlySide();//color(slot_moving);
	add_bonus(color(slot_moving), -bonus);

						  //	if (not_move()) {
//		sub_value(side,slot_moving);
//		Players.pieces[slot_moving] = initial;
//		add_value(side, slot_moving);
//		RepeatList.remove();
//		return;
//	}
	sub_value(side, slot_moving);
	Board[to] = NO_SLOT;
	Players.pieces[slot_taken] = piece_taken;
	set_position(taken_at, slot_taken);
	set_position(from, slot_moving);
	Players.pieces[slot_moving] = initial;
											  //Players.positions[slot_moving] = from;
	add_value(side, slot_moving);
	add_value(side, slot_taken);
	switch (castling) {
	case CastleLeft:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK1);
			Players.pieces[LIGHT_ROOK1] = ROOK_NOT_MOVED;
			Players.positions[LIGHT_ROOK1] = a1;
			Board[a1] = LIGHT_ROOK1;
			Board[d1] = NO_SLOT;
			add_value(side, LIGHT_ROOK1);
		}
		else {
			sub_value(side, DARK_ROOK1);
			Players.pieces[DARK_ROOK1] = ROOK_NOT_MOVED;
			Players.positions[DARK_ROOK1] = a8;
			Board[a8] = DARK_ROOK1;
			Board[d8] = NO_SLOT;
			add_value(side, DARK_ROOK1);
		}
		break;
	case CastleRight:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK2);
			Players.pieces[LIGHT_ROOK2] = ROOK_NOT_MOVED;
			Players.positions[LIGHT_ROOK2] = h1;
			Board[h1] = LIGHT_ROOK2;
			Board[f1] = NO_SLOT;
			add_value(side, LIGHT_ROOK2);
		}
		else {
			sub_value(side, DARK_ROOK2);
			Players.pieces[DARK_ROOK2] = ROOK_NOT_MOVED;
			Players.positions[DARK_ROOK2] = h8;
			Board[h8] = DARK_ROOK2;
			Board[f8] = NO_SLOT;
			add_value(side, DARK_ROOK2);
		}
		break;
	}
///*
	if (MoveNumber + history_len > 1
		&& Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] == PAWN) {
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] = PAWN_JUST_ADVANCED;
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		//		cout << "+ " << MoveNumber + history_len - 2 << " " << PosToStandard[En_passant_history[MoveNumber + history_len - 2]];
	}
//*/
	//	assert(hash == Hash);
	//if (is_pawn(initial) || is_king(initial) || is_pawn(piece_taken)) 
		PawnsDirty = true;
	board_consistent();
}


bool king_moved(Colors c)
{
	const PieceSlotType king = (PieceSlotType)(base_by_color(c) + KINGP);
	return Players.pieces[king] != KING_NOT_MOVED;
}

bool left_rook_moved(Colors c)
{
	const PieceSlotType rook = (PieceSlotType)(base_by_color(c) + ROOK1);
	return Players.pieces[rook] != ROOK_NOT_MOVED;
}

bool right_rook_moved(Colors c)
{
	const PieceSlotType rook = (PieceSlotType)(base_by_color(c) + ROOK2);
	return Players.pieces[rook] != ROOK_NOT_MOVED;
}

bool can_castle_left(Colors c)
{
	const Pos * r = HomeRow[c];
	return 	!king_moved(c) && !left_rook_moved(c) && NO_SLOT == Board[r[2 - 1]] && NO_SLOT == Board[r[3 - 1]] && NO_SLOT == Board[r[4 - 1]]
		&& 0 == Threatened(c,r[2 - 1]) && 0 == Threatened(c, r[3 - 1]) && 0 == Threatened(c, r[4 - 1]) && 0 == Threatened(c, r[5 - 1]);
}

bool can_castle_right(Colors c)
{
	const Pos * r = HomeRow[c];
	return !king_moved(c) && !right_rook_moved(c) && NO_SLOT == Board[r[6 - 1]] && NO_SLOT == Board[r[7 - 1]]
		&& 0 == Threatened(c, r[7 - 1]) && 0 == Threatened(c, r[6 - 1]) && 0 == Threatened(c, r[5 - 1]);
}

void clear_board()
{
	for (int i = 0;i < 20;++i) Board[i] = Board[100 + i] = OFF_BOARD;
	for (int i = 20;i < 100;i += 10) Board[i] = Board[9 + i] = OFF_BOARD;
	for (int j = 20;j < 100;j += 10) for (int i = 1;i < 9;++i) Board[j + i] = NO_SLOT;
}

int EndGamePoint = -1;

//median of the value of the last 4 moves - used to detect drops in value and use extra time
int fg[4] = { 0,0,0,0 };
int fg_index = 0;
int first_guess()
{
	int big = -INF;
	int little = INF;
	for (int i = 0;i < 4;++i) {
		if (big < fg[i]) big = fg[i];
		if (little > fg[i]) little = fg[i];
	}

	return (fg[0] + fg[1] + fg[2] + fg[3] - big - little) >> 1;
}
void add_first_guess(int i)
{
	fg[fg_index] = i;
	fg_index = (fg_index + 1) & 3;
}
void set_first_guess(int i)
{
	for (int i = 0;i < 4;++i) fg[i] = i;
}

int firstguess = 0;

int Ply0Alpha = 0;


void init_board()
{
	MinorPieces[LIGHT] = MinorPieces[DARK] = 2;
	SufficientPieces = 8 * 2 + 2 + 4;
	for (int c=0;c<NUM_COLORS;++c) for (int i=0;i<NUM_MATERIAL_INDEXES;++i) MaterialSums[c][i]=0;
	PawnsValue = 0;
	PawnsDirty = true;
	for (int i = 0;i < MAX_MOVES + MAX_PLY;++i)En_passant_history[i] = 0;
	firstguess = 0;
	Ply0Alpha = 0;
	Promotions.clear();
	KingThreats.clear();
	Captures.clear();
	VanillaMoves.clear();
	MovesOrdered.clear();
	MovesIID.clear();

	set_first_guess(0);
	ClearHash += MAX_MOVES;
	RepeatList.clear();
	FakeLen = 0;
	EndGamePoint = -1;
	clear_board();
	for (int i = 0;i<NUM_PIECE_SLOTS;++i) {
		Players.pieces[i] = Initial_Pieces[i];
		const Pos pos = Players.positions[i] = Initial_Pos[i];
		Board[pos] = (PieceSlotType)i;
	}
	Players.pieces[NO_SLOT] = Players.pieces[OFF_BOARD] = EMPTY;
	Players.positions[NO_SLOT] = Players.positions[OFF_BOARD] = 0;
	_PlySide = LIGHT;
	CheckForEndgame = true;
	CurrentPly = 0;
	MovesOrdered.clear();
	DisableBook = false;
	PersistantValue = 0;
	EphemeralValue = 0;
	history_len = 0;
	Hash.clear();
	for (Pos i = a8;i <= h1;++i) if (is_piece(i)) add_value(LIGHT, Board[i]);
}

#include <sys/timeb.h>
int ftime_ok;
int millis() //needs different implementation for arduino
{
	struct timeb timebuffer;
	ftime(&timebuffer);
	if (timebuffer.millitm != 0)
		ftime_ok = 1;
	return (timebuffer.time * 1000) + timebuffer.millitm;
}

int StopTime;
int Nodes = 0;
int MidNodes = 0;

int get_ms()
{
	return millis();
}

bool TimedOut = false;
enum  OutOfTimeException { OutOfTime };

bool test_extend_time(int);

//used to be !pv[0][0].empty()

Move pv[MAX_PLY];
int pv_length = 0;
Move Ply0Move;
bool has_a_first_move()
{
	return !pv[0].empty();
}

void checkup()
{
	/* is the engine's time up? if so, longjmp back to the
	beginning of think() */
#ifndef DISABLE_TIME
	if (has_a_first_move() && get_ms() >= StopTime) {
		if (test_extend_time(Ply0Alpha)) {
			LOG(Log << "t+\n");
			return;
		}
		TimedOut = true;
		LOG(Log << "Out of time at Ply " << CurrentPly << endl);

		throw OutOfTime;
	}
#endif
}

bool parse_move(Move &m, char *s)
{

	/* make sure the string looks like a move */
	if (s[0] < 'a' || s[0] > 'h' ||
		s[1] < '0' || s[1] > '9' ||
		s[2] < 'a' || s[2] > 'h' ||
		s[3] < '0' || s[3] > '9')
		return false;
	Move move((Pos)(s[0] - 'a' + 1 + 10 * (10 - (s[1] - '0'))),
		(Pos)(s[2] - 'a' + 1 + 10 * (10 - (s[3] - '0'))), Move::CheckForEnpassant ATLINE);
	switch (s[4]) {
	case 'N':
	case 'n':
		move.became = KNIGHT;
		break;
	case 'B':
	case 'b':
		move.became = BISHOP;
		break;
	case 'R':
	case 'r':
		move.became = ROOK;
		break;
	case 'Q':
	case 'q':
		move.became = QUEEN;
		break;
	default:
		if (move.became == PAWN) {
			if (move.to <= h8) move.became = QUEEN;
		}
		else if (move.became == PAWN) {
			if (move.to >= a1) move.became = QUEEN;
		}
	}
	m = move;
	return true;
}

const char *move_str(const Move &m)
{
	static char str[6];

	if (m.empty()) return "";

	char c;

	if (m.became != (PieceType)ChangePieceOnMove[m.initial] && m.became != PAWN_JUST_ADVANCED && m.became != KING_CASTLED) {
		if (color(Board[m.from]) == LIGHT) {
			switch (m.became) {
			case KNIGHT:
				c = 'N';
				break;
			case BISHOP:
				c = 'B';
				break;
			case ROOK:
				c = 'R';
				break;
			case QUEEN:
				c = 'Q';
				break;
			default:
				c = '?';//we shouldn't get here
			}
		}
		else {
			switch (m.became) {
			case KNIGHT:
				c = 'n';
				break;
			case BISHOP:
				c = 'b';
				break;
			case ROOK:
				c = 'r';
				break;
			case QUEEN:
				c = 'q';
				break;
			default:
				c = '?';//we shouldn't get here
			}
		}
		massert(m.from <= h1 && m.from >= a8);
		massert(Board[m.from] != OFF_BOARD);
		massert(m.to <= h1 && m.to >= a8);
		massert(Board[m.to] != OFF_BOARD);

		sprintf(str, "%s%s%c",
			PosToStandard[m.from],
			PosToStandard[m.to],
			c);
	}
	else
		sprintf(str, "%s%s",
			PosToStandard[m.from],
			PosToStandard[m.to]);
	return str;
}
#ifdef LOGGING
void log_board()
{
	int i;

	Log << "\n/*";
	for (int row = 0;row < 80;row += 10) {
		Log << "\n" << 8 - row / 10 << " ";
		for (int col = a8; col <= h8; ++col) {
			if (Board[row + col] == NO_SLOT) Log << " .";
			else Log << ' ' << piece_char(color(Board[row + col]),Players.pieces[Board[row + col]]);
		}
	}
	Log << "\n   a b c d e f g h\n*/\n";

	Log << "int board_init[BOARD_SIZE]\n{\n";
	for (int i = 0;i < BOARD_SIZE;++i) Log << (int)Board[i] << ",";
	Log << "\n};\n";
	Log << "int players_init[NUM_PIECE_SLOTS]\n{\n";
	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Log << (int)Players.pieces[i] << ",";
	Log << "\n};\n";

	Log.flush();
}
#else
void log_board()
{

}
#endif

void print_board()
{
	int i;

	printf("\n ");
	for (int row = 0;row < 80;row += 10) {
		printf("\n%d ", 8 - row / 10);
		for (int col = a8; col <= h8; ++col) {
			if (Board[row + col] == NO_SLOT) printf(" .");
			else printf(" %c", piece_char(color(Board[row+col]),Players.pieces[Board[row + col]]));
		}
	}
	printf("\n\n   a b c d e f g h\n\n");
}

//add c as color of sliding piece
//add value as value of sliding piece


#define CPOINT(direction,inc) \
	if (Board[root_pos+direction] != NO_SLOT) count+=inc;

#define CSLIDE(direction,inc) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] != NO_SLOT) break; \
	count+=inc;\
	continue; \
} while (true)


#define TSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (expanding != target) { \
		if (Board[expanding] != NO_SLOT) break; \
		continue; \
	}\
	if (Board[expanding] == NO_SLOT) { \
		return Move(root_pos,expanding ATLINE);\
	}\
	if (color(Board[expanding]) != c) \
		return Move(root_pos,expanding ATLINE);\
	break; \
} while (true)


#define HASH_LEN_LN2 24

const int HASH_LEN = 1 << HASH_LEN_LN2;
const int HASH_MASK = HASH_LEN - 1;

struct HashMove
{
	Pos from;
	Pos to;
	PieceType became;
	HashMove() { clear(); }
	HashMove(const Move & m) :from(m.from), to(m.to), became(m.became) {}
	HashMove(const RelativeMove &m) :from(m.from_pos), to(m.to), became(m.promotion) {}
	void operator = (const RelativeMove &m) {
		from = m.from_pos;
		to = m.to; 
		became = m.promotion;
	}
	void operator = (const Move &m) {
		from = m.from;
		to = m.to;
		became = m.became;
	}
	void clear()
	{
		from = 0;
	}
	bool empty()
	{
		return from == 0;
	}
};

class HashTableEntry
{


public:
	int get_lower(int depth)
	{
		if (lower_bound_depth >= depth)
			return lower_bound;
		return -INF;
	}
	int get_upper(int depth)
	{
		if (upper_bound_depth >= depth)
			return upper_bound;
		return INF;
	}
	void set_lower(int depth, int lower)
	{
		if (lower_bound_depth <= depth) {
			lower_bound = lower;
			lower_bound_depth = depth;
		}
	}
	void set_upper(int depth, int upper)
	{
		if (upper_bound_depth <= depth) {
			upper_bound = upper;
			upper_bound_depth = depth;
		}
	}
	void set_move(Move &m)
	{
		move = m;
	}

	void set_move(RelativeMove &m)
	{
		move = m;
	}
	HashMove & get_move()
	{
		return move;
	}
	void clear()
	{
		upper_bound_depth = lower_bound_depth = -127;
		move.clear();
		eval_copy = INF;
		upper_exact = lower_exact = false;
	}

	int get_eval()
	{
		if (upper_exact) {
			if (lower_exact) {
				if (upper_bound_depth > lower_bound_depth) return upper_bound;
				return lower_bound;
			}
		}
		if (lower_exact) return lower_bound;
		if (upper_bound_depth != -127 &&  abs(upper_bound - lower_bound)<PAWN_VALUE) return (upper_bound +lower_bound)>>1;
//		if (upper_bound_depth == lower_bound_depth) return upper_bound;
		if (eval_copy != INF) return eval_copy;
		if (upper_bound_depth != -127 && lower_bound_depth != -127) return (upper_bound + lower_bound) >> 1;
//		if (eval_copy == INF) 
			eval_copy = eval();
		return eval_copy;
	}
	HashTableEntry() : move_created(0) { }
	HashType key;

	bool upper_exact;
	bool lower_exact;
	int upper_bound;
	int lower_bound;
	int eval_copy;
	char upper_bound_depth;
	char lower_bound_depth;

	int move_created;
	HashMove move;
};


HashTableEntry *HashTable;//[HASH_LEN];
void init_hash()
{
	HashTable = new HashTableEntry[HASH_LEN<<1];
	if (HashTable == nullptr) cout << "\nAllocation failed\n";
}

HashTableEntry * GetHash(bool q)
{
	const int hoff = q ? HASH_LEN : 0;
	HashTableEntry * entry = &HashTable[hoff+((int)(Hash.low) & HASH_MASK)], *entry2;
	if (//entry->move_created == history_len + ClearHash && 
		entry->key == Hash) return entry;

	entry2 = &HashTable[hoff + ((int)Hash.high_mask() & HASH_MASK)];
	if (//entry->move_created == history_len + ClearHash && 
		entry2->key == Hash) return entry2;

	return nullptr;
}

int get_order_eval(bool &is_score, Colors c, int depth)
{
	HashTableEntry *e = nullptr;
	if (depth>=0) e=GetHash(false);
	if (e != nullptr) {
		if (e->lower_bound_depth != -127 && e->upper_bound_depth != -127) {
			is_score = true;
			return -(e->lower_bound + e->upper_bound) >> 1;
		}
	}
	HashTableEntry *eq = nullptr;
	if (depth<=1) eq = GetHash(true);
	if (eq != nullptr) {
		if (eq->lower_bound_depth != -127 && eq->upper_bound_depth != -127) {
			is_score = true;
			return -(eq->lower_bound + eq->upper_bound) >> 1;
		}
	}
	is_score = false;
	return 0;
}

HashTableEntry * GetOrMakeHash(bool q)
{
	const int hoff = q ? HASH_LEN : 0;
	HashTableEntry * entry = &HashTable[hoff + ((int)(Hash.low) & HASH_MASK)], *entry2;
	if (//entry->move_created == history_len + ClearHash && 
		entry->key == Hash) return entry;

	entry2 = &HashTable[hoff + ((int)Hash.high_mask() & HASH_MASK)];
	if (//entry->move_created == history_len + ClearHash && 
		entry2->key == Hash) return entry2;

	if (entry->move_created > entry2->move_created) entry = entry2;
	entry->key = Hash;
	entry->clear();
	entry->move_created = history_len + ClearHash;

	return entry;
}

bool inc_ply();
bool dec_ply();

int QUIESCENT_DEPTH;

bool order_value(int &result, Colors c,Move &m, int depth)
{
//	result = 0;
//	return false;
	m.make();
	//int get_order_eval(bool &is_score, Colors c)
//	set_PlySide(other_color(PlySide()));
	bool found = false;
	if (depth < 4 - QUIESCENT_DEPTH) result = 0;
	else result = get_order_eval(found, c, depth)<<9;
	m.unmake();
	return found;
}

#define LAST_MOVED_BONUS KING_VALUE
#define GENERATE_TO MovesOrdered


//#define CAP_SCALE(x,y) (((x)<<10)-(y))
#define CAP_SCALE(x,y) ((x)<<10)
bool ThreatenedExcluding(Colors o, Pos root_pos, PieceSlotType exclude);
int SEE(Colors c, Pos root_pos, PieceSlotType exclude, int depth);
#define COUNTER(c,expanding,attacker,value) (-SEE(c,expanding,attacker,INF))
//#define COUNTER(c,expanding,attacker,value) ThreatenedExcluding(c,expanding,attacker)?value:0
// square_value - positive_square_value_of_piece(c, piece_type, expanding) ));
#define CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		int v; \
		const bool found = order_value(v,c,m, depth);\
		GENERATE_TO.push(m,found?v:(v+(val<<10)+(MVV_LVA)));\
	} 
/*

#define NONCAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		int v; \
		const bool found = order_value(v,c,m, depth);\
		GENERATE_TO.push(m,found?v:(v+(val<<10)+(MVV_LVA)));\
	} 
*/
/*
#define CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		GENERATE_TO.push(m,(val<<10)+(MVV_LVA));\
	} 
*/
#define NONCAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		GENERATE_TO.push(m,(val<<9)+(MVV_LVA));\
	} 


#define QUIET_VALUE -KING_VALUE

#define SLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, expanding) ));\
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) { \
		CAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(ValuePerPiece[Players.pieces[Board[expanding]]]-COUNTER(c,expanding,attacker,value),value));\
	} \
	break; \
} while (true)

#define TPOINT(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction ATLINE);\
		} else if (color(Board[root_pos+direction]) != c) \
			return Move(root_pos,root_pos+direction ATLINE); \
		return Move();\
	}


//
//square_value - positive_square_value_of_piece(c, piece_type, root_pos+direction)
#define POINT(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, root_pos+direction)))); \
	} else if (Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]]-COUNTER(c,root_pos+direction,attacker,value),value))); \
	}

#define TPPOINT(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction ATLINE);\
		} \
		return Move();\
	}

#define PPOINT(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),CAP_SCALE(QUIET_VALUE,square_value -positive_square_value_of_piece(c, piece_type, root_pos) + direction));\
	}


#define PPOINT_DOUBLE(direction) \
	if (Board[root_pos+direction] == NO_SLOT && Board[root_pos+(direction>>1)] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction, PAWN_JUST_ADVANCED ATLINE),CAP_SCALE(QUIET_VALUE,square_value -positive_square_value_of_piece(c, piece_type, root_pos) + direction)); \
	}

#define TPPOINT_DOUBLE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT && Board[root_pos+(direction>>1)] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction, PAWN_JUST_ADVANCED ATLINE);\
		} \
		return Move();\
	}


#define PPOINT_PROMOTE(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
	CAPTURE_VALUATION((root_pos,root_pos+direction, QUEEN ATLINE),CAP_SCALE(QUEEN_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, KNIGHT ATLINE),CAP_SCALE(KNIGHT_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, ROOK ATLINE),CAP_SCALE(ROOK_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, BISHOP ATLINE),CAP_SCALE(BISHOP_VALUE,0)) \
	}

#define TQPOINT_PROMOTE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
			return Move(root_pos,root_pos+direction, promotion ATLINE); \
		}\
	}

#define QPOINT_PROMOTE(direction) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
		CAPTURE_VALUATION((root_pos,root_pos+direction, QUEEN ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+QUEEN_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, KNIGHT ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+KNIGHT_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, ROOK ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+ROOK_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, BISHOP ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+BISHOP_VALUE),PAWN_VALUE))) \
	}


#define TPPOINT_PROMOTE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction, promotion ATLINE);\
		} \
		return Move();\
	}

int Enpassants = 0;

#define PAWNQPOINT(direction,d2) \
	enpassant_pos = root_pos+d2;\
	if (\
		PAWN_JUST_ADVANCED == Players.pieces[Board[enpassant_pos]] \
		&& color(Board[enpassant_pos]) != c \
		&& Board[root_pos + direction] == NO_SLOT ) {\
			CAPTURE_VALUATION((root_pos,root_pos+direction , enpassant_pos, Move::DoEnpassant ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[enpassant_pos]]],value))) \
			++Enpassants; \
		}\
	else if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]],value))) 

//#define PAWNQPOINT(direction,d2) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]])-value)) 

#define TPAWNQPOINT(direction) \
	if (target == root_pos+direction){ \
		enpassant_pos = enpassant_table[root_pos+direction];\
		if (enpassant_pos != 0 \
			&& PAWN_JUST_ADVANCED == Players.pieces[Board[enpassant_pos]] \
			&& color(Board[enpassant_pos]) != c \
			&& Board[root_pos + direction] == NO_SLOT ) \
				return Move(root_pos, root_pos+direction, enpassant_pos, Move::DoEnpassant ATLINE); \
		if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
			return Move(root_pos,root_pos+direction ATLINE); \
		return Move();\
	}


#define QPOINT(direction) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) {\
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]]-COUNTER(c,root_pos+direction,attacker,value),value)));\
	}


Move test_pawn_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			TPPOINT_PROMOTE(-10);
			TQPOINT_PROMOTE(-9);
			TQPOINT_PROMOTE(-11);
		}
		else {
			if (root_pos >= a2) TPPOINT_DOUBLE(-20);
			TPPOINT(-10);
			TPAWNQPOINT(-9);
			TPAWNQPOINT(-11);
		}
	}
	else {
		if (root_pos >= a2) {
			TPPOINT_PROMOTE(10);
			TQPOINT_PROMOTE(9);
			TQPOINT_PROMOTE(11);
		}
		else {
			if (root_pos <= h7) TPPOINT_DOUBLE(20);
			TPPOINT(10);
			TPAWNQPOINT(9);
			TPAWNQPOINT(11);
		}
	}
	return Move();
}


void generate_pawn_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = PAWN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			PPOINT_PROMOTE(-10);
			QPOINT_PROMOTE(-9);
			QPOINT_PROMOTE(-11);
		}
		else {
			if (root_pos >= a2) PPOINT_DOUBLE(-20);
			PPOINT(-10);
			PAWNQPOINT(-9,1);
			PAWNQPOINT(-11,-1);
		}
	}
	else {
		if (root_pos >= a2) {
			PPOINT_PROMOTE(10);
			QPOINT_PROMOTE(9);
			QPOINT_PROMOTE(11);
		}
		else {
			if (root_pos <= h7) PPOINT_DOUBLE(20);
			PPOINT(10);
			PAWNQPOINT(9,-1);
			PAWNQPOINT(11,1);
		}
	}
}


Move test_knight_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	const Pos direction = KnightDirection[root_pos][target];
	if (direction != 0) {
		TPOINT(direction);
	}
	return Move();
}

void generate_knight_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KNIGHT_VALUE;
	const PieceType piece_type = KNIGHT;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	POINT(-21);
	POINT(-19);
	POINT(-12);
	POINT(-8);
	POINT(8);
	POINT(12);
	POINT(19);
	POINT(21);
}

Move test_king_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	const Pos direction = KingDirection[root_pos][target];
	if (direction != 0) {
		TPOINT(direction);
	}
	return Move();
}


void generate_king_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = KING;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	const int value = KING_VALUE;
	POINT(-11);
	POINT(-10);
	POINT(-9);
	POINT(-1);
	POINT(1);
	POINT(9);
	POINT(10);
	POINT(11);
}

Move test_king_castle_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	if (can_castle_left(c)) {
		if (c == LIGHT) { if (target==c1)  return Move(e1, c1, Move::CastleLeft ATLINE); }
		else { if (target == c8)  return Move(e8, c8, Move::CastleLeft ATLINE); }
	}
	if (can_castle_right(c)) {
		if (c == LIGHT) { if (target == g1) return Move(e1, g1, Move::CastleRight ATLINE); }
		else { if (target == g8) return Move(e8, g8, Move::CastleRight ATLINE); }
	}
	return test_king_moves(c,root_pos,target, promotion);
}

int Castles = 0;

void generate_king_castle_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	if (can_castle_left(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, c1, Move::CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS,0));
		else GENERATE_TO.push(Move(e8, c8, Move::CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS,0));
		++Castles;
	}
	if (can_castle_right(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, g1, Move::CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS,0));
		else GENERATE_TO.push(Move(e8, g8, Move::CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS,0));
		++Castles;
	}
	generate_king_moves(c, root_pos, attacker, val, depth);
}


Move test_queen_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = QueenDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}

int count_null_moves(const Colors c, const Pos root_pos)
{
	return 0;
}

#define QUEEN_COUNT 1
#define KNIGHT_COUNT 5
#define ROOK_HOR_COUNT 2
#define ROOK_VIR_COUNT 7
#define BISHOP_COUNT 3
int count_queen_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-11, QUEEN_COUNT);
	CSLIDE(-10, QUEEN_COUNT);
	CSLIDE(-9, QUEEN_COUNT);
	CSLIDE(-1, QUEEN_COUNT);
	CSLIDE(1, QUEEN_COUNT);
	CSLIDE(9, QUEEN_COUNT);
	CSLIDE(10, QUEEN_COUNT);
	CSLIDE(11, QUEEN_COUNT);
	return count;
}
int count_knight_moves(const Colors c, const Pos root_pos)
{
	int count = 0;
	CPOINT(-21, KNIGHT_COUNT);
	CPOINT(-19, KNIGHT_COUNT);
	CPOINT(-12, KNIGHT_COUNT);
	CPOINT(-8, KNIGHT_COUNT);
	CPOINT(8, KNIGHT_COUNT);
	CPOINT(12, KNIGHT_COUNT);
	CPOINT(19, KNIGHT_COUNT);
	CPOINT(21, KNIGHT_COUNT);
	return count;
}

int count_bishop_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-11, BISHOP_COUNT);
	CSLIDE(-9, BISHOP_COUNT);
	CSLIDE(9, BISHOP_COUNT);
	CSLIDE(11, BISHOP_COUNT);
	return count;
}

int count_rook_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-10, ROOK_VIR_COUNT);
	CSLIDE(-1, ROOK_HOR_COUNT);
	CSLIDE(1, ROOK_HOR_COUNT);
	CSLIDE(10, ROOK_VIR_COUNT);
	return count;
}

typedef int CountMoveFn(const Colors c, const Pos root_pos);
CountMoveFn* CountMoveTable[NUM_PIECE_TYPES] =
{
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_knight_moves,//knight
	count_bishop_moves,
	count_rook_moves,
	count_rook_moves,
	count_queen_moves,
};

int mobility(PieceSlotType s)
{
	return CountMoveTable[Players.pieces[s]](color(s), Players.positions[s]);
}

void generate_queen_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = QUEEN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = QUEEN_VALUE;
	SLIDE(-11);
	SLIDE(-10);
	SLIDE(-9);
	SLIDE(-1);
	SLIDE(1);
	SLIDE(9);
	SLIDE(10);
	SLIDE(11);
}

Move test_rook_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = RookDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}

void generate_rook_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = ROOK;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = ROOK_VALUE;
	SLIDE(-10);
	SLIDE(-1);
	SLIDE(1);
	SLIDE(10);
}

Move test_bishop_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = BishopDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}

void generate_bishop_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = BISHOP;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = BISHOP_VALUE;
	SLIDE(-11);
	SLIDE(-9);
	SLIDE(9);
	SLIDE(11);
}


#define QSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c){ \
		GENERATE_TO.push(Move(root_pos,expanding ATLINE),CAP_SCALE(ValuePerPiece[Players.pieces[Board[expanding]]]-COUNTER(c,expanding,attacker,value),value));\
	}\
	break; \
} while (true)

void quiesent_generate_pawn_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			PPOINT_PROMOTE(-10);
			QPOINT_PROMOTE(-9);
			QPOINT_PROMOTE(-11);
		}
		else {
			PAWNQPOINT(-9,1);
			PAWNQPOINT(-11,-1);
		}
	}
	else {
		if (root_pos >= a2) {
			PPOINT_PROMOTE(10);
			QPOINT_PROMOTE(9);
			QPOINT_PROMOTE(11);
		}
		else {
			PAWNQPOINT(9,-1);
			PAWNQPOINT(11,1);
		}
	}
}


void quiesent_generate_knight_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KNIGHT_VALUE;
	QPOINT(-21);
	QPOINT(-19);
	QPOINT(-12);
	QPOINT(-8);
	QPOINT(8);
	QPOINT(12);
	QPOINT(19);
	QPOINT(21);
}


void quiesent_generate_king_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KING_VALUE;
	QPOINT(-11);
	QPOINT(-10);
	QPOINT(-9);
	QPOINT(-1);
	QPOINT(1);
	QPOINT(9);
	QPOINT(10);
	QPOINT(11);
}


void quiesent_generate_queen_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	const int value = QUEEN_VALUE;
	QSLIDE(-11);
	QSLIDE(-10);
	QSLIDE(-9);
	QSLIDE(-1);
	QSLIDE(1);
	QSLIDE(9);
	QSLIDE(10);
	QSLIDE(11);
}

void quiesent_generate_rook_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	const int value = ROOK_VALUE;
	QSLIDE(-10);
	QSLIDE(-1);
	QSLIDE(1);
	QSLIDE(10);
}

void quiesent_generate_bishop_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	const int value = BISHOP_VALUE;
	QSLIDE(-11);
	QSLIDE(-9);
	QSLIDE(9);
	QSLIDE(11);
}

typedef void GenMoveFn(const Colors, const Pos, PieceSlotType attacker, int val, int depth);
typedef Move TestMoveFn(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion);

/*enum PieceType : signed char {
	EMPTY = 0,
	KING_NOT_MOVED = 1,
	KING = 2,
	KING_CASTLED = 3,
	PAWN = 4,
	PAWN_JUST_ADVANCED = 5,
	KNIGHT = 6,
	BISHOP = 7,
	ROOK_NOT_MOVED = 8,
	ROOK = 9,
	QUEEN = 10,
	NUM_PIECE_TYPES = 11,
};*/

void generate_empty_moves(const Colors, const Pos, PieceSlotType attacker, int val, int depth) {}
Move test_empty_moves(const Colors, const Pos, const Pos, const PieceType) { return Move();  }

TestMoveFn* TestMoveTable[NUM_PIECE_TYPES] =
{
	test_empty_moves,
	test_king_castle_moves,
	test_king_moves,
	test_king_moves,
	test_pawn_moves,
	test_pawn_moves,
	test_knight_moves,
	test_bishop_moves,
	test_rook_moves,
	test_rook_moves,
	test_queen_moves,
};

GenMoveFn* GenMoveTable[NUM_PIECE_TYPES] =
{
	generate_empty_moves,
	generate_king_castle_moves,
	generate_king_moves,
	generate_king_moves,
	generate_pawn_moves,
	generate_pawn_moves,
	generate_knight_moves,
	generate_bishop_moves,
	generate_rook_moves,
	generate_rook_moves,
	generate_queen_moves,
};

GenMoveFn* QGenMoveTable[NUM_PIECE_TYPES] =
{
	generate_empty_moves,
	quiesent_generate_king_moves,
	quiesent_generate_king_moves,
	quiesent_generate_king_moves,
	quiesent_generate_pawn_moves,
	quiesent_generate_pawn_moves,
	quiesent_generate_knight_moves,
	quiesent_generate_bishop_moves,
	quiesent_generate_rook_moves,
	quiesent_generate_rook_moves,
	quiesent_generate_queen_moves,
};

//only used at top level loop
void set_side(Colors s)
{
	if (PlySide() != s) {
		EphemeralValue = -EphemeralValue;
		PersistantValue = -PersistantValue;
		PawnsValue = -PawnsValue;
	}
	set_PlySide(s);
}
bool inc_ply()
{
	if (CurrentPly == MAX_PLY - 1)return false;
	++CurrentPly;
	++MoveNumber;
	MovesOrdered.inc_ply();
	PersistantValue = -PersistantValue;
	EphemeralValue = -EphemeralValue;
	set_PlySide(other_color(PlySide()));

	return true;
}

bool dec_ply()
{
	if (CurrentPly == 0)return false;
	--CurrentPly;
	--MoveNumber;
	MovesOrdered.dec_ply();
	PersistantValue = -PersistantValue;
	EphemeralValue = -EphemeralValue;
	set_PlySide(other_color(PlySide()));

	return true;
}

Move TestMove(Colors c, PieceSlotType p, Pos target, PieceType promotion)
{
	if (color(p) != c) return Move();
	return TestMoveTable[Players.pieces[p]](c, Players.positions[p], target, promotion);
}

void GenMove(PieceSlotType p, int val, int depth)
{
//	if (Players.pieces[p] == EMPTY) return;
	GenMoveTable[Players.pieces[p]](color(p), Players.positions[p],p, val, depth);
}

void QGenMove(PieceSlotType p, int val, int depth)
{
//	if (Players.pieces[p] == EMPTY) return;
	QGenMoveTable[Players.pieces[p]](color(p), Players.positions[p],p, val, depth);
}

void GenMoves(PieceSlotType p, int val, int depth)
{
	GenMove(p,val,depth);
//	MovesOrdered.push_list(VanillaMoves);
//	MovesOrdered.push_list(Captures);
}

int GenPinMoves(Colors c, int &num_pin_move, Pos *prev_pin_moves, int val, int depth)
{
	const int start_index = MovesOrdered.index();
	GenMoves((PieceSlotType)(KINGP + base_by_color(c)),val,depth);
	const int end_index = MovesOrdered.index();
	for (int i = start_index;i < end_index;++i) {
		for (int j = 0;j < num_pin_move;++j) {
			if (!MovesOrdered[i].empty() && MovesOrdered[i].to == prev_pin_moves[j]) MovesOrdered[i].clear();
		}
	}
	int count_pin_moves = 0;
	for (int i = start_index;i < end_index;++i) {
		if (!MovesOrdered[i].empty()) {
			++count_pin_moves;
			prev_pin_moves[num_pin_move++] = MovesOrdered[i].to;
		}
	}
	return count_pin_moves;
}
void QGenMoves(PieceSlotType p, int val, int depth)
{
	QGenMove(p,val, depth);
//	MovesOrdered.push_list(VanillaMoves);
//	MovesOrdered.push_list(Captures);
}
/*
bool LazyGenMove(int &i, bool quiescent, Colors c, Move *killer_moves, int num_killer)
{
	do {
		if (i == NUM_UNCOLORED_PIECE_SLOTS) return false;
		if (quiescent) QGenMove((PieceSlotType)(i + base_by_color(c)));
		else GenMove((PieceSlotType)(i + base_by_color(c)));
//		MovesOrdered.push_list(VanillaMoves);
//		MovesOrdered.push_list(Captures);
		++i;
	} while (MovesOrdered.empty());
	for (int i = 0;i < num_killer;++i) {
		if (sort_pv(killer_moves[i])) MovesOrdered.pop();
	}
	return true;
}
*/
void GenMoves(Colors c, int val, int depth)
{
	PieceSlotType base = base_by_color(c);
	for (int i = PAWN1;i < NUM_UNCOLORED_PIECE_SLOTS;++i) GenMove((PieceSlotType)(i + base), val,depth);
//	MovesOrdered.push_list(VanillaMoves);
//	MovesOrdered.push_list(Captures);
}

void QGenMoves(Colors c, int val, int depth)
{
	PieceSlotType base = base_by_color(c);
	for (int i = PAWN1;i < NUM_UNCOLORED_PIECE_SLOTS;++i) QGenMove((PieceSlotType)(i + base), val,depth);
//	MovesOrdered.push_list(VanillaMoves);
//	MovesOrdered.push_list(Captures);
}


const PieceType ComparisonPiece[] =
{
	EMPTY,
	KING,
	KING,
	KING,
	PAWN,
	PAWN,
	KNIGHT,
	BISHOP,
	ROOK,
	ROOK,
	QUEEN,
};


#define REV_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK:case QUEEN: return true;\
		}\
	break; \
} while (true)

#define EX_REV_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT || Board[expanding]==exclude) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK:case QUEEN: return true;\
		}\
	break; \
} while (true)


#define REV_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP:case QUEEN: return true;\
		}\
	break; \
} while (true)

#define REV_GEN_DSLIDE(direction) \
expanding = root_pos ;\
stop=false;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case QUEEN: \
				delay = true; \
			case BISHOP:\
			{ \
				Move m(expanding,root_pos ATLINE);\
				MovesOrdered.push(m,CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos]]]-COUNTER(c,root_pos,Board[expanding],ValuePerPiece[Players.pieces[Board[expanding]]]),ValuePerPiece[Players.pieces[Board[expanding]]]));\
				stop = true;\
			} \
		}\
	break; \
} while (!stop)

#define REV_GEN_HVSLIDE(direction) \
expanding = root_pos ;\
stop=false;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case QUEEN:\
				delay = true; \
			case ROOK_NOT_MOVED: case ROOK:\
			{ \
				Move m(expanding,root_pos ATLINE);\
				MovesOrdered.push(m,CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos]]]-COUNTER(c,root_pos,Board[expanding],ValuePerPiece[Players.pieces[Board[expanding]]]),ValuePerPiece[Players.pieces[Board[expanding]]]));\
				stop = true;\
			} \
		}\
	break; \
} while (!stop)

#define REV_GEN_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) {\
		CAPTURE_VALUATION((root_pos+direction, root_pos ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos]]]-COUNTER(c,root_pos,Board[root_pos+direction],ValuePerPiece[Players.pieces[Board[root_pos+direction]]]),ValuePerPiece[Players.pieces[Board[root_pos+direction]]])));\
}

#define REV_GEN_PAWN \
	if (c==LIGHT) {REV_GEN_POS(-9,PAWN);REV_GEN_POS(-11,PAWN);} else {REV_GEN_POS(9,PAWN);REV_GEN_POS(11,PAWN); }


#define EX_REV_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT || Board[expanding] == exclude) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP:case QUEEN: return true;\
		}\
	break; \
} while (true)


#define DPINSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) == c) \
	{\
		PinTypes pt;\
		if (Players.pieces[Board[expanding]]!=BISHOP && Players.pieces[Board[expanding]]!=QUEEN) pt=Pinned;\
		else pt=PartiallyPinned;\
		const PieceSlotType pinned_piece = Board[expanding]; \
		pins[pin_count] = Board[expanding];\
		do {\
			expanding+=direction;\
			if (Board[expanding] == NO_SLOT) { \
				continue; \
			}\
			if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
				switch(Players.pieces[Board[expanding]]){\
					case BISHOP:case QUEEN: \
					pinner[pin_count++] = Board[expanding];\
					Players.pinned[pinned_piece] = pt;\
				}\
			break;\
		}while(true);\
	}\
	break; \
} while (true)

#define HVPINSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) == c) \
	{\
		PinTypes pt;\
		if (Players.pieces[Board[expanding]]!=ROOK && Players.pieces[Board[expanding]]!=ROOK_NOT_MOVED && Players.pieces[Board[expanding]]!=QUEEN) pt=Pinned;\
		else pt=PartiallyPinned;\
		const PieceSlotType pinned_piece = Board[expanding]; \
		pins[pin_count] = Board[expanding];\
		do {\
			expanding+=direction;\
			if (Board[expanding] == NO_SLOT) { \
				continue; \
			}\
			if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
				switch(Players.pieces[Board[expanding]]){\
					case ROOK_NOT_MOVED: case ROOK:case QUEEN: \
					pinner[pin_count++] = Board[expanding];\
					Players.pinned[pinned_piece] = pt;\
				}\
			break;\
		}while(true);\
	}\
	break; \
} while (true)

int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner)
{
	int pin_count = 0;
	int expanding;
	DPINSLIDE(-11);
	HVPINSLIDE(-10);
	DPINSLIDE(-9);
	HVPINSLIDE(-1);
	HVPINSLIDE(1);
	DPINSLIDE(9);
	HVPINSLIDE(10);
	DPINSLIDE(11);
	return pin_count;
}


//used for knight and king
#define REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;

#define EX_REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && Board[root_pos+direction] != exclude && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;

#define FIND_ATTACKER_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK: return Board[expanding];\
			case QUEEN: found_queen = Board[expanding];\
		}\
	break; \
} while (true)


#define FIND_ATTACKER_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP: return Board[expanding];\
			case QUEEN: found_queen = Board[expanding];\
		}\
	break; \
} while (true)


#define FIND_ATTACKER_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return Board[root_pos+direction];

#define FIND_ATTACKER_PAWN \
	if (c==LIGHT) {FIND_ATTACKER_POS(-9,PAWN);FIND_ATTACKER_POS(-11,PAWN);} else {FIND_ATTACKER_POS(9,PAWN);FIND_ATTACKER_POS(11,PAWN); }


#define WEIGHT_REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;


#define REV_PAWN \
	if (c==LIGHT) {REV_POS(-9,PAWN);REV_POS(-11,PAWN);} else {REV_POS(9,PAWN);REV_POS(11,PAWN); }

#define EX_REV_PAWN \
	if (c==LIGHT) {EX_REV_POS(-9,PAWN);EX_REV_POS(-11,PAWN);} else {EX_REV_POS(9,PAWN);EX_REV_POS(11,PAWN); }

PieceSlotType LeastAttacker(Colors c, Pos root_pos)
{
	PieceSlotType found_queen = NO_SLOT;
	int expanding;
	FIND_ATTACKER_PAWN;
	FIND_ATTACKER_POS(-21, KNIGHT);
	FIND_ATTACKER_POS(-19, KNIGHT);
	FIND_ATTACKER_POS(-12, KNIGHT);
	FIND_ATTACKER_POS(-8, KNIGHT);
	FIND_ATTACKER_POS(8, KNIGHT);
	FIND_ATTACKER_POS(12, KNIGHT);
	FIND_ATTACKER_POS(19, KNIGHT);
	FIND_ATTACKER_POS(21, KNIGHT);

	FIND_ATTACKER_DSLIDE(-11);
	FIND_ATTACKER_DSLIDE(-9);
	FIND_ATTACKER_DSLIDE(9);
	FIND_ATTACKER_DSLIDE(11);
	FIND_ATTACKER_HVSLIDE(-10);
	FIND_ATTACKER_HVSLIDE(-1);
	FIND_ATTACKER_HVSLIDE(1);
	FIND_ATTACKER_HVSLIDE(10);

	if (found_queen != NO_SLOT) return found_queen;

	FIND_ATTACKER_POS(-11, KING);
	FIND_ATTACKER_POS(-10, KING);
	FIND_ATTACKER_POS(-9, KING);
	FIND_ATTACKER_POS(-1, KING);
	FIND_ATTACKER_POS(1, KING);
	FIND_ATTACKER_POS(9, KING);
	FIND_ATTACKER_POS(10, KING);
	FIND_ATTACKER_POS(11, KING);

	return NO_SLOT;
}

int see_u(Colors side, Pos root_pos, int just_captured, int depth)
{
	if (depth == 0) return 0;
	PieceSlotType least = LeastAttacker(side, root_pos);
	if (least == NO_SLOT) return 0;
	Board[Players.positions[least]] = NO_SLOT;
	int v = just_captured - see_u(other_color(side), root_pos, ValuePerPiece[Players.pieces[least]],depth-1);
	Board[Players.positions[least]] = least;
	if (v < 0) return 0;
	return v;
}

int SEE(Colors c, Pos root_pos, PieceSlotType exclude, int depth)
{
	Board[Players.positions[exclude]] = NO_SLOT;
	int v = -see_u(c, root_pos, ValuePerPiece[Players.pieces[exclude]], depth);
	Board[Players.positions[exclude]] = exclude;
	return v;
}

int SEE(Pos root_pos)
{
	PieceSlotType s = Board[root_pos];
	if (!is_piece(s)) return 0;
	return SEE(color(s), root_pos, s, INF);
}

bool ThreatenedExcluding(Colors c, Pos root_pos, PieceSlotType exclude)
{
	int expanding;
	EX_REV_POS(-21, KNIGHT);
	EX_REV_POS(-19, KNIGHT);
	EX_REV_POS(-12, KNIGHT);
	EX_REV_POS(-11, KING);
	EX_REV_POS(-10, KING);
	EX_REV_POS(-9, KING);
	EX_REV_POS(-8, KNIGHT);
	EX_REV_POS(-1, KING);
	EX_REV_PAWN;
	EX_REV_POS(1, KING);
	EX_REV_POS(8, KNIGHT);
	EX_REV_POS(9, KING);
	EX_REV_POS(10, KING);
	EX_REV_POS(11, KING);
	EX_REV_POS(12, KNIGHT);
	EX_REV_POS(19, KNIGHT);
	EX_REV_POS(21, KNIGHT);
	EX_REV_DSLIDE(-11);
	EX_REV_HVSLIDE(-10);
	EX_REV_DSLIDE(-9);
	EX_REV_HVSLIDE(-1);
	EX_REV_HVSLIDE(1);
	EX_REV_DSLIDE(9);
	EX_REV_HVSLIDE(10);
	EX_REV_DSLIDE(11);
	return false;
}
bool Threatened(Colors c, Pos root_pos)
{
	int expanding;
	REV_POS(-21, KNIGHT);
	REV_POS(-19, KNIGHT);
	REV_POS(-12, KNIGHT);
	REV_POS(-11, KING);
	REV_POS(-10, KING);
	REV_POS(-9, KING);
	REV_POS(-8, KNIGHT);
	REV_POS(-1, KING);
	REV_PAWN;
	REV_POS(1, KING);
	REV_POS(8, KNIGHT);
	REV_POS(9, KING);
	REV_POS(10, KING);
	REV_POS(11, KING);
	REV_POS(12, KNIGHT);
	REV_POS(19, KNIGHT);
	REV_POS(21, KNIGHT);
	REV_DSLIDE(-11);
	REV_HVSLIDE(-10);
	REV_DSLIDE(-9);
	REV_HVSLIDE(-1);
	REV_HVSLIDE(1);
	REV_DSLIDE(9);
	REV_HVSLIDE(10);
	REV_DSLIDE(11);
	return false;
}

bool GenThreat(int &i, Colors c, Pos root_pos, int val, int depth)
{
	int expanding;
	bool stop;
	bool delay = false;
	switch (i)
	{
	case 0:
		if (c == LIGHT) { REV_GEN_POS(-9, PAWN);}
		else { REV_GEN_POS(9, PAWN); }
		i = 1;
		if (!MovesOrdered.empty()) return true;
	case 1:
		if (c == LIGHT) { REV_GEN_POS(-11, PAWN); }
		else { REV_GEN_POS(11, PAWN); }
		i = 2;
		if (!MovesOrdered.empty()) return true;
	case 2:
		REV_GEN_POS(-21, KNIGHT);
		i = 3;
		if (!MovesOrdered.empty()) return true;
	case 3:
		REV_GEN_POS(-19, KNIGHT);
		i = 4;
		if (!MovesOrdered.empty()) return true;
	case 4:
		REV_GEN_POS(-12, KNIGHT);
		i = 5;
		if (!MovesOrdered.empty()) return true;
	case 5:
		REV_GEN_POS(-8, KNIGHT);
		i = 6;
		if (!MovesOrdered.empty()) return true;
	case 6:
		REV_GEN_POS(8, KNIGHT);
		i = 7;
		if (!MovesOrdered.empty()) return true;
	case 7:
		REV_GEN_POS(12, KNIGHT);
		i = 8;
		if (!MovesOrdered.empty()) return true;
	case 8:
		REV_GEN_POS(19, KNIGHT);
		i = 9;
		if (!MovesOrdered.empty()) return true;
	case 9:
		REV_GEN_POS(21, KNIGHT);
		i = 10;
		if (!MovesOrdered.empty()) return true;
	case 10:
		REV_GEN_DSLIDE(-11);
		i = 11;
		if (!delay && !MovesOrdered.empty()) return true;
	case 11:
		REV_GEN_DSLIDE(-9);
		i = 12;
		if (!delay && !MovesOrdered.empty()) return true;
	case 12:
		REV_GEN_DSLIDE(9);
		i = 13;
		if (!delay && !MovesOrdered.empty()) return true;
	case 13:
		REV_GEN_DSLIDE(11);
		i = 14;
		if (!delay && !MovesOrdered.empty()) return true;
	case 14:
		REV_GEN_HVSLIDE(-10);
		i = 15;
		if (!delay && !MovesOrdered.empty()) return true;
	case 15:
		REV_GEN_HVSLIDE(-1);
		i = 16;
		if (!delay && !MovesOrdered.empty()) return true;
	case 16:
		REV_GEN_HVSLIDE(1);
		i = 17;
		if (!delay && !MovesOrdered.empty()) return true;
	case 17:
		REV_GEN_HVSLIDE(10);
		i = 18;
		if (!MovesOrdered.empty()) return true;
	case 18:
		REV_GEN_POS(-11, KING);
		i = 19;
		if (!MovesOrdered.empty()) return true;
	case 19:
		REV_GEN_POS(-10, KING);
		i = 20;
		if (!MovesOrdered.empty()) return true;
	case 20:
		REV_GEN_POS(-9, KING);
		i = 21;
		if (!MovesOrdered.empty()) return true;
	case 21:
		REV_GEN_POS(-1, KING);
		i = 22;
		if (!MovesOrdered.empty()) return true;
	case 22:
		REV_GEN_POS(1, KING);
		i = 23;
		if (!MovesOrdered.empty()) return true;
	case 23:
		REV_GEN_POS(9, KING);
		i = 24;
		if (!MovesOrdered.empty()) return true;
	case 24:
		REV_GEN_POS(10, KING);
		i = 25;
		if (!MovesOrdered.empty()) return true;
	case 25:
		REV_GEN_POS(11, KING);
		i = 26;
		if (!MovesOrdered.empty()) return true;
	case 26:
		break;
	}
	return false;
}


bool king_in_check(Colors c)
{
	return Threatened(c, Players.positions[base_by_color(c) + KINGP]);
}
/*
// fail-soft alpha-beta search
int alphabeta(int depth, int alpha, int beta)
{
	move bestmove;
	int current = -WIN;
	if (game over or depth <= 0) return winning score or eval();
	for (each possible move m) {
		make move m;
		score = -alphabeta(depth - 1, -beta, -alpha)
		unmake move m;
		if (score >= current) {
			current = score;
			bestmove = m;
			if (score >= alpha) alpha = score;
			if (score >= beta) break;
		}
	}
	return current;
}

int test_search(int depth, int beta)
{
	move bestmove;
	int current = -WIN;
	if (game over or depth <= 0) return winning score or eval();
	for (each possible move m) {
		make move m;
		score = -test_search(depth - 1, -beta+1)
		unmake move m;
		if (score >= current) {
			current = score;
			bestmove = m;
			if (score >= beta) break;
		}
	}
	return current;
}



The main difference is that with normal alpha/beta, _all_ scores you
store are >=alpha and <=beta.  With fail-soft, you store whatever is
backed up, even if it is > beta or < alpha.  When you have searched _all_
moves at a node, you have two outcomes:

(1) best score is > alpha and < beta (if it were >= beta you should have
already stopped searching.)  This is an EXACT score.

(2) best score is <= alpha.  This means this score is an upper bound,
that the true score could be lower.

int test = 0;
for (;;) {
	score = test_search(depth, test+1);
	if (test == score) break;
	test = score;
}
RECORD TransTableEntry IS
Tag : INTEGER;
Value : INTEGER;
Bound : (LB, UB, Exact);
Depth : INTEGER;
BestMove : INTEGER;
Aged : BOOLEAN;
END;
The Tag is used to distinguish positions. The field Value stores
the search result for the corresponding node, and Bound indicates whether this is a
lower bound, upper bound, or exact. Depth stores the search depth to which the node
was searched. BestMove identifies the child that is most likely the best. If Depth is
zero, the entry caches an evaluation value, and BestMove is void. The field Aged is
used to mark the entry as being old. After the tree is searched completely and the
computer made a move, all entries in the table are marked as old. Old entries can still
be used in the next search, but if multiple positions compete for a place in the same
cache line, old entries are evicted first, as described later.

*/

#define HALF_KILLERS 8
#define NUM_KILLERS 7

RelativeMove KillerTemp[HALF_KILLERS];

	RelativeMove BestMovePerPly[8][MAX_PLY];
	int BestMovePerPlyIndex[MAX_PLY];
	void clear_killer()
	{
		for (int i = 0;i < MAX_PLY;++i) {
			for (int j = 0;j < 4; ++j) BestMovePerPly[j][i].clear();
			BestMovePerPlyIndex[i] = 0;
		}
	}





	void add_killer(Move &c)
	{
		RelativeMove m(c);
		assert(m.from <= NO_SLOT);
		int b = BestMovePerPlyIndex[CurrentPly];
		if (BestMovePerPly[(b - 1) & (HALF_KILLERS - 1)][CurrentPly] == m) return;
		for (int i = 1;i < HALF_KILLERS;++i) {
			if (BestMovePerPly[(b - 1 - i) & (HALF_KILLERS - 1)][CurrentPly] == m) {
				KillerTemp[0] = m;
				int k = 1;
				for (int j = 0;j < HALF_KILLERS;++j) {
					if (j != i) KillerTemp[k++] = BestMovePerPly[(b - 1 - j) & (HALF_KILLERS - 1)][CurrentPly];
				}
				for (int j = 0;j < HALF_KILLERS;++j) {
					BestMovePerPly[(b - 1 - j) & (HALF_KILLERS - 1)][CurrentPly] = KillerTemp[j];
				}
				return;
			}
		}
		BestMovePerPly[BestMovePerPlyIndex[CurrentPly]][CurrentPly] = m;
		BestMovePerPlyIndex[CurrentPly] = (1 + BestMovePerPlyIndex[CurrentPly]) & (HALF_KILLERS - 1);
	}

	bool get_killers(RelativeMove **dest, int &i)
	{
		int b = BestMovePerPlyIndex[CurrentPly];
		int bn = BestMovePerPlyIndex[CurrentPly - 2];
		switch (i)
		{
		case 0:
		{
			RelativeMove &m = BestMovePerPly[(b - 1)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 1:
		{
			RelativeMove &m = BestMovePerPly[(b - 2)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 2:
		{
			RelativeMove &m = BestMovePerPly[(b - 3)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 3:
		{
			RelativeMove &m = BestMovePerPly[(bn - 1)&(HALF_KILLERS - 1)][CurrentPly - 2];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 4:
		{
			RelativeMove &m = BestMovePerPly[(b - 4)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 5:
		{
			RelativeMove &m = BestMovePerPly[(bn - 2)&(HALF_KILLERS - 1)][CurrentPly - 2];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 6:
		{
			RelativeMove &m = BestMovePerPly[(b - 5)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		/*
		case 7:
		{
			RelativeMove &m = BestMovePerPly[(bn - 3)&(HALF_KILLERS - 1)][CurrentPly - 2];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 8:
		{
			RelativeMove &m = BestMovePerPly[(b - 6)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 9:
		{
			RelativeMove &m = BestMovePerPly[(bn - 4)&(HALF_KILLERS - 1)][CurrentPly - 2];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 10:
		{
			RelativeMove &m = BestMovePerPly[(b - 7)&(HALF_KILLERS - 1)][CurrentPly];
			assert(m.from <= NO_SLOT);
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 11:
		{
			RelativeMove &m = BestMovePerPly[(b - 8)&(HALF_KILLERS - 1)][CurrentPly];
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 12:
		{
			RelativeMove &m = BestMovePerPly[(bn - 5)&(HALF_KILLERS - 1)][CurrentPly - 2];
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 13:
		{
			RelativeMove &m = BestMovePerPly[(bn - 6)&(HALF_KILLERS - 1)][CurrentPly - 2];
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 14:
		{
			RelativeMove &m = BestMovePerPly[(bn - 7)&(HALF_KILLERS - 1)][CurrentPly - 2];
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
		case 15:
		{
			RelativeMove &m = BestMovePerPly[(bn - 8)&(HALF_KILLERS - 1)][CurrentPly - 2];
			++i;
			if (!m.empty()) {
				*dest = &m;
				return true;
			}
		}
*/
		}
		return false;
	}

//KillerMoves QuietKillers;
//KillerMoves CaptureKillers;

HashMove EmptyRelativeMove;
//RelativeMove CounterMoveTable[NUM_PIECE_SLOTS*(h1 - a8 + 1)*(h1 - a8 + 1)];

struct CountMoveStruct
{
	HashMove move;
	int age;
	void set(Move &m)
	{
		move = m;
		age = history_len + ClearHash;
	}
	HashMove &get()
	{
		if (history_len + ClearHash - age < 4) return move;
		return EmptyRelativeMove;
	}
	CountMoveStruct() :age(0) {}
};

CountMoveStruct EmptyCMS;

CountMoveStruct CounterMoveTable[NUM_PIECE_SLOTS*NUM_PIECE_SLOTS*(h1 - a8 + 1) * 2 * (h1 - a8 + 1)];

CountMoveStruct &CounterMove(bool quiescent, RelativeMove &r)
{
	if (r.from == NO_SLOT) return EmptyCMS;
//	return CounterMoveTable[s + (h1 - a8 + 1)*(from - a8) + ((h1 - a8 + 1)*(h1 - a8 + 1))*(to - a8)];
	return CounterMoveTable[ (r.to-a8)+ (h1 - a8 + 1)*((r.from_pos - a8) + (h1 - a8 + 1)*(r.from + NUM_PIECE_SLOTS*(r.slot_taken +(quiescent? NUM_PIECE_SLOTS:0)
		)))];
}
struct MoveGenerator
{
	enum State { Initial,  PositiveCaptures, DoCounterMove, Killers, GeneratedMoves, IID };
	Move killer_moves[NUM_KILLERS+2];
	int num_killer;
	int killer_iterator;
	int capture_iterator;
	bool initial_ok;
	bool quiescent;
	State state;
	Colors side;
	bool history_sorted;
	int num_pin_moves;
	bool found;
	int count_positive;
	PieceSlotType last_piece_moved;
	RelativeMove last_move;
	int val;
	int depth;
	void init(int d, Move &initial, RelativeMove &lm, int v)
	{
		val = v;
		history_sorted = false;
		count_positive = 0;
		last_move = lm;
		last_piece_moved = last_move.from;
		num_pin_moves = 0;
		num_killer = 0;
		killer_iterator = 0;
		capture_iterator = 0;
		initial_ok = false;
		depth = d;
		quiescent = (d <= 0);
		state = Initial;
		side = PlySide();
		if (!initial.empty())
		{
			initial_ok = true;
			killer_moves[num_killer++] = initial;
		}
	}
	MoveGenerator(int depth, Move &initial, RelativeMove &lpm, int v)
	{
		init(depth, initial,lpm,v);
	}
	MoveGenerator()
	{
	}
	void clean_up()
	{
		NumPinMoves[side] -= num_pin_moves;
	}
	//returns see value of move or -INF for done
	int next(Move &c, State *kind=nullptr, int *value=nullptr)
	{
		switch (state) {
		case Initial:
			if (kind) *kind = state;
//			state = PositiveCaptures;
			if (initial_ok) {
				c = killer_moves[0];

				c.make();
				if (king_in_check(side)) {//illegal to make a move that leaves your king in check
					c.unmake();
				}
				else {
					initial_ok = false;
					return 1<<10;//dummy value
				}
				--num_killer;
			}
/*
			state = CounterCaptures;
		case CounterCaptures:
			if (last_piece_moved != OFF_BOARD && !is_king(Players.pieces[last_piece_moved])) {
				while (!MovesOrdered.empty() || GenThreat(capture_iterator, other_color(side), Players.positions[last_piece_moved])) {
					while (MovesOrdered.find_best() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
						) {
						MovesOrdered.best().make();
						if (king_in_check(side)) {//illegal to make a move that leaves your king in check
							MovesOrdered.best().unmake();
							continue;
						}
						c = MovesOrdered.best();
						if (kind) *kind = state;
						capture_iterator = 26;
						return MovesOrdered.best_value();
					}
				}
			}
*/
			state = DoCounterMove;

		case DoCounterMove:
		{
			if (false) 
			{
				HashMove &counter_move = CounterMove(quiescent, last_move).get();
				if (!counter_move.empty()) {
					bool duplicate = false;
					for (int i = 0;i < num_killer;++i) if (counter_move.from == killer_moves[i].from && counter_move.to == killer_moves[i].to) { duplicate = true; break; }
					if (!duplicate) {
						c = TestMove(side, Board[counter_move.from], counter_move.to, counter_move.became);
						if (!(c.empty())) {
							c.make();
							if (king_in_check(side)) {//illegal to make a move that leaves your king in check
								c.unmake();
							}
							else {
								killer_moves[num_killer++] = c;
								if (kind) *kind = state;
								state = Killers;
								return 1 << 10;//dummy value
							}
						}
					}
				}
			}
		}
		state = PositiveCaptures;
		if (quiescent) {
//				if (NumPins[side] != 0) {
//					num_pin_moves = GenPinMoves(side, NumPinMoves[side], PinMoves[side]);
//				}
				QGenMoves(side,val,depth);
			}
			else {
				GenMoves(side,val,depth);
			}
		case PositiveCaptures:
			if (kind) *kind = state;
			found = false;
			//if (!quiescent)
			while (MovesOrdered.find_best() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
//			while (!MovesOrdered.empty() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
					) {
				if (MovesOrdered.best().empty()) continue;
				//				if (last_piece_moved != OFF_BOARD && MovesOrdered.best().slot_taken == last_piece_moved && MovesOrdered.best().is_enpassant()==false) continue;
				if (++count_positive > 2 || MovesOrdered.best_value() >> 10 <= 0) {
//				if (MovesOrdered.back_value() >> 10 <= 0) {
					found = true;
					break;
				}
				if (is_king(MovesOrdered.best().piece_taken)) {
//				if (is_king(MovesOrdered.back().piece_taken)) {
//					MovesOrdered.pop();
					continue;
				}
//				cout << '.';
				MovesOrdered.best().make();
//				MovesOrdered.back().make();
				if (king_in_check(side)) {//illegal to make a move that leaves your king in check
					MovesOrdered.best().unmake();
//					MovesOrdered.back().unmake();
//					MovesOrdered.pop();
					continue;
				}
				c = MovesOrdered.best();
//				c = MovesOrdered.back();
//				int v = MovesOrdered.back_value();
				int v = MovesOrdered.best_value();
				MovesOrdered.pop();
				if (kind) *kind = state;
				return v;
			}
//			if (CurrentPly < 7) {
//				state = GeneratedMoves;
//				MovesOrdered.add_history(quiescent);
//			}
//		else
				state = Killers;
		case Killers:
			{
			if (kind) *kind = state;
			RelativeMove *m;
				while (get_killers(&m, killer_iterator)) {
					if (Players.pieces[m->from] == EMPTY) continue;
					bool duplicate = false;
					for (int i = 0;i < num_killer;++i) if (*m == killer_moves[i]) { duplicate = true; break; }
					if (duplicate) continue;
					if (Board[m->from_pos] == m->from && (Board[m->to]==NO_SLOT || color(Board[m->to])!= side)) {
						c = TestMove(side, m->from, m->to, m->promotion);
					}
					else continue;
					if (c.empty()) continue;
					c.make();
					if (king_in_check(side)) {//illegal to make a move that leaves your king in check
						c.unmake();
						continue;
					}
					killer_moves[num_killer++] = c;
//					cout << '+';
					if (kind) *kind = state;
					return 1 << 10;//dummy value
				}
				for (int i = 0;i < num_killer;++ i) {
					if (sort_pv(killer_moves[i])) MovesOrdered.pop();
				}
				if (found) state = GeneratedMoves;
				else return -INF;
		}
			MovesOrdered.add_history(quiescent);
			//bool LazyGenMove(int &i, bool quiescent, Colors c, Move *killer_moves, int num_killer)

		case GeneratedMoves:
			if (kind) *kind = state;
			while (found || MovesOrdered.find_best() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
//			while (!MovesOrdered.empty() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
					) {
					found = false;
					if (MovesOrdered.best().empty()) continue;
//					if (!history_sorted && MovesOrdered.best_value() <= 0) {
//						history_sorted = true;
//						MovesOrdered.add_history(quiescent);
//						found = true;
//						continue;
//					}
//				if (MovesOrdered.back().empty()) { MovesOrdered.pop(); continue; }

//					if (last_piece_moved != OFF_BOARD && MovesOrdered.best().slot_taken == last_piece_moved && MovesOrdered.best().is_enpassant() == false) continue;
//				if (is_king(MovesOrdered.back().piece_taken)) {
					if (is_king(MovesOrdered.best().piece_taken)) {
//					MovesOrdered.pop();
						continue;
					}
//					cout << ';';
					MovesOrdered.best().make();
//					MovesOrdered.back().make();
					if (king_in_check(side)) {//illegal to make a move that leaves your king in check
						MovesOrdered.best().unmake();
//						MovesOrdered.back().unmake();
//						MovesOrdered.pop();
						continue;
					}
					c = MovesOrdered.best();
//					c = MovesOrdered.back();
//					int v = MovesOrdered.back_value();
					int v = MovesOrdered.best_value();
//					MovesOrdered.pop();

					if (kind) *kind = state;
//					return MovesOrdered.best_value();
					return v;
				}
			state = IID;
/*
			if (!MovesIID.empty()) {
				Captures.clear();
				while (!MovesIID.empty()) {
					Captures.push(MovesIID.back(), MovesIID.back_value());
					MovesIID.pop();
				}
				Captures.sort();
				while (!Captures.empty()) {
					MovesOrdered.push(Captures.back(), Captures.back_value());
					Captures.pop();
				}
			}
*/
		case IID:
			/*
			if (!MovesOrdered.empty()) {
				c = MovesOrdered.back();
				if (value) *value = MovesOrdered.back_value();
				c.make();
				MovesOrdered.pop();
				if (kind) *kind = state;
				return true;
			}*/
			return -INF;
		}
		return -INF;
	}
};

MoveGenerator MoveGenerators[MAX_PLY];

int CapturesC = 0;
int Checks = 0;
int Checkmates = 0;


int _perft(int d)
{
	int nodes = 0;
	int moves = 0;
	bool check = king_in_check(PlySide());
	int e = Enpassants;
	inc_ply();
	GenMoves(other_color(PlySide()),0,-20);
	if (d != 1) Enpassants = e;
	while (!MovesOrdered.empty()) {
		int e_2 = Enpassants;
		MovesOrdered.back().make();
		if (king_in_check(other_color(PlySide()))) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			Enpassants = e_2;
			MovesOrdered.pop();
			continue;
		}
		++moves;
		if (d > 0) {
			if (MovesOrdered.back().piece_taken != EMPTY && d==1) ++CapturesC;
			nodes += _perft(d - 1);
		}
		MovesOrdered.back().unmake();
		MovesOrdered.pop();
	}
	dec_ply();

	if (check) {
		if (d == 0 && moves == 0) ++Checkmates;
		if (d==0) ++Checks;
	}
	if (d == 0) return 1;
	return nodes;
}

int perft(int d)
{
	CapturesC = 0;
	Checks = 0;
	Checkmates = 0;
	Enpassants = 0;
	Castles = 0;
	return _perft(d);
}
#define STAND_PAT

inline bool close_to_mate(int score)
{
	return abs(abs(score) - KING_VALUE) < (KING_VALUE >> 1);
}

#define FUTILITY
#define REVERSE_FUTILITY

//#define IGNORE_TT


bool USE_TT = true;

int See(Pos);

RelativeMove EmptyMove;

int CheckupNodes;

int NCNodes = 0;
int NCMidNodes = 0;

int NumFailHighNodes = 0;
int NumberOnFirstMove = 0;
int NumberOfFailHighMoves = 0;

#define NULL_MOVE
int NegaScout(int alpha, int beta, int d, bool in_null, bool somewhere_in_null, bool alpha_real, bool beta_real,RelativeMove &last_move)
{
	PieceSlotType last_piece_moved = last_move.from;
	if (d <= 0) {
		++Nodes;
		++MidNodes;
	}
	else {
		++NCNodes;
		++NCMidNodes;
	}

	++CheckupNodes;
	if ((CheckupNodes & 1023) == 0)
		checkup();
	if (d == 0) {
		NumPinMoves[PlySide()] = 0;
	}
	Colors my_color = PlySide();
	HashTableEntry *n=nullptr;
	Move m2;
//	if (d>0)
	{
		n = GetOrMakeHash(d <= 0);
#ifndef IGNORE_TT
		int lower = n->get_lower(d);
		int upper = n->get_upper(d);
		bool hash_move_repeat = false;
		HashMove *m = &n->get_move();
		m2 = TestMove(PlySide(), Board[m->from], m->to, m->became);
		if (!m2.empty()) {
			inc_ply();
			m2.make();
			hash_move_repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
			if (hash_move_repeat) {
//				upper = lower = -n->get_eval() >> 1;
				if ((CurrentPly & 1) == 0) upper = lower = -2 * PAWN_VALUE;
				else upper = lower = 2 * PAWN_VALUE;
			}
			m2.unmake();
			dec_ply();
		}
		if (!hash_move_repeat && lower >= beta) {
			if (CurrentPly == 0) {
				if (!m2.empty()) {
					Ply0Move = m2;
					if (d <= 0) --MidNodes; else --NCMidNodes;
					return lower;
				}
				else {
					lower = alpha;
					upper = beta;
				}
			}
			else {
				if (d <= 0) { --MidNodes; }
				else { 
/*
int NumFailHighNodes = 0;
int NumberOnFirstMove = 0;
int NumberOfFailHighMoves = 0;
*/	
//					++NumFailHighNodes;
//					++NumberOnFirstMove;
					--NCMidNodes; 
				}
				return lower;
			}
			;
		}
		if (!hash_move_repeat && (upper <= alpha || upper == lower)) {
			if (CurrentPly == 0) {
				if (!m2.empty()) {
					Ply0Move = m2;
					if (d<=0) --MidNodes; else --NCMidNodes;
					return lower;
				}
				else {
					lower = alpha;
					upper = beta;
				}
			}
			else {
				if (d<=0) --MidNodes; else --NCMidNodes;
				return upper;
			}
		}
		if (CurrentPly == 0 && Ply0Move.empty()) {
			if (!m2.empty()) {
				Ply0Move = m2;
			}
		}
		if (CurrentPly != 0) {
			alpha = __max(alpha, lower);
			beta = __min(beta, upper);
		}
	}
#endif
	int g, a;
	int second_best_value = INF;

	if (d == -QUIESCENT_DEPTH) {
		g = (n == nullptr ? eval() : n->get_eval()); /* leaf node */
		if (last_piece_moved != OFF_BOARD) g = g - SEE(Players.positions[last_piece_moved]);
	}
	else {
		int val = (n == nullptr ? eval() : n->get_eval());
		if (last_piece_moved != OFF_BOARD) val = val - SEE(Players.positions[last_piece_moved]);
		const bool in_check = king_in_check(PlySide());

#ifdef FUTILITY
		if (alpha_real && !in_check && CurrentPly>0 && !(close_to_mate(alpha) || close_to_mate(beta))) {
			if (n != nullptr && n->get_upper(d - 1) + BISHOP_VALUE < alpha) {
				if (d<=0) --MidNodes; else --NCMidNodes;
				return n->get_upper(d - 1);
			}
			if (n != nullptr && n->get_upper(d - 2) + ROOK_VALUE < alpha) {
				if (d<=0) --MidNodes; else --NCMidNodes;
				return n->get_upper(d - 2);
			}
			//			if (d == 1 && val + BISHOP_VALUE < alpha) return val;
			//			if (d == 2 && val + ROOK_VALUE < alpha) return val;
		}
#endif
		if (d < 1 && !in_check)
		{
			if (val > beta) {
				if (d <= 0) --MidNodes; else --NCMidNodes;
				return val; //stand pat
			}
			if (n != nullptr)
				if (n->get_lower(-QUIESCENT_DEPTH) > beta) {
					if (d <= 0) --MidNodes; else --NCMidNodes;
					return n->get_lower(-QUIESCENT_DEPTH);
				}

		}

#ifdef REVERSE_FUTILITY
		if (beta_real && !in_check && CurrentPly > 0 && !(close_to_mate(alpha) || close_to_mate(beta))) {
			if (n != nullptr && n->get_lower(d - 1) - BISHOP_VALUE > beta) {
				if (d <= 0) { --MidNodes; }
				else { --NCMidNodes; 
//					++NumFailHighNodes;
//					++NumberOnFirstMove;
				}
				return n->get_lower(d - 1);
			}
			if (n != nullptr && n->get_lower(d - 2) - ROOK_VALUE > beta) {
				if (d <= 0) { --MidNodes; }
				else { 
//					++NumFailHighNodes;
//					++NumberOnFirstMove;
					--NCMidNodes; 
				}
				return n->get_lower(d - 2);
			}
			//			if (CurrentPly > 3 && d == 1 && val - BISHOP_VALUE > beta) return val;
			//			if (beta_real && CurrentPly > 3 && d == 2 && val - ROOK_VALUE > beta) return val;
		}
#endif

#ifdef NULL_MOVE
		if (beta_real &&
			beta != INF &&
			!in_null 
			//!somewhere_in_null
			&&
			//CurrentPly>2 &&
			!in_check &&
			CheckForEndgame && 
			d > 1 &&
			(somewhere_in_null || RepeatList.count(my_color) < 3)
			) {
			inc_ply();
			int new_value;
			try {
				int new_depth = __max(d - 4, 0);//(d>6?__max(d - 5, 0): __max(d - 4, 0));
				new_value = -NegaScout(-beta,-beta+1,new_depth,true,true,beta_real,false, EmptyMove);
			}
			catch (OutOfTimeException) {
				dec_ply();
				throw OutOfTime;
			}
			dec_ply();
			if (new_value > beta) {
//				if (CheckForEndgame) {
				if (d <= 0)  --MidNodes; else --NCMidNodes;
					return beta;
//				}
//				else d = __max(d - 4, 0);
			}
		}
#endif
		if (d == 1)--NCMidNodes;
		Move c;
		Move best_move;
		//int best_value;
		MoveGenerator::State best_move_type;

		MoveGenerator &moves = MoveGenerators[CurrentPly];
		moves.init(in_check?1:d,m2,last_move,val);
		g = -INF; a = alpha; /* save original alpha value */
		inc_ply();
		int move_count = 0;
		MoveGenerator::State move_type;
		int reduced = 0;
		int iid_value;
		MovesIID.inc_ply();

		bool in_endgame = SideInEndgame(my_color);

		if (SufficientPieces == 0 && MinorPieces[LIGHT] < 2 && MinorPieces[DARK] < 2) {
			//g = 0;
			if ((CurrentPly & 1) == 1) g = -2 * PAWN_VALUE;
			//if ((CurrentPly & 1) == 1 && val > -PAWN_VALUE*3>>1 && val < PAWN_VALUE*3>>1) val1 = -PAWN_VALUE*3>>2;
			else g = 2 * PAWN_VALUE;
			if (d <= 0)  --MidNodes; else --NCMidNodes;
		}
		else {
			int move_value;
			while ((g < beta) && -INF!=(move_value= moves.next(c,&move_type,&iid_value))) {
				RelativeMove r(c);
				bool delay = false;
				++move_count;
				//moves.next calls c.make()
				int new_depth=d-1;
				bool skip_high_fail = false;
/*
				if (move_type == MoveGenerator::IID) {
					if (++reduced > 1 && d > 3) {
						skip_high_fail = true;
						new_depth = d - 3;
					}
					else {
						new_depth = d - 2;
						if (d==2) skip_high_fail = true;
					}
				}
				else {
					delay = d > 2 && !in_check && (move_type != MoveGenerator::GeneratedMoves) && c.slot_taken == NO_SLOT && c.became == c.initial && !is_king(c.initial);
					if (delay) new_depth = d - 3;
					else new_depth = d - 1;
				}
*/
//				if (d < 3 && ((CurrentPly & 1) == 1) && move_count > 1 && move_type == MoveGenerator::GeneratedMoves && c.slot_taken != NO_SLOT) {
//					c.unmake();
//					continue;
//				}

				delay = d > 2 && !in_check && move_type == MoveGenerator::GeneratedMoves //(iid_value >> 10 <= 0)  // || move_count>=3) 
					//&& c.slot_taken == NO_SLOT 
					&& c.became == c.initial && !is_king(c.initial) && !(in_endgame && is_pawn(c.initial));
				if (delay) {
					++reduced;
					if (d > 4 && reduced > 3
						)
						new_depth = d - 3; else new_depth = d - 2;
				}
				//if (iid_value >> 10 <= 0 && move_count > 3) {
				//	delay = true;
				//	new_depth = d - 2;
				//}

				bool repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
				try {
					int val1;
					if ( !repeat && delay) {
						if (a != -INF) {
//							val1 = -NegaScout(-beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to]);
							val1 = -NegaScout(-(a + 1), -a, new_depth, false, somewhere_in_null, false, true, r);
//							val1 = -NegaScout(-beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, Board[c.to]);
							if (val1 > a) {
								new_depth = d - 1;
								delay = false;
							}
						}
						else {
//							val1 = -NegaScout(-beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to]);
							new_depth = d - 1;
							delay = false;
						}
						//delay = false;
					}
					if (repeat) {
						if ((CurrentPly & 1) == 1) val1 = -2 * PAWN_VALUE;
						//if ((CurrentPly & 1) == 1 && val > -PAWN_VALUE*3>>1 && val < PAWN_VALUE*3>>1) val1 = -PAWN_VALUE*3>>2;
						else val1 = 2 * PAWN_VALUE;
						++Nodes;
					}
					else if (delay);

					else if (a == beta - 1) {
						val1 = -NegaScout(-beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, r);
//						if (new_depth!=d-1 && val1 > a) {
//							delay = false;
//							new_depth = d - 1;
//							val1 = -NegaScout(-beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to]);
//						}
					}
					else if (a == -INF && beta == INF //|| (d>0 && CounterMove(false, last_move).get().empty())
						) {

						int inc = 16;
						int low = firstguess - inc;
						int high = firstguess + inc;

						val1 = -NegaScout(-high, -low, new_depth, false, somewhere_in_null, false, false, r);
						 if (val1<low) {
							 do {
								 low = val1 - inc;
								 inc = inc+ (inc>>1);
								 val1 = -NegaScout(-val1, -low, new_depth, false, somewhere_in_null, true, false, r);
							 } while (val1 < low);
						}
						else if (val1 >= high) {
							do {
								high = val1 + inc;
								inc = inc + (inc>>1);
								val1 = -NegaScout(-high, -val1, new_depth, false, somewhere_in_null, false, true, r);
							} while (val1 >= high );
						}

/*
						val1 = -NegaScout(-(firstguess+1), -firstguess, new_depth, false, somewhere_in_null, false, false, r);
						if (val1<firstguess) {
							do {
								firstguess = __min(val1,firstguess);
								val1 = -NegaScout(-(firstguess + 1), -firstguess, new_depth, false, somewhere_in_null, false, false, r);
							} while (val1 < firstguess);
						}
						else {
							do {
								firstguess = __max(val1,firstguess);
								val1 = -NegaScout(-(firstguess + 1), -firstguess, new_depth, false, somewhere_in_null, false, false, r);
							} while (val1 >= firstguess);
						}
*/
					}
					else {
						if (a == -INF) {
							val1 = -NegaScout(-beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, r);
//							if (new_depth != d - 1 && val1 > a) {
//								delay = false;
//								new_depth = d - 1;
//								val1 = -NegaScout(-beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, Board[c.to]);
//							}
							if (val1 < beta) {
								val1 = -NegaScout(-val1, -a, new_depth, false, somewhere_in_null, true, true, r);
//								int low, inc = 16;
//								do {
//									low = val1 - inc;
//									inc = inc +(inc>> 1);
//									val1 = -NegaScout(-val1, -low, new_depth, false, somewhere_in_null, true, false, r);
//								} while (val1 < low);
							}
						}
						else if (beta == INF) {
							val1 = -NegaScout(-(a + 1), -a, new_depth, false, somewhere_in_null, false, true, r);
							if (val1 >= a) {
								val1 = -NegaScout(-beta, -val1 + 1, new_depth, false, somewhere_in_null, true, true, r);
//								if (abs(val2 - val1) < PAWN_VALUE) val1 = (val1 + val2) >> 1;
//								else val1 = -NegaScout(-val2, -val1, new_depth, false, somewhere_in_null, true, false, r);
							}
						}
						else {
							val1 = -NegaScout(-beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, r);
							if (val1 < beta) {
								val1 = -NegaScout(-val1, -a, new_depth, false, somewhere_in_null, true, true, r);
							}
							/*
							int val2;
							val1 = -NegaScout(-(a + 1), -a, new_depth, false, somewhere_in_null, false, true, r);
							if (val1 < beta && val1 >= a) {
								val2 = -NegaScout(-beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, r);
								if (abs(val2 - val1) < PAWN_VALUE) val1 = (val1 + val2) >> 1;
								else val1 = -NegaScout(-val2, -val1, new_depth, false, somewhere_in_null, true, false, r);
							}
*/
								/*
								if (beta - val1 >= 32) {
									int limit;
									int inc = 16;
									do {
										limit = __min(val1 + inc, beta);
										inc = inc + (inc>>1);
										val1 = -NegaScout(-limit, -val1, new_depth, false, somewhere_in_null, limit==beta, true, r);
									} while (val1>=limit && limit<beta);
								} else
									val1 = -NegaScout(-beta, -val1, new_depth, false, somewhere_in_null, true, true, r);
*/
								//								for (;;) {
//									val2 = -NegaScout(-val1-1, -val1, new_depth, false, somewhere_in_null, false, true, r, can_reduce&&new_depth == d - 1);
//									if (val2 <= val1) break;
//									val1 = val2;
//								}
//							}
							//}
							/*
							val1 = -NegaScout(-(a + 1), -a, d - 1, false, somewhere_in_null);
							if (val1 > a && val1 < beta) {
								int val2 = -NegaScout(-beta, -beta + 1, d - 1, false, somewhere_in_null);
								if (val2<beta && val2>val1) val1 = -NegaScout(-val2, -val1, d - 1, false, somewhere_in_null);
								else val1 = val2;
	*/

						}
					}
					//if (delay) MovesIID.push(c, val1);
					//else r
					if (val1 > g) {
						second_best_value = g;
						g = val1;
						best_move = c;
						//best_value = move_value;
						best_move_type = move_type;
						if (CurrentPly == 1) Ply0Move = c;
					}
				}
				catch (OutOfTimeException)
				{
					c.unmake();
					MovesIID.dec_ply();
					dec_ply();
					moves.clean_up();
					throw OutOfTime;
				}
				if (g > a) {
					a = g;
				}
				c.unmake();
			}
		}
		moves.clean_up();
		MovesIID.dec_ply();

		if (g >= beta) {
			++NumFailHighNodes;
			if (move_count == 1) ++NumberOnFirstMove;
		}

//		if (//(g >= beta || d<=0) &&
//			!best_move.empty() //&& (best_move.slot_taken == NO_SLOT  || d<=0)
//			&& !last_move.empty()
//			//&& d>0
//			) {
//			CounterMove(d<=0,last_move).set(best_move);
//		}
		if (!best_move.empty()) GetHH(d <= 0, RelativeMove(best_move)).set((d + QUIESCENT_DEPTH + 1) << (g >= beta ? (beta_real ? 2 : 1) : 0));

		if (g >= beta && 
			!best_move.empty() //&& best_value >> 10 <= 0
			&& best_move_type == MoveGenerator::GeneratedMoves //&& d>0 
			) {
			add_killer(best_move);
		}

		dec_ply();
		if (n != nullptr && !best_move.empty()) {
			if (!(Hash == n->key)) n = nullptr;
			else n->set_move(best_move);
		}
		if (g == -INF) {
			if (d < 1) return (n == nullptr?eval():n->get_eval());
			if (in_check) return -KING_VALUE-d-QUIESCENT_DEPTH;//includes waiting penalty
			return 0;
		}
	}


	if (n != nullptr && n->key == Hash)
	{
		/* Traditional transposition table storing of bounds */
		/* Fail high result implies a lower bound */
		//n->singular = false;
		if (g >= beta) //if (beta_real)
		{
			n->set_lower(d, g); 
			n->lower_exact = false;
		}
		/* Fail low result implies an upper bound */
		else if (g <= alpha) //if (alpha_real) 
		{
			n->set_upper(d, g);
			n->upper_exact = false;
		}
		/* Found an accurate minimax value - will not occur if called with zero window */
		else {
			//if(alpha_real) 
				n->set_lower(d, g);
			//if (beta_real) 
				n->set_upper(d, g);
			//if (alpha_real && beta_real) 
				n->upper_exact = n->lower_exact = true;
		//	if (g - second_best_value >= PAWN_VALUE >> 1)n->singular = true;
		}
	}
	return g;
}


int MTDF(int g, int d)
{
	return NegaScout(-INF,INF,d,false,false,true,true,RelativeMove());
	int upperbound = INF;
	int lowerbound = -INF;
	do {
		int beta;
		if (g == lowerbound) beta = g + 1; else beta = g;
		assert(CurrentPly == 0);
		g = NegaScout(beta - 1, beta, d,false,false,false,false,RelativeMove());
		assert(CurrentPly == 0);
		if (g < beta) upperbound = g; else lowerbound = g;
	}while(lowerbound < upperbound);
	return g;
}

int DepthIncBy = 0;
int TimeExtendCounter = 0;
int MaxTime;
int StartTime;
int MaxDepth;
int MinDepth;
int TimeIncBy = 0;
int clock;
bool TimeExtended;
bool add_time()
{
	if (MaxDepth == MAX_PLY) {
		if (clock > MaxTime << 4) {
			clock -= MaxTime;
			TimeIncBy += MaxTime;
			StopTime += MaxTime;
			TimeExtended = true;
//			printf("-t");
		}
		else return false;
	}
	else {
		DepthIncBy += 1;
		MaxDepth += 1;
//		printf("-d");
	}
	++TimeExtendCounter;
	return true;
}
bool extended_time()
{
	return DepthIncBy != 0 || TimeIncBy != 0;
}
void restore_time()
{
	TimeExtendCounter = 0;
	MaxDepth -= DepthIncBy;
	DepthIncBy = 0;
	TimeIncBy = 0;
}

bool test_extend_time(int x)
{
	return false;
	if (x < PAWN_VALUE -(PAWN_VALUE >> 2) &&  first_guess() - x >= PAWN_VALUE - (PAWN_VALUE >> 2)) {
		int limit;
		if (x >= ROOK_VALUE - (PAWN_VALUE >> 2)) limit = 20;
		else if (x > KNIGHT_VALUE - (PAWN_VALUE >> 2)) limit = 15;
		else limit = 8;
		if (TimeExtendCounter >= limit) {
			return false;
		}
		return add_time();
	}
	return false;
}


void endgame_check()
{
	if (!CheckForEndgame) return;
	if (SideInEndgame(LIGHT) && SideInEndgame(DARK)) {
		CheckForEndgame = false;
		EndGamePoint = history_len; //for takeback
	}
}

void think(int output)
{
	NumFailHighNodes=0;
	NumberOnFirstMove=0;

	USE_TT = true;
	EphemeralValue = 0;
	TimeExtended = false;
	int i, j, x;
	for (i = 0;i < MAX_PLY;++i) {
		for (j = 0;j < 4; ++j) {
//			CaptureKillers.BestMovePerPly[j][i].clear();
			BestMovePerPly[j][i].clear();
		}
//		CaptureKillers.BestMovePerPlyIndex[i] = 0;
		BestMovePerPlyIndex[i] = 0;
	}
	Ply0Move.clear();

/*
	if (!DisableBook && book_move()) {
		pv[0][0] = MovesOrdered.back();
		MovesOrdered.clear();
		return;
	}
*/
	endgame_check();

	TimedOut = false;
	StartTime = get_ms();
	StopTime = StartTime + MaxTime;
	Nodes = 0;
	MidNodes = 0;
	NCNodes = 0;
	NCMidNodes = 0;
	//	memset(history, 0, sizeof(history));
	if (output == 1)
		printf("ply      nodes  score  pv\n");
	for (i = 1; i <= MaxDepth; ++i) {
//		if (i == 5)USE_TT = true;

//		if (i < 7) QUIESCENT_DEPTH = 5;
//		else 
			QUIESCENT_DEPTH = 5;

		MinDepth = i;
		HashType test = Hash;
		try {
			x = MTDF(firstguess, i);
			assert(test == Hash);
			Ply0Alpha = x;
			firstguess = x;
		}
		catch (OutOfTimeException)
		{
			assert(CurrentPly == 0);
			break;
		}

		//get principle variation
		pv[0] = Ply0Move;
		if (Ply0Move.empty())
		{
			pv_length = 0;
		}
		else {
			pv_length = 1;

			for (j = 0;j < MAX_PLY - 2;++j) {
				pv[j].make();
				inc_ply();
				HashTableEntry *e = GetHash(false);
				if (e != nullptr) {
					HashMove *m = &(e->get_move());
					if (!m->empty()) {
						Move c = TestMove(PlySide(), Board[m->from], m->to, m->became);
						if (!c.empty()) {
							pv[j + 1] = c;
							pv_length = j + 2;
							continue;
						}
					}
				}
				break;
			}
			while (CurrentPly != 0) {
				dec_ply();
				pv[CurrentPly].unmake();
			}
			assert(test == Hash);
		}
		//4000
		int y = x;
		if (y > 500) y = 500;
		if (y < -500) y = -500;
		int end_time = get_ms();
		if (output == 1)
			printf("%3d  %9d  %7d  %5d %f nps ", i, Nodes, (pv[0].from / 10 - 2) * 8 + (pv[0].from % 10 - 1), y * 20, Nodes*1000.0 / (end_time - StartTime));   // @ED
		else if (output == 2) {
			printf("%d %d %d %d %.2g %.2g %.2g",
				MinDepth, x, (end_time - StartTime) / 10, Nodes, (double)Nodes / MidNodes, (double)NCNodes / NCMidNodes, (double)NumberOnFirstMove / NumFailHighNodes
		);
			LOG(Log << "depth:"<<MinDepth<<" score" <<x<<" time:"<<(end_time - StartTime) / 10<<" Nodes:"<< Nodes<<" median branching factor quiescent:" <<(double)Nodes / MidNodes<<" median branching factor:"<<(double)NCNodes / NCMidNodes<<" fail high on first:"<< (double)NumberOnFirstMove / NumFailHighNodes)<<endl;
		}
		if (output) {
			for (j = 0; j < pv_length; ++j) {
				if (pv[j].empty()) break;
				printf(" %s", move_str(pv[j]));
			}
		}

		printf("\n");
		fflush(stdout);

		if (TimedOut || x >= KING_VALUE || x <= -KING_VALUE)
			break;
	}
	if (extended_time()) { LOG(Log << "extended time " << MaxTime << endl); }
	LOG(Log << "computer moved at " << move_str(pv[0]) << endl);
	restore_time();
	if (TimeExtended) set_first_guess(Ply0Alpha);
	else add_first_guess(Ply0Alpha);
}

bool whitespace(char i)
{
	return i == ' ' || i == '\t' || i == '\n' || i == '\r' || i == '\v' || i == '\f';
}

char *gets(char *str, int num) {
	return fgets(str, num, stdin);
}

void takeback()
{
	if (history_len == 0) return;
	int hl = history_len;
	Move temp[MAX_MOVES];
	for (int i = 0;i < history_len;++i) temp[i] = History[i];
	int side = PlySide();
	init_board();
	for (int i = 0;i < hl - 1;++i) {
		set_side(other_color(PlySide()));
		temp[i].make();
		History[history_len++] = temp[i];
	}
}

bool make_move(Move &m)
{
	set_side(other_color(PlySide()));
	m.make();
	if (king_in_check(other_color(PlySide()))) {//illegal to make a move that leaves your king in check
		m.unmake();
		set_side(other_color(PlySide()));
		return false;
	}
	return true;
}

#define SAFETY_MARGIN 100
#define CLOCK_SAFETY_MARGIN 100

int control_period, control_period_original, time_base_min, time_base_sec, time_inc, time_base;
int exact_time;
bool roll_over_check;
int roll_over_increment;
void xboard()
{
	char line[256], command[256];
	int m;
	int post = 0;

	control_period = 0; time_base_min = 0; time_base_sec = 0; time_inc = 0; time_base = 0; clock = 0, exact_time=0;

	printf("\n");
	init_board();
	log_board();
	//	gen();
	computer_side = NO_COLOR;
	for (;;) {
		fflush(stdout);
		if (PlySide() == computer_side) {
			if (MaxDepth != MAX_PLY) {
				LOG(Log << "using depth " << MaxDepth << endl;);
				MaxTime = 1 << 25;
			} else
			if (exact_time != 0) {
				LOG(Log<<"using exact time " << exact_time << endl);
				MaxTime = exact_time;
			}
			else {
				if (control_period != 0) {
					LOG(Log << "control_period "<< control_period<<" clock "<<clock<<" time_inc "<<time_inc<<endl);
					//MaxTime = (clock- SAFETY_MARGIN) / (abs(control_period)*3>>1);
					MaxTime = (clock - CLOCK_SAFETY_MARGIN)/ (abs(control_period));
					if (MaxTime <= 0) {
						if (time_inc > 0) MaxTime = 0;
						else MaxTime = clock / (abs(control_period) + 1);
					}
					clock -= MaxTime;
					if (clock <= SAFETY_MARGIN) {
						if (time_inc > SAFETY_MARGIN) MaxTime += time_inc - SAFETY_MARGIN;
						else MaxTime += 7*time_inc>>3;
					}
					else if (time_inc > SAFETY_MARGIN)
						MaxTime += time_inc - SAFETY_MARGIN;
					else MaxTime += 7*time_inc>>3;
					if (control_period > 0) {
						--control_period;
						if (control_period == 0) control_period = control_period_original;
					}
					else {
						if (control_period < -30) ++control_period;
					}
				}
				else {
					LOG(Log <<"clock " << clock << " time_inc " << time_inc << endl);
					MaxTime = (clock-SAFETY_MARGIN) / 25;
					clock -= MaxTime;
					if (clock <= SAFETY_MARGIN) {
						if (time_inc > SAFETY_MARGIN) MaxTime += time_inc - SAFETY_MARGIN;
						else MaxTime += (time_inc >> 1);
					}
					else MaxTime += time_inc;
				}
			}
			LOG(Log<<"MaxTime "<<MaxTime<<endl);
			think(post);
			if (pv[0].empty()) {
				//				set_side(other_color(PlySide()));//??
				//				print_result();
				computer_side = NO_COLOR;
				continue;
			}
			printf("move %s\n", move_str(pv[0]));
			set_side(other_color(PlySide()));//??
			pv[0].make();
			History[history_len++] = pv[0];

//			print_result();
			log_board();
			continue;
		}
		if (!gets(line, 256))
			return;
		if (line[0] == '\n')
			continue;
		sscanf(line, "%s", command);
		LOG(Log << "recieved \"" << line << "\"\n");
		if (!strcmp(command, "xboard"))
			continue;
		if (!strcmp(command, "new")) {
			init_board();
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "quit"))
			return;
		if (!strcmp(command, "force")) {
			computer_side = NO_COLOR;
			continue;
		}
		if (!strcmp(command, "white")) {
			set_side(LIGHT);
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "black")) {
			set_side(DARK);
			computer_side = LIGHT;
			continue;
		}
		char extra[256];
		if (!strcmp(command, "level")) {
			int read=sscanf(line, "level %d %d:%d %d",&control_period,&time_base_min,&time_base_sec,&time_inc);
			control_period_original = control_period;
			LOG(Log << "read " << read << endl);
			if (read < 4) {
				LOG(Log << "no seconds\n");
				time_base_sec = 0;
				sscanf(line, "level %d %d %d", &control_period, &time_base_min, &time_inc);
			}
			LOG(Log<<"control_period "<< control_period<<" time_base_min "<< time_base_min<<"time_base_sec"<<time_base_sec<<" extra "<< extra<<" time_inc "<< time_inc<<endl);
			time_base = (time_base_min * 60 + time_base_sec)*1000;
			LOG(Log << " clock was " << clock << endl);
			clock = time_base;
			LOG(Log << " clock assumed to be " << clock << endl);
			//if (time_base != 0 && control_period_original == 0) control_period = -50;
			if (control_period != 0) {
				roll_over_check = true;
				roll_over_increment = time_base + time_inc;
			}
			time_inc *= 1000;
			exact_time = 0;
			continue;
		}
		if (!strcmp(command, "st")) {
			sscanf(line, "st %d", &exact_time);
			exact_time *= 1000;
			time_base = 0; time_inc = 0;control_period = 0;
			LOG(Log << " exact time set " << exact_time << endl);
			//MaxTime = MaxTime / 2;
#ifndef DISABLE_TIME
			MaxDepth = MAX_PLY;
#endif
			continue;
		}
		if (!strcmp(command, "sd")) {
			sscanf(line, "sd %d", &MaxDepth);
			MaxTime = 1 << 25;
			continue;
		}
		if (!strcmp(command, "time")) {
			int clock_temp;
			sscanf(line, "time %d", &clock_temp);
			clock_temp *= 10;
			if (roll_over_check) {
				if (fabs((double)(clock_temp - clock) / roll_over_increment - 1.0) < .1 && fabs((double)(clock_temp - clock) / roll_over_increment - 1.0)<fabs((double)(clock_temp - clock) / time_inc - 1.0)) {
					LOG(Log << "roll over assumed at "<<control_period<<endl);
					control_period = control_period_original;
				}
			}
			clock = clock_temp;
			LOG(Log<<" clock " << clock << endl);
			//MaxTime /= 30;
			//MaxTime = MaxTime / 2;
#ifndef DISABLE_TIME
//			MaxDepth = 32;
#endif
			continue;
		}
		if (!strcmp(command, "otim")) {
			continue;
		}
		if (!strcmp(command, "go")) {
			computer_side = PlySide();
			continue;
		}
		if (!strcmp(command, "hint")) {
			think(0);
			if (pv[0].empty())
				continue;
			printf("Hint: %s\n", move_str(pv[0]));
			continue;
		}
		if (!strcmp(command, "undo")) {
			if (history_len == 0)
				continue;
			computer_side = NO_COLOR;
			takeback();
			continue;
		}
		if (!strcmp(command, "remove")) {
			if (history_len >= 2)
				takeback();
			takeback();
			continue;
		}
		if (!strcmp(command, "post")) {
			post = 2;
			continue;
		}
		if (!strcmp(command, "nopost")) {
			post = 0;
			continue;
		}
		Move move;
		LOG(Log << "Parse move " << line << endl);
		//m = parse_move(move, line);
		if (!parse_move(move, line) || !make_move(move)) {
			printf("Error (unknown command): %s\n", command);
			LOG(Log << "Error (unknown command): " << command << endl);
		}
		else {
			History[history_len++] = move;

//			print_result();
			log_board();
		}
	}
}

void print_result()
{
	return;
	GenMoves(PlySide(),0,-20);
	while (!MovesOrdered.empty()) {
		MovesOrdered.back().make();
		if (king_in_check(PlySide())) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			MovesOrdered.pop();
			continue;
		}
		MovesOrdered.back().unmake();
		MovesOrdered.clear();
		return;
	}
	//no legal moves
	if (king_in_check(PlySide())) {
		if (PlySide() == LIGHT) {
			printf("0-1 {Black mates}\n");
			LOG(Log << "0-1 {Black mates}\n");
		}
		else {
			printf("1-0 {White mates}\n");
			LOG(Log << "1-0 {White mates}\n");
		}
	}
	else {
		printf("1/2-1/2 {Stalemate}\n");
		LOG(Log << "1/2-1/2 {Stalemate}\n");
	}
	//no test for repetitions or 50 move rule yet {}{}{}
}

void test_init();
char s[256];
char s2[30];
int mainish()
{
	int computer_side;
	int m;

	printf("\n");
	printf("Small Chess by Josh Scholar\n");
	printf("version 1.0,\n");
	printf("\n");
	printf("\"help\" displays a list of commands.\n");
	printf("\n");

	computer_side = NO_COLOR;
	MaxTime = 1 << 25;
	MaxDepth = 7;
	char * p = s;
	char *p2;
	*p = 0;
	for (;;) {
		if (PlySide() == computer_side) {  /* computer's turn */
			print_board();
			log_board();

//			board_consistent();						  /* think about the move and make it */
													  //			eval();
													  //			piece_threats();
			think(2);//1 for original format
			if (pv[0].empty()) {
				LOG(Log << "(no legal moves)\n");
				printf("(no legal moves)\n");
				computer_side = NO_COLOR;
				continue;
			}

			printf("Computer's move: %s\n", move_str(pv[0]));
			LOG(Log << "Computer's move: " << move_str(pv[0]) << (PlySide() == LIGHT ? " Light" : " Dark") << endl);
//			board_consistent();

			set_side(other_color(PlySide()));//??
			pv[0].make();
			History[history_len++] = pv[0];

			print_result();
			continue;
		}

		/* get user input */
		printf("> ");
		while (whitespace(*p))++p;
		if (*p == 0) {
			gets(s, 256);
			p = s;
			while (whitespace(*p))++p;
		}
		s2[0] = 0;
		p2 = s2;
		while (!whitespace(*p) && *p != 0)*p2++ = *p++;
		*p2 = 0;
		// return 0;
		if (!strcmp(s2, "on")) {
			computer_side = PlySide();
			continue;
		}
		if (!strcmp(s2, "off")) {
			computer_side = NO_COLOR;
			continue;
		}
		if (!strcmp(s2, "st")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &MaxTime);
			MaxTime *= 1000;
#ifndef DISABLE_TIME
			MaxDepth = MAX_PLY;
#endif
			continue;
		}
		if (!strcmp(s2, "sd")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &MaxDepth);
			MaxTime = 1 << 25;
			continue;
		}
		if (!strcmp(s2, "undo")) {
			if (history_len == 0)
				continue;
			computer_side = NO_COLOR;
			takeback();
			continue;
		}
		if (!strcmp(s2, "new")) {
			computer_side = NO_COLOR;
			init_board();
			continue;
		}
		if (!strcmp(s2, "test")) {
			test_init();
			continue;
		}
		if (!strcmp(s2, "perft")) {
//			test_init();
			int depth;
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &depth);
			cout << "perft "<<depth<<" =" << perft(depth) << endl;
			cout << "Checks = " << Checks << " Captures = " << CapturesC << " Checkmates = " << Checkmates <<" en passant = "<< Enpassants <<" Castles = "<< Castles <<endl;
			continue;
		}
		if (!strcmp(s2, "d")) {
			print_board();
			continue;
		}
		if (!strcmp(s2, "bye")) {
			printf("Share and enjoy!\n");
			break;
		}
		if (!strcmp(s2, "xboard")) {
			MaxDepth = MAX_PLY;
			xboard();
			break;
		}
		if (!strcmp(s2, "help")) {
			printf("on - computer plays for the side to move\n");
			printf("off - computer stops playing\n");
			printf("st n - search for n seconds per move\n");
			printf("sd n - search n ply per move\n");
			printf("undo - takes back a move\n");
			printf("new - starts a new game\n");
			printf("d - display the board\n");
			printf("bye - exit the program\n");
			printf("Enter moves in coordinate notation, e.g., e2e4, e7e8Q\n");
			continue;
		}

		/* maybe the user entered a move? */
		Move move;
		m = parse_move(move, s2);
		if (!parse_move(move, s2) || !make_move(move))
			printf("Illegal move.\n");
		else {
			LOG(Log << "User move " << s2 << endl);
			log_board();
			History[history_len++] = move;

			print_result();
		}
	}
	//	close_book();
	return 0;
}

struct BadFen
{};

void init_fen()
{
	init_board();
	for (int i = a1;i <= h1;++i) {
		if (Board[i] != OFF_BOARD) {
			if (Board[i] != NO_SLOT) {
				sub_value(LIGHT, Board[i]);
				Board[i] = NO_SLOT;
			}
		}
	}
	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Players.pieces[i] = EMPTY;
}

PieceSlotType next_pawn(Colors c)
{
	int base = base_by_color(c);
	for (int i = PAWN1;i <= PAWN8;++i) {
		if (Players.pieces[i + base] == EMPTY) return (PieceSlotType)(i + base);
	}
	throw(BadFen());
}
bool find_fen_piece(PieceSlotType &p, int slot, PieceType t)
{
	if (Players.pieces[slot] == EMPTY) {
		Players.pieces[slot] = t;
		p = (PieceSlotType)slot;
		return true;
	}
	return false;
}
PieceSlotType next_fen_piece(char f)
{
	PieceSlotType p;
	Colors c = isupper(f) ? LIGHT : DARK;
	int base = base_by_color(c);
	switch (toupper(f))
	{
	case 'P':
		p = next_pawn(c);
		Players.pieces[p] = PAWN;
		return p;
	case 'R':
		find_fen_piece(p, ROOK1 + base, ROOK)|| find_fen_piece(p, ROOK2 + base, ROOK)|| find_fen_piece(p, next_pawn(c), ROOK);
		return p;
	case 'N':
		find_fen_piece(p, KNIGHT1 + base, KNIGHT) || find_fen_piece(p, KNIGHT2 + base, KNIGHT) || find_fen_piece(p, next_pawn(c), KNIGHT);
		return p;
	case 'B':
		find_fen_piece(p, BISHOP1 + base, BISHOP) || find_fen_piece(p, BISHOP2 + base, BISHOP) || find_fen_piece(p, next_pawn(c), BISHOP);
		return p;
	case 'Q':
		find_fen_piece(p, QUEENP + base, QUEEN) || find_fen_piece(p, next_pawn(c), QUEEN);
		return p;
	case 'K':
		find_fen_piece(p, KINGP + base, KING);
		return p;
	}
}

Pos next_fen_pos(Pos p)
{
	while (Board[++p] == OFF_BOARD);
	return p;
}
void scan_fen(char *fen)
{
	init_fen();
	Pos p = a8;
	while(true) {
		while (Board[p] == OFF_BOARD) ++p;
		switch (*fen) {
		case '1': case '2':case '3':case '4':case '5':case '6':case '7':case '8':
			p += *fen - '0';
			break;
		case'/':
			break;
		default:
			{
				PieceSlotType s = next_fen_piece(*fen);
				Board[p] = s;
				Players.positions[s] = p;
				add_value(LIGHT, s);
				p = next_fen_pos(p);
			}
		}
		++fen;
		if (p == h1+1) break;
	}
	++fen;
	if (*fen == 'b') set_side(DARK);
	fen += 2;
	while(true){
		switch (*fen) {
		case 'K':
			Players.pieces[DARK_ROOK2] = ROOK_NOT_MOVED;
			Players.pieces[DARK_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'Q':
			Players.pieces[DARK_ROOK1] = ROOK_NOT_MOVED;
			Players.pieces[DARK_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'k':
			Players.pieces[LIGHT_ROOK2] = ROOK_NOT_MOVED;
			Players.pieces[LIGHT_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'q':
			Players.pieces[LIGHT_ROOK1] = ROOK_NOT_MOVED;
			Players.pieces[LIGHT_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case '-':
			++fen;
		}
		break;
	}
	++fen;
	if (*fen != '-') {
		p = fen[0] - 'a' + 1 + 10 * (10 - (fen[1] - '0'));
		Players.pieces[Board[p]] = PAWN_JUST_ADVANCED;
		En_passant_history[MoveNumber + history_len] = p;
	}else En_passant_history[MoveNumber + history_len] = 0;
}
/*
8  . . . . . . . K
7  r B . . k . P .
6  P . . . . . . .
5  . . . . . . . P
4  . . . . P . . .
3  . . . . . . . .
2  . . p . . . . .
1  . . . . . . . .
a b c d e f g h
*/
int board_init[BOARD_SIZE]
{
	33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,15,33,33,28,11,32,32,31,32,5,32,33,33,0,32,32,32,32,32,32,32,33,33,32,32,32,32,32,32,32,7,33,33,32,32,32,32,4,32,32,32,33,33,32,32,32,32,32,32,32,32,33,33,32,32,18,32,32,32,32,32,33,33,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
};
int players_init[NUM_PIECE_SLOTS]
{
	4,0,0,0,4,4,0,4,0,0,0,7,0,0,0,2,0,0,4,0,0,0,0,0,0,0,0,0,9,0,0,3,
};
void test_init()
{
	init_board();
	scan_fen("4k3/8/8/8/8/8/8/R3K3 w - - 0 1");
//	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Players.pieces[i] = (PieceType)players_init[i];
//	for (int i = 0;i < BOARD_SIZE;++i) {
//		Board[i] = (PieceSlotType)board_init[i];
//		if (Board[i] != NO_SLOT) Players.positions[Board[i]] = (Pos)i;
//	}
//	set_side(LIGHT);
	endgame_check();
	DisableBook = true;
	FakeLen = 51;
}

int main()
{
	init_direction_tables();
	init_log();
	init_zobrist();
	init_hash();
	init_board();
	mainish();
	close_log();
    return 0;
}

