// jacksprat.cpp : Defines the entry point for the console application.
//
#include <utility>
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <math.h>
#include <string.h>

#ifdef __GNUC__
#define __min(x,y) ((x)<(y)?(x):(y))
#define __max(x,y) ((x)>=(y)?(x):(y))
#endif


#define KING_VALUE 25000
/*
#define PAWN_VALUE 100
#define KNIGHT_VALUE 320
#define BISHOP_VALUE 330
#define ROOK_VALUE 500
#define QUEEN_VALUE 900
#define KING_CASTLING_BONUS 15
*/

//#define PAWN_VALUE 100
//#define KNIGHT_VALUE 420
//#define BISHOP_VALUE 428
//#define ROOK_VALUE 643
//#define QUEEN_VALUE 1283

/*<mkchan> sf values are doubled the usual values cuz it's greater flexibility for tuning
<mkchan> PawnValueMg   = 198,   PawnValueEg   = 258,
<mkchan>     KnightValueMg = 817,   KnightValueEg = 846,
<mkchan>     BishopValueMg = 836,   BishopValueEg = 857,
<mkchan>     RookValueMg   = 1270,  RookValueEg   = 1278,
<mkchan>     QueenValueMg  = 2521,  QueenValueEg  = 2558,
sf 6
<mkchan>   PawnValueMg   = 188,   PawnValueEg   = 248,
<mkchan>   KnightValueMg = 753,   KnightValueEg = 832,
<mkchan>   BishopValueMg = 826,   BishopValueEg = 897,
<mkchan>   RookValueMg   = 1285,  RookValueEg   = 1371,
<mkchan>   QueenValueMg  = 2513,  QueenValueEg  = 2650,
*/
//zirconiumx
//(75, 110), (485, 350), (507, 350), (634, 639), (1185, 1275)
#define PAWN_VALUE (int)(188/1.88)
#define KNIGHT_VALUE (int)(753/1.88)
#define BISHOP_VALUE (int)(826/1.88)
#define ROOK_VALUE (int)(1285/1.88)
#define QUEEN_VALUE (int)(2513/1.88)

#define EPAWN_VALUE (int)(248/1.88)
#define EKNIGHT_VALUE (int)(832/1.88)
#define EBISHOP_VALUE (int)(897/1.88)
#define EROOK_VALUE (int)(1371/1.88)
#define EQUEEN_VALUE (int)(2650/1.88)


#define KING_CASTLING_BONUS 15


#define LOGGING
#define INF (1<<28)
#define SHORTINF (1<<14)

#define UP -10
#define DOWN 10
#define LEFT -1
#define RIGHT 1

#define MAX_PLY 64
//approximate max branching factor
#define MAX_MOVES_PER_PLY 128

//no more than 400 moves per game
#define MAX_MOVES 400


#define REPRODUCABLE_HASH
#define REPLACE_BY_DEPTH
//for debugging
//#define DISABLE_TIME

#define HASH_TABLE
bool DisableBook = false;
int FakeLen = 0;
const int BOARD_SIZE = 120;
bool CheckForEndgame;
int MoveNumber = 0;

#ifdef NDEBUG
#define PARAMLINE 
#define DEFLINE
#define INITLINE
#define ATLINE 
#define COPYLINE 
#define SETLINE 
#else

#define PARAMLINE ,int _line
#define DEFLINE int line;
#define INITLINE ,line(_line)
#define ATLINE ,__LINE__
#define COPYLINE ,line(m.line)
#define SETLINE line=m.line;
#endif

enum Colors { LIGHT, DARK, NUM_COLORS = 2, NO_COLOR = 2 };

inline Colors other_color(Colors n)
{
	return (Colors)(1 - (int)n);
}

Colors computer_side;

enum PieceType : signed char {
	EMPTY = 0,
	KING_NOT_MOVED = 1,
	KING = 2,
	KING_CASTLED = 3,
	PAWN = 4,
	PAWN_JUST_ADVANCED = 5,
	KNIGHT = 6,
	BISHOP = 7,
	ROOK_NOT_MOVED = 8,
	ROOK = 9,
	QUEEN = 10,
	NUM_PIECE_TYPES = 11,
};


inline bool is_rook(PieceType p)
{
	return p == ROOK || p == ROOK_NOT_MOVED;
}
inline bool is_sliding_type(PieceType p)
{
	return p >= BISHOP;
}

inline bool is_king(PieceType p)
{
	return p > EMPTY && p <= KING_CASTLED;
}

inline bool is_pawn(PieceType p)
{
	return p == PAWN || p == PAWN_JUST_ADVANCED;
}


inline bool is_piece(PieceType p)
{
	return p != EMPTY;
}



enum PieceSlotType : signed char {
	LIGHT_SLOT = 0,
	PAWN1 = 0,
	LIGHT_PAWN1 = 0,
	PAWN2 = 1,
	LIGHT_PAWN2 = 1,
	PAWN3 = 2,
	LIGHT_PAWN3 = 2,
	PAWN4 = 3,
	LIGHT_PAWN4 = 3,
	PAWN5 = 4,
	LIGHT_PAWN5 = 4,
	PAWN6 = 5,
	LIGHT_PAWN6 = 5,
	PAWN7 = 6,
	LIGHT_PAWN7 = 6,
	PAWN8 = 7,
	LIGHT_PAWN8 = 7,
	KNIGHT1 = 8,
	LIGHT_KNIGHT1 = 8,
	KNIGHT2 = 9,
	LIGHT_KNIGHT2 = 9,
	BISHOP1 = 10,
	LIGHT_BISHOP1 = 10,
	BISHOP2 = 11,
	LIGHT_BISHOP2 = 11,
	ROOK1 = 12,
	LIGHT_ROOK1 = 12,
	ROOK2 = 13,
	LIGHT_ROOK2 = 13,
	QUEENP = 14,
	LIGHT_QUEENP = 14,
	KINGP = 15,
	LIGHT_KINGP = 15,
	UNCOLORED_SLOT_MASK = 15,
	NUM_UNCOLORED_PIECE_SLOTS = 16,
	DARK_SLOT = 16,
	DARK_PAWN1 = 16,
	DARK_PAWN2 = 17,
	DARK_PAWN3 = 18,
	DARK_PAWN4 = 19,
	DARK_PAWN5 = 20,
	DARK_PAWN6 = 21,
	DARK_PAWN7 = 22,
	DARK_PAWN8 = 23,
	DARK_KNIGHT1 = 24,
	DARK_KNIGHT2 = 25,
	DARK_BISHOP1 = 26,
	DARK_BISHOP2 = 27,
	DARK_ROOK1 = 28,
	DARK_ROOK2 = 29,
	DARK_QUEENP = 30,
	DARK_KINGP = 31,
	NO_SLOT = 32,
	OFF_BOARD = 33,
	NUM_PIECE_SLOTS = 32,
};

inline bool is_piece(PieceSlotType p)
{
	return p != NO_SLOT && p != OFF_BOARD;
}


typedef PieceSlotType BoardArray[BOARD_SIZE];
BoardArray Board;

inline Colors color(PieceSlotType p)
{
	if ((p & 16) != 0) return DARK;
	return LIGHT;
}

inline PieceSlotType as_light(PieceSlotType p)
{
	return (PieceSlotType)(p & 15);
}

inline PieceSlotType as_dark(PieceSlotType p)
{
	return (PieceSlotType)(p | 16);
}

inline PieceSlotType base_by_color(Colors c)
{
	if (c == LIGHT) return LIGHT_SLOT;
	return DARK_SLOT;
}

typedef signed char Pos;


Pos En_passant_history[MAX_MOVES + MAX_PLY];
Colors En_passant_colors_history[MAX_MOVES + MAX_PLY];
typedef Pos PlayersPositions[NUM_PIECE_SLOTS + 2];
typedef int PlayersEnpassant[NUM_PIECE_SLOTS + 2];
typedef PieceType PlayersPieces[NUM_PIECE_SLOTS + 2];//The +2 is so that NO_SLOT and OFF_BOARD can map to EMPTY
enum PinTypes { NotPinned, PartiallyPinned, Pinned };
struct PlayersType {
	PlayersPieces pieces;
	PlayersPositions positions;
	PinTypes pinned[NUM_PIECE_SLOTS + 2];
};

#define a1 91
#define b1 92
#define c1 93
#define d1 94
#define e1 95
#define f1 96
#define g1 97
#define h1 98
#define a2 81
#define b2 82
#define c2 83
#define d2 84
#define e2 85
#define f2 86
#define g2 87
#define h2 88
#define a3 71
#define b3 72
#define c3 73
#define d3 74
#define e3 75
#define f3 76
#define g3 77
#define h3 78
#define a4 61
#define b4 62
#define c4 63
#define d4 64
#define e4 65
#define f4 66
#define g4 67
#define h4 68
#define a5 51
#define b5 52
#define c5 53
#define d5 54
#define e5 55
#define f5 56
#define g5 57
#define h5 58
#define a6 41
#define b6 42
#define c6 43
#define d6 44
#define e6 45
#define f6 46
#define g6 47
#define h6 48
#define a7 31
#define b7 32
#define c7 33
#define d7 34
#define e7 35
#define f7 36
#define g7 37
#define h7 38
#define a8 21
#define b8 22
#define c8 23
#define d8 24
#define e8 25
#define f8 26
#define g8 27
#define h8 28

const int ValuePerPiece[NUM_PIECE_TYPES] = {
	0,
	KING_VALUE,
	KING_VALUE,
	KING_VALUE + KING_CASTLING_BONUS,
	PAWN_VALUE,
	PAWN_VALUE,
	KNIGHT_VALUE,
	BISHOP_VALUE,
	ROOK_VALUE,
	ROOK_VALUE,
	QUEEN_VALUE,
};

const int EValuePerPiece[NUM_PIECE_TYPES] = {
	0,
	KING_VALUE,
	KING_VALUE,
	KING_VALUE + KING_CASTLING_BONUS,
	EPAWN_VALUE,
	EPAWN_VALUE,
	EKNIGHT_VALUE,
	EBISHOP_VALUE,
	EROOK_VALUE,
	EROOK_VALUE,
	EQUEEN_VALUE,
};


const char PieceCharL[] = ".KKKPPNBRRQ";
const char PieceCharD[] = ".kkkppnbrrq";
const char PieceChar2[] = ".1 c a  1  ";
const char piece_char(Colors c, PieceType p)
{
	if (c == LIGHT) return PieceCharL[p];
	return PieceCharD[p];
}
const char piece_char2(PieceType p)
{
	return PieceChar2[p];
}

const PieceType ChangePieceOnMove[] =
{
	EMPTY,
	KING,
	KING,
	KING_CASTLED,
	PAWN,
	PAWN,
	KNIGHT,
	BISHOP,
	ROOK,
	ROOK,
	QUEEN,
};

//

enum MaterialIndexes { DONT_COUNT = 0, PAWN_COUNT = 1, MAJOR_MINOR_COUNT = 2, NUM_MATERIAL_INDEXES = 3 };

const MaterialIndexes PieceCountIndex[] =
{
	DONT_COUNT,
	DONT_COUNT,
	DONT_COUNT,
	DONT_COUNT,
	PAWN_COUNT,
	PAWN_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
	MAJOR_MINOR_COUNT,
};

int MaterialSums[NUM_COLORS][NUM_MATERIAL_INDEXES];

const Pos enpassant_table[BOARD_SIZE] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	// 8
	0,0,0,0,0,0,0,0,0,0,
	// 7
	0,0,0,0,0,0,0,0,0,0,
	// 6
	0,a5,b5,c5,d5,e5,f5,g5,h5,0,
	// 5
	0,0,0,0,0,0,0,0,0,0,
	// 4
	0,0,0,0,0,0,0,0,0,0,
	// 3
	0,a4,b4,c4,d4,e4,f4,g4,h4,0,
	// 2
	0,0,0,0,0,0,0,0,0,0,
	// 1
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};


const char * const PosToStandard[] = {
	"Off 0","Off 1","Off 2","Off 3","Off 4","Off 5","Off 6","Off 7","Off 8","Off 9",
	"Off 10","Off 11","Off 12","Off 13","Off 14","Off 15","Off 16","Off 17","Off 18","Off 19",
	"Off 20","a8","b8","c8","d8","e8","f8","g8","h8","Off29",
	"Off 30","a7","b7","c7","d7","e7","f7","g7","h7","Off39",
	"Off 40","a6","b6","c6","d6","e6","f6","g6","h6","Off49",
	"Off 50","a5","b5","c5","d5","e5","f5","g5","h5","Off59",
	"Off 60","a4","b4","c4","d4","e4","f4","g4","h4","Off69",
	"Off 70","a3","b3","c3","d3","e3","f3","g3","h3","Off79",
	"Off 80","a2","b2","c2","d2","e2","f2","g2","h2","Off89",
	"Off 90","a1","b1","c1","d1","e1","f1","g1","h1","Off99",
	"Off 100","Off 101","Off 102","Off 103","Off 104","Off 105","Off 106","Off 107","Off 108","Off 109",
	"Off 110","Off 111","Off 112","Off 113","Off 114","Off 115","Off 116","Off 117","Off 118","Off 119",
};


#ifdef LOGGING
using namespace std;
ofstream Log;
void init_log()
{
	Log.open("chess.txt");
}
void close_log()
{
	Log.close();
}
#define LOG(x) x
#else
#define LOG(X)
void init_log()
{
}
void close_log()
{
}

#endif

#include <limits>

#define DINF (std::numeric_limits<double>::infinity())
//bool EvalDirty;
double PawnsValue;
double PawnsPartValue;

int EvalDirtyValue = 0;
int EvalDirtyNegate = 1;
double EvalDirtyCache[MAX_MOVES + MAX_MOVES_PER_PLY] = { DINF };

bool EvalDirtySimple;

inline bool EvalDirty()
{
	//return EvalDirtySimple;//
	return EvalDirtyCache[EvalDirtyValue] == DINF;
}
void incEvalDirty()
{
	//EvalDirtySimple = true;//
	EvalDirtyCache[++EvalDirtyValue] = DINF;
}
void decEvalDirty()
{
	//EvalDirtySimple = true;
	--EvalDirtyValue;
	if (!EvalDirty()) PawnsValue = EvalDirtyCache[EvalDirtyValue]* EvalDirtyNegate;
}
void clearEvalDirty()
{
//	EvalDirtySimple = false;
	EvalDirtyCache[EvalDirtyValue] = PawnsValue*EvalDirtyNegate;
}
void resetEvalDirty()
{
//	EvalDirtySimple = true;
	EvalDirtyValue = 0;
	EvalDirtyCache[0] = DINF;
}


bool PawnsDirtyValue = true;
//int PawnsDirtyTop = 0;

double PawnsDirtyCache[MAX_MOVES + MAX_MOVES_PER_PLY ] = { DINF };

inline bool PawnsDirty() 
{
	return PawnsDirtyValue;//PawnsDirtyCache[PawnsDirtyValue] == DINF;
}
void incPawnsDirty()
{
	PawnsDirtyValue=true;
}
void decPawnsDirty()
{
	PawnsDirtyValue = true;
}
void clearPawnsDirty()
{
	PawnsDirtyValue = false;
}
void resetPawnsDirty()
{
	PawnsDirtyValue = true;
}


const PieceType Initial_Pieces[] = {
	PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,PAWN,
	KNIGHT,KNIGHT,BISHOP,BISHOP, ROOK_NOT_MOVED ,ROOK_NOT_MOVED, QUEEN,KING_NOT_MOVED,
	PAWN,PAWN,PAWN,PAWN,PAWN,PAWN ,PAWN,PAWN,
	KNIGHT, KNIGHT,BISHOP,BISHOP, ROOK_NOT_MOVED,ROOK_NOT_MOVED, QUEEN,KING_NOT_MOVED,
	EMPTY
};

const PlayersPositions Initial_Pos =
{
	a2,b2,c2,d2,e2,f2,g2,h2,
	b1,g1,c1,f1,a1,h1,d1,e1,
	a7,b7,c7,d7,e7,f7,g7,h7,
	b8,g8,c8,f8,a8,h8,d8,e8
};

typedef int PieceSquareTable[BOARD_SIZE];
const PieceSquareTable EmptySquareTable =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

#define SCALE_PST *2/5
#define PAWN_SCALE *2/5
#define END_PAWN_SCALE *2/5 
#define HAIR_TABLES 
//#define HAIR_PAWNS

#ifdef HAIR_TABLES
const PieceSquareTable KingEndSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,42 SCALE_PST, 46 SCALE_PST, 48 SCALE_PST, 50 SCALE_PST, 50 SCALE_PST, 48 SCALE_PST, 46 SCALE_PST, 42 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,38 SCALE_PST, 41 SCALE_PST, 44 SCALE_PST, 45 SCALE_PST, 45 SCALE_PST, 44 SCALE_PST, 41 SCALE_PST, 38 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,31 SCALE_PST, 34 SCALE_PST, 37 SCALE_PST, 38 SCALE_PST, 38 SCALE_PST, 37 SCALE_PST, 34 SCALE_PST, 31 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,22 SCALE_PST, 26 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 26 SCALE_PST, 22 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,11 SCALE_PST, 15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST, 11 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 2 SCALE_PST, 4 SCALE_PST, 5 SCALE_PST, 5 SCALE_PST, 4 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,-17 SCALE_PST, -13 SCALE_PST, -11 SCALE_PST, -10 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, -13 SCALE_PST, -17 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-34 SCALE_PST, -30 SCALE_PST, -28 SCALE_PST, -27 SCALE_PST, -27 SCALE_PST, -28 SCALE_PST, -30 SCALE_PST, -34 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingEndSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-34 SCALE_PST, -30 SCALE_PST, -28 SCALE_PST, -27 SCALE_PST, -27 SCALE_PST, -28 SCALE_PST, -30 SCALE_PST, -34 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-17 SCALE_PST, -13 SCALE_PST, -11 SCALE_PST, -10 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, -13 SCALE_PST, -17 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 2 SCALE_PST, 4 SCALE_PST, 5 SCALE_PST, 5 SCALE_PST, 4 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,11 SCALE_PST, 15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST, 11 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,22 SCALE_PST, 26 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 26 SCALE_PST, 22 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,31 SCALE_PST, 34 SCALE_PST, 37 SCALE_PST, 38 SCALE_PST, 38 SCALE_PST, 37 SCALE_PST, 34 SCALE_PST, 31 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,38 SCALE_PST, 41 SCALE_PST, 44 SCALE_PST, 45 SCALE_PST, 45 SCALE_PST, 44 SCALE_PST, 41 SCALE_PST, 38 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,42 SCALE_PST, 46 SCALE_PST, 48 SCALE_PST, 50 SCALE_PST, 50 SCALE_PST, 48 SCALE_PST, 46 SCALE_PST, 42 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingMidSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 25 SCALE_PST, 0 SCALE_PST,      0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KingMidSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST, -9 SCALE_PST, 25 SCALE_PST, 0 SCALE_PST,      0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameQueenSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,	12 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 12 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	21 SCALE_PST, 26 SCALE_PST, 30 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 30 SCALE_PST, 26 SCALE_PST, 21 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	23 SCALE_PST, 28 SCALE_PST, 32 SCALE_PST, 34 SCALE_PST, 34 SCALE_PST, 32 SCALE_PST, 28 SCALE_PST, 23 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	19 SCALE_PST, 24 SCALE_PST, 28 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 28 SCALE_PST, 24 SCALE_PST, 19 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	  9 SCALE_PST, 14 SCALE_PST, 17 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 17 SCALE_PST, 14 SCALE_PST, 9 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	-8 SCALE_PST, -3 SCALE_PST, 1 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, -3 SCALE_PST, -8 SCALE_PST,			   0 SCALE_PST,
	0 SCALE_PST,	-31 SCALE_PST, -26 SCALE_PST, -22 SCALE_PST, -21 SCALE_PST, -21 SCALE_PST, -22 SCALE_PST, -26 SCALE_PST, -31 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-61 SCALE_PST, -55 SCALE_PST, -52 SCALE_PST, -50 SCALE_PST, -50 SCALE_PST, -52 SCALE_PST, -55 SCALE_PST, -61 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};
const PieceSquareTable EndgameQueenSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,	-61 SCALE_PST, -55 SCALE_PST, -52 SCALE_PST, -50 SCALE_PST, -50 SCALE_PST, -52 SCALE_PST, -55 SCALE_PST, -61 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-31 SCALE_PST, -26 SCALE_PST, -22 SCALE_PST, -21 SCALE_PST, -21 SCALE_PST, -22 SCALE_PST, -26 SCALE_PST, -31 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,	-8 SCALE_PST, -3 SCALE_PST, 1 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, -3 SCALE_PST, -8 SCALE_PST,			   0 SCALE_PST,
	0 SCALE_PST,	  9 SCALE_PST, 14 SCALE_PST, 17 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 17 SCALE_PST, 14 SCALE_PST, 9 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	19 SCALE_PST, 24 SCALE_PST, 28 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 28 SCALE_PST, 24 SCALE_PST, 19 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	23 SCALE_PST, 28 SCALE_PST, 32 SCALE_PST, 34 SCALE_PST, 34 SCALE_PST, 32 SCALE_PST, 28 SCALE_PST, 23 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	21 SCALE_PST, 26 SCALE_PST, 30 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 30 SCALE_PST, 26 SCALE_PST, 21 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST,	12 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 12 SCALE_PST,		   0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable QueenSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, 3 SCALE_PST, -15 SCALE_PST, -51 SCALE_PST, -83 SCALE_PST, -13 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-7 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 5 SCALE_PST, -1 SCALE_PST, -10 SCALE_PST, -7 SCALE_PST, -2 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-11 SCALE_PST, 0 SCALE_PST, 12 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 11 SCALE_PST, 7 SCALE_PST, -6 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, 5 SCALE_PST, 7 SCALE_PST, 9 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 26 SCALE_PST, 4 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-6 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST, 25 SCALE_PST, 32 SCALE_PST, 9 SCALE_PST, 26 SCALE_PST, 12 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 10 SCALE_PST, 13 SCALE_PST, 25 SCALE_PST, 37 SCALE_PST, 30 SCALE_PST, 15 SCALE_PST, 26 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 11 SCALE_PST, 35 SCALE_PST, 0 SCALE_PST, 16 SCALE_PST, 55 SCALE_PST, 39 SCALE_PST, 57 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-13 SCALE_PST, 6 SCALE_PST, -42 SCALE_PST, 0 SCALE_PST, 29 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 102 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable QueenSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, -10 SCALE_PST, -11 SCALE_PST, 3 SCALE_PST, -15 SCALE_PST, -51 SCALE_PST, -83 SCALE_PST, -13 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-7 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 5 SCALE_PST, -1 SCALE_PST, -10 SCALE_PST, -7 SCALE_PST, -2 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-11 SCALE_PST, 0 SCALE_PST, 12 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 11 SCALE_PST, 7 SCALE_PST, -6 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, 5 SCALE_PST, 7 SCALE_PST, 9 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 26 SCALE_PST, 4 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-6 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST, 25 SCALE_PST, 32 SCALE_PST, 9 SCALE_PST, 26 SCALE_PST, 12 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 10 SCALE_PST, 13 SCALE_PST, 25 SCALE_PST, 37 SCALE_PST, 30 SCALE_PST, 15 SCALE_PST, 26 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 11 SCALE_PST, 35 SCALE_PST, 0 SCALE_PST, 16 SCALE_PST, 55 SCALE_PST, 39 SCALE_PST, 57 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,-13 SCALE_PST, 6 SCALE_PST, -42 SCALE_PST, 0 SCALE_PST, 29 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 102 SCALE_PST,	 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameRookSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,16 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 16 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,27 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,25 SCALE_PST, 27 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST, 25 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST, 4 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,-15 SCALE_PST, -13 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -13 SCALE_PST, -15 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-27 SCALE_PST, -25 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -25 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-32 SCALE_PST, -31 SCALE_PST, -30 SCALE_PST, -29 SCALE_PST, -29 SCALE_PST, -30 SCALE_PST, -31 SCALE_PST, -32 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameRookSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-32 SCALE_PST, -31 SCALE_PST, -30 SCALE_PST, -29 SCALE_PST, -29 SCALE_PST, -30 SCALE_PST, -31 SCALE_PST, -32 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-27 SCALE_PST, -25 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -24 SCALE_PST, -25 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,-15 SCALE_PST, -13 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -12 SCALE_PST, -13 SCALE_PST, -15 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,1 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST, 4 SCALE_PST, 3 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST,				 0 SCALE_PST,
	0 SCALE_PST,15 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 15 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,25 SCALE_PST, 27 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST, 25 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,27 SCALE_PST, 28 SCALE_PST, 29 SCALE_PST, 30 SCALE_PST, 30 SCALE_PST, 29 SCALE_PST, 28 SCALE_PST, 27 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST,16 SCALE_PST, 17 SCALE_PST, 18 SCALE_PST, 19 SCALE_PST, 19 SCALE_PST, 18 SCALE_PST, 17 SCALE_PST, 16 SCALE_PST,		 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable RookSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,84 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 37 SCALE_PST, 124 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 153 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,46 SCALE_PST, 33 SCALE_PST, 64 SCALE_PST, 62 SCALE_PST, 91 SCALE_PST, 89 SCALE_PST, 70 SCALE_PST, 104 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,24 SCALE_PST, 83 SCALE_PST, 54 SCALE_PST, 75 SCALE_PST, 134 SCALE_PST, 144 SCALE_PST, 85 SCALE_PST, 75 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,19 SCALE_PST, 33 SCALE_PST, 46 SCALE_PST, 57 SCALE_PST, 53 SCALE_PST, 39 SCALE_PST, 53 SCALE_PST, 16 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -5 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, -17 SCALE_PST, 13 SCALE_PST, -13 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 0 SCALE_PST, 3 SCALE_PST, -3 SCALE_PST, 8 SCALE_PST, -1 SCALE_PST, 12 SCALE_PST, 3 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,-26 SCALE_PST, -6 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST, 2 SCALE_PST, -10 SCALE_PST, -1 SCALE_PST, -29 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST, 4 SCALE_PST, -8 SCALE_PST,       0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable RookSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 1 SCALE_PST, 4 SCALE_PST, -8 SCALE_PST,       0 SCALE_PST,
	0 SCALE_PST,-26 SCALE_PST, -6 SCALE_PST, 2 SCALE_PST, -2 SCALE_PST, 2 SCALE_PST, -10 SCALE_PST, -1 SCALE_PST, -29 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-16 SCALE_PST, 0 SCALE_PST, 3 SCALE_PST, -3 SCALE_PST, 8 SCALE_PST, -1 SCALE_PST, 12 SCALE_PST, 3 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST,-9 SCALE_PST, -5 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, -17 SCALE_PST, 13 SCALE_PST, -13 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,19 SCALE_PST, 33 SCALE_PST, 46 SCALE_PST, 57 SCALE_PST, 53 SCALE_PST, 39 SCALE_PST, 53 SCALE_PST, 16 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST,24 SCALE_PST, 83 SCALE_PST, 54 SCALE_PST, 75 SCALE_PST, 134 SCALE_PST, 144 SCALE_PST, 85 SCALE_PST, 75 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST,46 SCALE_PST, 33 SCALE_PST, 64 SCALE_PST, 62 SCALE_PST, 91 SCALE_PST, 89 SCALE_PST, 70 SCALE_PST, 104 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,84 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 37 SCALE_PST, 124 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 153 SCALE_PST,	   0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameBishopSquareTableL = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 4 SCALE_PST, 8 SCALE_PST, 10 SCALE_PST, 10 SCALE_PST, 8 SCALE_PST, 4 SCALE_PST, -2 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, 20 SCALE_PST, 20 SCALE_PST, 18 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 13 SCALE_PST, 19 SCALE_PST, 23 SCALE_PST, 25 SCALE_PST, 25 SCALE_PST, 23 SCALE_PST, 19 SCALE_PST, 13 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 14 SCALE_PST, 20 SCALE_PST, 24 SCALE_PST, 26 SCALE_PST, 26 SCALE_PST, 24 SCALE_PST, 20 SCALE_PST, 14 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 11 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 11 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 14 SCALE_PST, 12 SCALE_PST, 8 SCALE_PST, 2 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, -10 SCALE_PST, -4 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, -4 SCALE_PST, -10 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -27 SCALE_PST, -21 SCALE_PST, -17 SCALE_PST, -15 SCALE_PST, -15 SCALE_PST, -17 SCALE_PST, -21 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameBishopSquareTableD = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -27 SCALE_PST, -21 SCALE_PST, -17 SCALE_PST, -15 SCALE_PST, -15 SCALE_PST, -17 SCALE_PST, -21 SCALE_PST, -27 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, -10 SCALE_PST, -4 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, -4 SCALE_PST, -10 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 2 SCALE_PST, 8 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 14 SCALE_PST, 12 SCALE_PST, 8 SCALE_PST, 2 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, 11 SCALE_PST, 17 SCALE_PST, 21 SCALE_PST, 23 SCALE_PST, 23 SCALE_PST, 21 SCALE_PST, 17 SCALE_PST, 11 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 14 SCALE_PST, 20 SCALE_PST, 24 SCALE_PST, 26 SCALE_PST, 26 SCALE_PST, 24 SCALE_PST, 20 SCALE_PST, 14 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 13 SCALE_PST, 19 SCALE_PST, 23 SCALE_PST, 25 SCALE_PST, 25 SCALE_PST, 23 SCALE_PST, 19 SCALE_PST, 13 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 8 SCALE_PST, 14 SCALE_PST, 18 SCALE_PST, 20 SCALE_PST, 20 SCALE_PST, 18 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST,-2 SCALE_PST, 4 SCALE_PST, 8 SCALE_PST, 10 SCALE_PST, 10 SCALE_PST, 8 SCALE_PST, 4 SCALE_PST, -2 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable BishopSquareTableL = {

	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, -24 SCALE_PST, -23 SCALE_PST, 30 SCALE_PST, 58 SCALE_PST, 65 SCALE_PST, 61 SCALE_PST, 69 SCALE_PST, 11 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 7 SCALE_PST, 27 SCALE_PST, 20 SCALE_PST, 56 SCALE_PST, 91 SCALE_PST, 108 SCALE_PST, 53 SCALE_PST, 44 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, -1 SCALE_PST, 16 SCALE_PST, 29 SCALE_PST, 27 SCALE_PST, 37 SCALE_PST, 27 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, 1 SCALE_PST, 5 SCALE_PST, 23 SCALE_PST, 32 SCALE_PST, 21 SCALE_PST, 8 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 5 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 13 SCALE_PST, 10 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 15 SCALE_PST, 5 SCALE_PST, 13 SCALE_PST, -10 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, -8 SCALE_PST, -37 SCALE_PST, -31 SCALE_PST, -8 SCALE_PST, -45 SCALE_PST, -67 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable BishopSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, -8 SCALE_PST, -37 SCALE_PST, -31 SCALE_PST, -8 SCALE_PST, -45 SCALE_PST, -67 SCALE_PST,0 SCALE_PST,
	0 SCALE_PST, 15 SCALE_PST, 5 SCALE_PST, 13 SCALE_PST, -10 SCALE_PST, 1 SCALE_PST, 2 SCALE_PST, 0 SCALE_PST, 15 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 5 SCALE_PST, 12 SCALE_PST, 14 SCALE_PST, 13 SCALE_PST, 10 SCALE_PST, -1 SCALE_PST, 3 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, 1 SCALE_PST, 5 SCALE_PST, 23 SCALE_PST, 32 SCALE_PST, 21 SCALE_PST, 8 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,		  0 SCALE_PST,
	0 SCALE_PST, -1 SCALE_PST, 16 SCALE_PST, 29 SCALE_PST, 27 SCALE_PST, 37 SCALE_PST, 27 SCALE_PST, 17 SCALE_PST, 4 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, 7 SCALE_PST, 27 SCALE_PST, 20 SCALE_PST, 56 SCALE_PST, 91 SCALE_PST, 108 SCALE_PST, 53 SCALE_PST, 44 SCALE_PST,	  0 SCALE_PST,
	0 SCALE_PST, -24 SCALE_PST, -23 SCALE_PST, 30 SCALE_PST, 58 SCALE_PST, 65 SCALE_PST, 61 SCALE_PST, 69 SCALE_PST, 11 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,			  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable EndgameKnightSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -21 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -21		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -2 SCALE_PST, 17 SCALE_PST, 30 SCALE_PST, 36 SCALE_PST, 36 SCALE_PST, 30 SCALE_PST, 17 SCALE_PST, -2			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -22			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -46 SCALE_PST, -27 SCALE_PST, -15 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -15 SCALE_PST, -27 SCALE_PST, -46		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -81 SCALE_PST, -62 SCALE_PST, -49 SCALE_PST, -43 SCALE_PST, -43 SCALE_PST, -49 SCALE_PST, -62 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 	-99 SCALE_PST, -99 SCALE_PST, -94 SCALE_PST, -88 SCALE_PST, -88 SCALE_PST, -94 SCALE_PST, -99 SCALE_PST, -99 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable EndgameKnightSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 	-99 SCALE_PST, -99 SCALE_PST, -94 SCALE_PST, -88 SCALE_PST, -88 SCALE_PST, -94 SCALE_PST, -99 SCALE_PST, -99 SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -81 SCALE_PST, -62 SCALE_PST, -49 SCALE_PST, -43 SCALE_PST, -43 SCALE_PST, -49 SCALE_PST, -62 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -46 SCALE_PST, -27 SCALE_PST, -15 SCALE_PST, -9 SCALE_PST, -9 SCALE_PST, -15 SCALE_PST, -27 SCALE_PST, -46		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -22			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -2 SCALE_PST, 17 SCALE_PST, 30 SCALE_PST, 36 SCALE_PST, 36 SCALE_PST, 30 SCALE_PST, 17 SCALE_PST, -2			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -7 SCALE_PST, 12 SCALE_PST, 25 SCALE_PST, 31 SCALE_PST, 31 SCALE_PST, 25 SCALE_PST, 12 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -21 SCALE_PST, -3 SCALE_PST, 10 SCALE_PST, 16 SCALE_PST, 16 SCALE_PST, 10 SCALE_PST, -3 SCALE_PST, -21		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};


const PieceSquareTable KnightSquareTableL = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -60 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0			       SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -34 SCALE_PST, 24 SCALE_PST, 54 SCALE_PST, 74 SCALE_PST, 60 SCALE_PST, 122 SCALE_PST, 2 SCALE_PST, 29		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, 18 SCALE_PST, 60 SCALE_PST, 64 SCALE_PST, 124 SCALE_PST, 143 SCALE_PST, 55 SCALE_PST, 6		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, -4 SCALE_PST, 25 SCALE_PST, 33 SCALE_PST, 10 SCALE_PST, 33 SCALE_PST, 14 SCALE_PST, 43		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 19 SCALE_PST, 12 SCALE_PST, 33 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -38 SCALE_PST, -16 SCALE_PST, 0 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, -42		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -56 SCALE_PST, -31 SCALE_PST, -28 SCALE_PST, -1 SCALE_PST, -7 SCALE_PST, -20 SCALE_PST, -42 SCALE_PST, -11	   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -99 SCALE_PST, -30 SCALE_PST, -66 SCALE_PST, -64 SCALE_PST, -29 SCALE_PST, -19 SCALE_PST, -61 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};

const PieceSquareTable KnightSquareTableD = {
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, -99 SCALE_PST, -30 SCALE_PST, -66 SCALE_PST, -64 SCALE_PST, -29 SCALE_PST, -19 SCALE_PST, -61 SCALE_PST, -81  SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -56 SCALE_PST, -31 SCALE_PST, -28 SCALE_PST, -1 SCALE_PST, -7 SCALE_PST, -20 SCALE_PST, -42 SCALE_PST, -11	   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -38 SCALE_PST, -16 SCALE_PST, 0 SCALE_PST, 14 SCALE_PST, 8 SCALE_PST, 3 SCALE_PST, 3 SCALE_PST, -42		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, 0 SCALE_PST, 2 SCALE_PST, 3 SCALE_PST, 19 SCALE_PST, 12 SCALE_PST, 33 SCALE_PST, -7			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -14 SCALE_PST, -4 SCALE_PST, 25 SCALE_PST, 33 SCALE_PST, 10 SCALE_PST, 33 SCALE_PST, 14 SCALE_PST, 43		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -22 SCALE_PST, 18 SCALE_PST, 60 SCALE_PST, 64 SCALE_PST, 124 SCALE_PST, 143 SCALE_PST, 55 SCALE_PST, 6		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -34 SCALE_PST, 24 SCALE_PST, 54 SCALE_PST, 74 SCALE_PST, 60 SCALE_PST, 122 SCALE_PST, 2 SCALE_PST, 29		   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, -60 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0			   SCALE_PST,  0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
	0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST, 0 SCALE_PST,
};



#ifndef HAIR_PAWNS
const PieceSquareTable PawnSquareTableL =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable EndgamePawnSquareTableL =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable PawnSquareTableD =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
const PieceSquareTable EndgamePawnSquareTableD =
{
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0, -40, -40,   0,   0,   0,   0,
	0,   1,   2,   3, -10, -10,   3,   2,   1,   0,
	0,   2,   4,   6,   8,   8,   6,   4,   2,   0,
	0,   3,   6,   9,  12,  12,   9,   6,   3,   0,
	0,   4,   8,  12,  16,  16,  12,   8,   4,   0,
	0,   5,  10,  15,  20,  20,  15,  10,   5,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
};
#else
const PieceSquareTable PawnSquareTableL =
{
	//A1                                H1
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0                 PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 118 PAWN_SCALE, 121 PAWN_SCALE, 173 PAWN_SCALE, 168 PAWN_SCALE, 107 PAWN_SCALE, 82 PAWN_SCALE, -16 PAWN_SCALE, 22	  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 21 PAWN_SCALE, 54 PAWN_SCALE, 72 PAWN_SCALE, 56 PAWN_SCALE, 77 PAWN_SCALE, 95 PAWN_SCALE, 71 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 9 PAWN_SCALE, 30 PAWN_SCALE, 23 PAWN_SCALE, 31 PAWN_SCALE, 31 PAWN_SCALE, 23 PAWN_SCALE, 17 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 14 PAWN_SCALE, 8 PAWN_SCALE, 4 PAWN_SCALE, 5 PAWN_SCALE, 4 PAWN_SCALE, 10 PAWN_SCALE, 7				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 1 PAWN_SCALE, -6 PAWN_SCALE, -19 PAWN_SCALE, -6 PAWN_SCALE, -7 PAWN_SCALE, -4 PAWN_SCALE, 10		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, -1 PAWN_SCALE, -7 PAWN_SCALE, -11 PAWN_SCALE, -35 PAWN_SCALE, -13 PAWN_SCALE, 5 PAWN_SCALE, 3 PAWN_SCALE, -5		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	//A8                                H8
};

const PieceSquareTable PawnSquareTableD =
{
	//A1                                H1
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0                 PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, -1 PAWN_SCALE, -7 PAWN_SCALE, -11 PAWN_SCALE, -35 PAWN_SCALE, -13 PAWN_SCALE, 5 PAWN_SCALE, 3 PAWN_SCALE, -5		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 1 PAWN_SCALE, -6 PAWN_SCALE, -19 PAWN_SCALE, -6 PAWN_SCALE, -7 PAWN_SCALE, -4 PAWN_SCALE, 10		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 1 PAWN_SCALE, 14 PAWN_SCALE, 8 PAWN_SCALE, 4 PAWN_SCALE, 5 PAWN_SCALE, 4 PAWN_SCALE, 10 PAWN_SCALE, 7				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 9 PAWN_SCALE, 30 PAWN_SCALE, 23 PAWN_SCALE, 31 PAWN_SCALE, 31 PAWN_SCALE, 23 PAWN_SCALE, 17 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 21 PAWN_SCALE, 54 PAWN_SCALE, 72 PAWN_SCALE, 56 PAWN_SCALE, 77 PAWN_SCALE, 95 PAWN_SCALE, 71 PAWN_SCALE, 11		  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 118 PAWN_SCALE, 121 PAWN_SCALE, 173 PAWN_SCALE, 168 PAWN_SCALE, 107 PAWN_SCALE, 82 PAWN_SCALE, -16 PAWN_SCALE, 22	  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0				  PAWN_SCALE,  0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE, 0 PAWN_SCALE,
	//A8                                H8
};

//#define END_PAWN_SCALE +30
const PieceSquareTable EndgamePawnSquareTableL =
{
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, -11 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, -17 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE, 0 END_PAWN_SCALE,
};

const PieceSquareTable EndgamePawnSquareTableD =
{
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,-17 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,-11 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,-7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE, -7 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE, 16 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE, 55 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE, 82 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
	0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,  0 END_PAWN_SCALE,
};
#endif

//#define PAWN_PSQ_ONLY

#ifdef PAWN_PSQ_ONLY
const signed int * SquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,

	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,

	EmptySquareTable,
	EmptySquareTable,

	KnightSquareTableL,
	BishopSquareTableL,
	RookSquareTableL,
	RookSquareTableL,
	EmptySquareTable,//QueenSquareTableL, bad
};
const signed int * SquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,

	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,

	EmptySquareTable,
	EmptySquareTable,

	KnightSquareTableD,
	BishopSquareTableD,
	RookSquareTableD,
	RookSquareTableD,
	EmptySquareTable,//QueenSquareTableD, bad
};

const signed int * EndgameSquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EndgameKnightSquareTableL,
	EndgameBishopSquareTableL,
	EndgameRookSquareTableL,
	EndgameRookSquareTableL,
	EndgameQueenSquareTableL, //ok
};

const signed int * EndgameSquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EmptySquareTable,
	EndgameKnightSquareTableD,
	EndgameBishopSquareTableD,
	EndgameRookSquareTableD,
	EndgameRookSquareTableD,
	EndgameQueenSquareTableD, //ok
};
#else
const signed int * SquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingMidSquareTableL,
	KingMidSquareTableL,
	KingMidSquareTableL,
	PawnSquareTableL,
	PawnSquareTableL,
	KnightSquareTableL,
	BishopSquareTableL,
	RookSquareTableL,
	RookSquareTableL,
	EmptySquareTable,//
					 //	QueenSquareTableL, //bad
};
const signed int * SquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingMidSquareTableD,
	KingMidSquareTableD,
	KingMidSquareTableD,
	PawnSquareTableD,
	PawnSquareTableD,
	KnightSquareTableD,
	BishopSquareTableD,
	RookSquareTableD,
	RookSquareTableD,
	EmptySquareTable,//
					 //QueenSquareTableD, //bad
};

const signed int * EndgameSquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingEndSquareTableL,
	KingEndSquareTableL,
	KingEndSquareTableL,
	EndgamePawnSquareTableL,
	EndgamePawnSquareTableL,
	EndgameKnightSquareTableL,
	EndgameBishopSquareTableL,
	EndgameRookSquareTableL,
	EndgameRookSquareTableL,
	EndgameQueenSquareTableL, //ok
};

const signed int * EndgameSquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	KingEndSquareTableD,
	KingEndSquareTableD,
	KingEndSquareTableD,
	EndgamePawnSquareTableD,
	EndgamePawnSquareTableD,
	EndgameKnightSquareTableD,
	EndgameBishopSquareTableD,
	EndgameRookSquareTableD,
	EndgameRookSquareTableD,
	EndgameQueenSquareTableD, //ok
};
#endif
#else
#endif

#define SIMPLE_SCALE *5

const PieceSquareTable sQueenSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};

const PieceSquareTable sQueenSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sRookSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};

const PieceSquareTable sRookSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sBishopSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sBishopSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};

const PieceSquareTable sKnightSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-8  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-8  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,2  SIMPLE_SCALE,3  SIMPLE_SCALE,3  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,1  SIMPLE_SCALE,3  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,3  SIMPLE_SCALE,1  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,3  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,3  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,3  SIMPLE_SCALE,3  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-8  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-8  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,

};
const PieceSquareTable sPawnSquareTableL =
{
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sPawnSquareTableD =
{
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,-1  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,-1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sEndgamePawnSquareTableL =
{
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sEndgamePawnSquareTableD =
{
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,5  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,9  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,14  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,20  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,50  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};

const PieceSquareTable sKnightSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-8  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-8  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,1  SIMPLE_SCALE,2  SIMPLE_SCALE,3  SIMPLE_SCALE,3  SIMPLE_SCALE,2  SIMPLE_SCALE,1  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,3  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,3  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,1  SIMPLE_SCALE,3  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,3  SIMPLE_SCALE,1  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,2  SIMPLE_SCALE,3  SIMPLE_SCALE,3  SIMPLE_SCALE,2  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-8  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-8  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,

};
const PieceSquareTable sKingMidSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};

const PieceSquareTable sKingMidSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,1  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,1  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,4  SIMPLE_SCALE,4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-1  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-1  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const PieceSquareTable sKingEndSquareTableL = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,6  SIMPLE_SCALE,8  SIMPLE_SCALE,8  SIMPLE_SCALE,6  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,6  SIMPLE_SCALE,8  SIMPLE_SCALE,8  SIMPLE_SCALE,6  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};


const PieceSquareTable sKingEndSquareTableD = {
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,6  SIMPLE_SCALE,8  SIMPLE_SCALE,8  SIMPLE_SCALE,6  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,6  SIMPLE_SCALE,8  SIMPLE_SCALE,8  SIMPLE_SCALE,6  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-2  SIMPLE_SCALE,4  SIMPLE_SCALE,6  SIMPLE_SCALE,6  SIMPLE_SCALE,4  SIMPLE_SCALE,-2  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,-2  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,-2  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,-10  SIMPLE_SCALE,-8  SIMPLE_SCALE,-6  SIMPLE_SCALE,-4  SIMPLE_SCALE,-4  SIMPLE_SCALE,-6  SIMPLE_SCALE,-8  SIMPLE_SCALE,-10  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
	0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,0  SIMPLE_SCALE,
};
const signed int * sSquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	sKingMidSquareTableL,
	sKingMidSquareTableL,
	sKingMidSquareTableL,
	sPawnSquareTableL,
	sPawnSquareTableL,
	sKnightSquareTableL,
	sBishopSquareTableL,
	sRookSquareTableL,
	sRookSquareTableL,
	sQueenSquareTableL, 
};
const signed int * sSquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	sKingMidSquareTableD,
	sKingMidSquareTableD,
	sKingMidSquareTableD,
	sPawnSquareTableD,
	sPawnSquareTableD,
	sKnightSquareTableD,
	sBishopSquareTableD,
	sRookSquareTableD,
	sRookSquareTableD,
	sQueenSquareTableD, 
};
const signed int * sEndgameSquareTableL[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	sKingEndSquareTableL,
	sKingEndSquareTableL,
	sKingEndSquareTableL,
	sEndgamePawnSquareTableL,
	sEndgamePawnSquareTableL,
	sKnightSquareTableL,
	sBishopSquareTableL,
	sRookSquareTableL,
	sRookSquareTableL,
	sQueenSquareTableL,
};

const signed int * sEndgameSquareTableD[NUM_PIECE_TYPES] = {
	EmptySquareTable,
	sKingEndSquareTableD,
	sKingEndSquareTableD,
	sKingEndSquareTableD,
	sEndgamePawnSquareTableD,
	sEndgamePawnSquareTableD,
	sKnightSquareTableD,
	sBishopSquareTableD,
	sRookSquareTableD,
	sRookSquareTableD,
	sQueenSquareTableD,
};

const Pos HomeRow[2][8] = { { a1,b1,c1,d1,e1,f1,g1,h1 } ,{ a8,b8,c8,d8,e8,f8,g8,h8 } };
const Pos PawnsRow[2][8] = { { a2,b2,c2,d2,e2,f2,g2,h2 } ,{ a7,b7,c7,d7,e7,f7,g7,h7 } };

#define POINT_THREATS 0
#define EXPANDING_THREATS 1

const Pos PAWN_L_THREAT_DESC[] = { POINT_THREATS,2,-9,-11 };
const Pos PAWN_D_THREAT_DESC[] = { POINT_THREATS,2,9,11 };
const Pos KNIGHT_THREAT_DESC[] = { POINT_THREATS,8,-21,-19, -12, -8, +12, +8, +21, +19 };
const Pos QUEEN_THREAT_DESC[] = { EXPANDING_THREATS,8,-10,+10, -1, +1,+9,+11,-9,-11 };
const Pos KING_THREAT_DESC[] = { POINT_THREATS,8,-10,+10, -1, +1,+9,+11,-9,-11 };
const Pos ROOK_THREAT_DESC[] = { EXPANDING_THREATS,4,-10,+10, -1, +1 };
const Pos BISHOP_THREAT_DESC[] = { EXPANDING_THREATS,4,+9,+11,-9,-11 };

int PersistantValue;
double EphemeralValue;

int CurrentPly = 0;
PlayersType Players;
#ifdef NDEBUG
#define board_consistent()
#define massert(a) 
#else

void print_board();
void log_board();

void do_assertion(const char *n)
{
	printf("\nFailed %s\n", n);
	LOG(Log << "\n**** Failed " << n << endl);
	//	log_board();
	print_board();
	//	abort();
}

#define massert(a) if (!(a)) do_assertion(#a)

int PlayersReferences[NUM_PIECE_SLOTS];

void board_consistent()
{
	for (int i = 0;i < NUM_PIECE_SLOTS;++i)PlayersReferences[i] = 0;
	for (Pos i = a8;i <= h1;++i) {
		if (Board[i] != NO_SLOT && Board[i] != OFF_BOARD) {
			massert(i == Players.positions[Board[i]]);
			massert(Players.pieces[Board[i]] != EMPTY);
			if (Board[i] != NO_SLOT && Board[i] != OFF_BOARD) {
				++PlayersReferences[Board[i]];
				massert(PlayersReferences[Board[i]] == 1);
			}
		}
	}
	for (PieceSlotType i = LIGHT_PAWN1; i <= LIGHT_KINGP;i = (PieceSlotType)(i + 1))
	{
		massert(Players.pieces[i] >= EMPTY && Players.pieces[i] < NUM_PIECE_TYPES);
		if (Players.pieces[i] != EMPTY) { massert(Board[Players.positions[i]] == i); }
	}
	for (PieceSlotType i = DARK_PAWN1; i <= DARK_KINGP;i = (PieceSlotType)(i + 1))
	{
		massert(Players.pieces[i] >= EMPTY && Players.pieces[i] < NUM_PIECE_TYPES);
		if (Players.pieces[i] != EMPTY) { massert(Board[Players.positions[i]] == i); }
	}
	//	eval();
}

#endif

inline bool is_pawn_at(Pos p, Colors c)
{
	PieceSlotType s = Board[c];
	return is_piece(s) && color(s) == c && is_pawn(Players.pieces[s]);
}

inline void set_position(Pos p, PieceSlotType s)
{
	Board[p] = s;
	Players.positions[s] = p;
}


inline bool is_piece(Pos p)
{
	return is_piece(Board[p]);
}

int brand()
{
	int j = rand() & 15;
	while (j--)rand();
	return rand();
}
uint64_t rand64() {

	return brand() ^ ((uint64_t)brand() << 15) ^ ((uint64_t)brand() << 30) ^ ((uint64_t)brand() << 45) ^ ((uint64_t)brand() << 60);
}

#define SMALL_HASH

#ifdef SMALL_HASH
struct HashType
{
	uint64_t low;
	void rand() {
		low = rand64();
	}
	int high_mask() { return (int)(low >> 32); }
	void clear()
	{
		low = 0;
	}
	void operator ^=(const HashType &o)
	{
		low ^= o.low;
	}
	HashType operator ^ (const HashType &o)
	{
		return HashType{ low ^ o.low };
	}

	bool operator == (const HashType & o) const
	{
		return low == o.low;
	}
	bool is_zero() const
	{
		return low == 0;
	}
};
#else
struct HashType
{
	uint64_t low;
	uint64_t high;
	void rand() {
		low = rand64();
		high = rand64();
	}
	int high_mask() { return (int)high; }
	void clear()
	{
		low = high = 0;
	}
	void operator ^=(const HashType &o)
	{
		low ^= o.low;
		high ^= o.high;
	}
	HashType operator ^ (const HashType &o)
	{
		return HashType{ low ^ o.low, high ^ o.high };
	}

	bool operator == (const HashType & o) const
	{
		return low == o.low && high == o.high;
	}
	bool is_zero() const
	{
		return low == 0 && high == 0;
	}
};

#endif
HashType Hash;
//one clears the hash by incrementing this by the maximum number of moves per game
int ClearHash = 0;
Colors _PlySide = LIGHT;
HashType LightHash;
inline Colors PlySide()
{
	return _PlySide;
}
inline void set_PlySide(Colors c)
{
	if (c != _PlySide) {
		_PlySide = c;
		Hash ^= LightHash;
	}
}

const Pos SquareToRowIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1,1,0,
	0,2,2,2,2,2,2,2,2,0,
	0,3,3,3,3,3,3,3,3,0,
	0,4,4,4,4,4,4,4,4,0,
	0,5,5,5,5,5,5,5,5,0,
	0,6,6,6,6,6,6,6,6,0,
	0,7,7,7,7,7,7,7,7,0,
	0,8,8,8,8,8,8,8,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,

};
//for increments +/-10
const Pos SquareToColIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,1,2,3,4,5,6,7,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

const Pos SquareToDiagLeftIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,8,9,10,11,12,13,14,15,0,
	0,7,8,9,10,11,12,13,14,0,
	0,6,7,8,9,10,11,12,13,0,
	0,5,6,7,8,9,10,11,12,0,
	0,4,5,6,7,8,9,10,11,0,
	0,3,4,5,6,7,8,9,10,0,
	0,2,3,4,5,6,7,8,9,0,
	0,1,2,3,4,5,6,7,8,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

//for increments +/-9
const Pos SquareToDiagRightIndex[120] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,1,2,3,4,5,6,7,8,0,
	0,2,3,4,5,6,7,8,9,0,
	0,3,4,5,6,7,8,9,10,0,
	0,4,5,6,7,8,9,10,11,0,
	0,5,6,7,8,9,10,11,12,0,
	0,6,7,8,9,10,11,12,13,0,
	0,7,8,9,10,11,12,13,14,0,
	0,8,9,10,11,12,13,14,15,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

Pos RookDirection[h1 + 1][h1 + 1];
Pos BishopDirection[h1 + 1][h1 + 1];
Pos QueenDirection[h1 + 1][h1 + 1];
Pos KingDirection[h1 + 1][h1 + 1];
Pos KnightDirection[h1 + 1][h1 + 1];

void init_direction_tables()
{
	for (int i = 0;i <= h1;++i)
		for (int j = 0;j <= h1;++j)
			RookDirection[i][j] = BishopDirection[i][j] = QueenDirection[i][j] = KingDirection[i][j] = KnightDirection[i][j] = 0;

	for (int i = 0;i <= h1;++i) {
		if (SquareToRowIndex[i] == 0) continue;
		for (int j = 0;j <= h1;++j) {
			if (SquareToRowIndex[j] == 0) continue;
			if (SquareToColIndex[i] != 0 && SquareToColIndex[i] == SquareToColIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -10;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 10;
			}
			if (SquareToRowIndex[i] != 0 && SquareToRowIndex[i] == SquareToRowIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -1;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 1;
			}
			if (SquareToDiagLeftIndex[i] != 0 && SquareToDiagLeftIndex[i] == SquareToDiagLeftIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -11;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 11;
			}
			if (SquareToDiagRightIndex[i] != 0 && SquareToDiagRightIndex[i] == SquareToDiagRightIndex[j]) {
				if (j < i) RookDirection[i][j] = QueenDirection[i][j] = -9;
				else if (j>i)  RookDirection[i][j] = QueenDirection[i][j] = 9;
			}
			if (abs(SquareToRowIndex[i] - SquareToRowIndex[j]) <= 1
				&& abs(SquareToColIndex[i] - SquareToColIndex[j]) <= 1
				&& i != j) {
				KingDirection[i][j] = j - i;
			}
			if ((abs(SquareToRowIndex[i] - SquareToRowIndex[j]) == 3
				&& abs(SquareToColIndex[i] - SquareToColIndex[j]) == 2)
				|| (abs(SquareToRowIndex[i] - SquareToRowIndex[j]) == 2
					&& abs(SquareToColIndex[i] - SquareToColIndex[j]) == 3)) {
				KnightDirection[i][j] = j - i;
			}
		}
	}

}



bool in_front_of_king(PieceSlotType s)
{
	if (!is_piece(s)) return false;
	if (color(s) == LIGHT) {
		return SquareToRowIndex[Players.positions[s]] < SquareToRowIndex[Players.positions[KINGP + base_by_color(color(s))]];
	}
	else {
		return SquareToRowIndex[Players.positions[s]] > SquareToRowIndex[Players.positions[KINGP + base_by_color(color(s))]];
	}
}
int horizontal_distance_from_king(PieceSlotType s)
{
	return abs(SquareToColIndex[Players.positions[s]] - SquareToColIndex[Players.positions[KINGP + base_by_color(color(s))]]);
}
int horizontal_distance_from_king(PieceSlotType s, Pos p)
{
	return abs(SquareToColIndex[p] - SquareToColIndex[Players.positions[KINGP + base_by_color(color(s))]]);
}

//return 0 for directly in front, 1 for one away, >1 for not shielding king
int shielding_king(PieceSlotType s)
{
	if (in_front_of_king(s)) return horizontal_distance_from_king(s);
	return 8;
}

int shielding_king(PieceSlotType s, Pos p)
{
	if (in_front_of_king(s)) return horizontal_distance_from_king(s, p);
	return 8;
}

inline void add_bonus(Colors side, double bonus)
{
	if (side == PlySide()) EphemeralValue += bonus;
	else EphemeralValue -= bonus;
}

int ways_can_castle(Colors side)
{
	if (Players.pieces[KINGP + base_by_color(side)] != KING_NOT_MOVED) return 0;
	return (Players.pieces[ROOK1 + base_by_color(side)] == ROOK_NOT_MOVED ? 1 : 0) + (Players.pieces[ROOK2 + base_by_color(side)] == ROOK_NOT_MOVED ? 1 : 0);
}

inline int count_slot(int s)
{
	return  Players.pieces[s] == EMPTY ? 0 : 1;
}

bool SideInEndgame_for_null(Colors s)
{
	//return MaterialSums[other_color(s)][MAJOR_MINOR_COUNT] <= (QUEEN_VALUE + KNIGHT_VALUE);
	PieceSlotType base = base_by_color(other_color(s));

	return //Players.pieces[QUEENP + base] == EMPTY ||
		(
			2 > count_slot(ROOK1 + base) + count_slot(ROOK2 + base) + count_slot(QUEENP + base)
			&& 2 > count_slot(BISHOP1 + base) + count_slot(BISHOP2 + base)
			+ count_slot(KNIGHT1 + base) + count_slot(KNIGHT2 + base));

}

bool SideInEndgame(Colors s)
{
	//return MaterialSums[other_color(s)][MAJOR_MINOR_COUNT] <= (QUEEN_VALUE + KNIGHT_VALUE);
	PieceSlotType base = base_by_color(other_color(s));

	return Players.pieces[QUEENP + base] == EMPTY ||
		(
			2 > count_slot(ROOK1 + base) + count_slot(ROOK2 + base) + count_slot(QUEENP + base)
			&& 2 > count_slot(BISHOP1 + base) + count_slot(BISHOP2 + base)
			+ count_slot(KNIGHT1 + base) + count_slot(KNIGHT2 + base));

}

int simple_eval();
inline int simple_eval(Colors c)
{
	if (PlySide() == c) return simple_eval();
	return -simple_eval();
}

enum MoveFlags : char { NotCastling, CastleLeft, CastleRight, Extend };
struct Move
{
	enum CheckForEnpassantEnum { CheckForEnpassant, DoEnpassant };

	Pos from;
	Pos to;
	Pos taken_at; //different than to in case of enpassant
	PieceType initial;
	PieceType became;  //promotion or transition
	PieceSlotType slot_taken;
	PieceType piece_taken;
	MoveFlags move_flags;
	//	int see;
	short bonus;
	//	short perm_bonus;
	//	HashType hash;
	DEFLINE
		Move &set_bonus(short b) { bonus = b; return *this; }



	void movement_bonuses()
	{
		if (bonus != SHORTINF)return;
		bonus = 0;
		const Colors my_side = color(Board[from]);
		const Colors other_side = other_color(my_side);
		/*

		if (my_side == computer_side &&
		piece_taken != EMPTY) {
		if (simple_eval(my_side)>0)
		bonus += 5;//transaction bonus to make computer aggressive
		else
		bonus -= 5;
		}
		int material_threat = MaterialSums[other_side][MAJOR_MINOR_COUNT];
		if (is_pawn(piece_taken)) {
		switch (shielding_king(slot_taken)) {
		case 0: bonus += 40* material_threat>>12; break;
		case 1: bonus += 20 * material_threat >> 12;
		}
		}
		if (is_pawn(initial)) {
		int shielding = shielding_king(Board[from]);
		if (shielding < 2) {
		int to_shielding = shielding_king(Board[from], to);
		if (to_shielding > shielding) {
		switch (shielding) {
		case 0: bonus -= 20 * material_threat >> 12; break;
		case 1: bonus -= 40 * material_threat >> 12;
		}
		}
		else {
		switch (shielding) {
		case 0: bonus -= 20 * material_threat >> 12; break;
		case 1: bonus -= 10 * material_threat >> 12;
		}
		}
		}
		}
		//*/
		
		if (!SideInEndgame(my_side)) {
			int material_threat = MaterialSums[other_side][MAJOR_MINOR_COUNT];
			if (move_flags == NotCastling) {
				if (initial == KING_NOT_MOVED || initial == ROOK_NOT_MOVED) {
					switch (ways_can_castle(color(Board[from]))) {
						case 1: 
							bonus -= 30* material_threat>>10; 
							break;
						case 2: 
							if (initial == KING_NOT_MOVED) bonus -= 30 * material_threat >> 10; 
							else bonus -= 30 * material_threat >> 10;
					}
				}
				else if (became == KING || became == KING_CASTLED) bonus -= 15* material_threat >> 10;
			}
		}
		//if (move_flags == Extend) bonus += 8;
		//*/
	}
	void clear() { from = 0; }
	bool operator == (const Move &o) {
		if (from != o.from) return false;
		return (to == o.to && became == o.became) || from == 0;
	}
	bool empty() const {
		return from == 0;
	}
	Move() :from(0) {}
	//	Move(Pos f, Pos t) :from(f), to(t), initial(EMPTY), promotion(EMPTY) {}
	Move(Pos f, Pos t PARAMLINE);
	Move(Pos f, Pos t, MoveFlags c PARAMLINE);
	Move(Pos f, Pos t, PieceType type PARAMLINE);

	bool is_enpassant() { return to != taken_at; }
	Move(Pos f, Pos t, Pos enpassant_pos, CheckForEnpassantEnum PARAMLINE);
	//from other player
	Move(Pos f, Pos t, CheckForEnpassantEnum PARAMLINE);

	Move(const Move &m);
	void operator = (const Move &m);
	Move(Move &&m);
	void make();
	void unmake();
	//in place moves used to change pawn type to mark vulnerablity to enpassant
	//and transition to endgame (changing king type)
	bool not_move() { return from == to; }
};

struct RelativeMove
{
	PieceSlotType from;
	PieceSlotType slot_taken;
	Pos from_pos;
	Pos to;
	PieceType promotion;
	MoveFlags move_flags;
	RelativeMove(const Move &m) :from(m.from == 0 ? NO_SLOT : Board[m.from]), from_pos(m.from), to(m.to), promotion(m.became),move_flags(m.move_flags),
		slot_taken(m.slot_taken) {}
	void operator = (const RelativeMove &m)
	{
		from = m.from;
		slot_taken = m.slot_taken;
		from_pos = m.from_pos;
		to = m.to;
		promotion = m.promotion;
		move_flags = m.move_flags;
	}

	void operator = (const Move &m)
	{
		from_pos = m.from;
		slot_taken = m.slot_taken;
		from = m.from == 0 ? NO_SLOT : Board[m.from];
		to = m.to;
		promotion = m.became;
		move_flags = m.move_flags;
	}
	RelativeMove() :from(NO_SLOT) {}
	RelativeMove(const RelativeMove &m) :from(m.from), from_pos(m.from_pos), to(m.to), promotion(m.promotion),move_flags(m.move_flags) {}
	bool operator == (const RelativeMove &m) const
	{
		return (from == NO_SLOT && m.from == NO_SLOT) || (from == m.from && from_pos == m.from_pos && to == m.to && slot_taken == m.slot_taken
			&& promotion == m.promotion);
	}
	bool operator == (const Move &m) const
	{
		return (from == NO_SLOT && m.from == 0) || (from != NO_SLOT && from_pos == m.from &&  slot_taken == m.slot_taken
			&& from == Board[m.from] && to == m.to && promotion == m.became);
	}
	bool empty() const { return from == NO_SLOT; }
	void clear() { from = NO_SLOT; }
};

struct ImmediateMoveList {
	Move moves[MAX_MOVES_PER_PLY];
	//	int delta[MAX_MOVES_PER_PLY];
	int base; //clear in order_moves()
	ImmediateMoveList() :base(0) {}
	void clear()
	{
		base = 0;
	}
	void push(Move m)
	{
		moves[base++] = m;
	}
	Move &back()
	{
		return moves[base - 1];
	}
	bool empty() const { return base == 0; }
	void pop() { --base; }
};

struct SortingMoveList {
	struct Entry {
		int index;
		int key;
	};
	Entry entries[MAX_MOVES_PER_PLY];
	Move moves[MAX_MOVES_PER_PLY];
	int base; //clear in order_moves()
	SortingMoveList() :base(0) {}
	void clear()
	{
		base = 0;
	}
	void push(Move m, int key)
	{
		moves[base] = m;
		//		moves[base].see = key;
		entries[base].index = base;
		entries[base++].key = key;
	}
	int back_value()
	{
		return entries[base - 1].key;
	}
	Move &back()
	{
		return moves[entries[base - 1].index];
	}
	static int comp(const void * elem1, const void * elem2)
	{
		const Entry * const f = ((Entry*)elem1);
		const Entry * const s = ((Entry*)elem2);
		return s->key - f->key;//reversed
	}
	void sort()
	{
		if (base > 1)
			qsort(&entries[0], base, sizeof(entries) / MAX_MOVES_PER_PLY, comp);
	}
	bool empty() const { return base == 0; }
	void pop() { --base; }
};

int history_len = 0;
int NCNodes = 0;
int NCMidNodes = 0;

double log_table[] =
{
	0,
	0.6931471806,
	1.0986122887,
	1.3862943611,
	1.6094379124,
	1.7917594692,
	1.9459101491,
	2.0794415417,
	2.1972245773,
	2.302585093,
	2.3978952728,
	2.4849066498,
	2.5649493575,
	2.6390573296,
	2.7080502011,
	2.7725887222,
	2.8332133441,
	2.8903717579,
	2.9444389792,
	2.9957322736,
	3.0445224377,
	3.0910424534,
	3.1354942159,
	3.1780538303,
	3.2188758249,
	3.258096538,
	3.295836866,
	3.3322045102,
	3.36729583,
	3.4011973817,
	3.4339872045,
	3.4657359028,
	3.4965075615,
	3.5263605246,
	3.5553480615,
	3.5835189385,
	3.6109179126,
	3.6375861597,
	3.6635616461,
	3.6888794541,
	3.7135720667,
	3.7376696183,
	3.7612001157,
	3.7841896339,
	3.8066624898,
	3.8286413965,
	3.8501476017,
	3.8712010109,
	3.8918202981,
	3.9120230054,
	3.9318256327,
	3.9512437186,
	3.9702919136,
	3.9889840466,
	4.0073331852,
	4.0253516907,
	4.0430512678,
	4.0604430105,
	4.0775374439,
	4.0943445622,
	4.1108738642,
	4.127134385,
	4.1431347264,
	4.1588830834,
	4.1743872699,
	4.1896547420,
};

struct HH
{
	int time;
	double value;
	void set(int v, double m)
	{
		/*		int t = v;
		int t2 = v;
		while (t != 0) {
		t >>= 2;
		t2 >>= 1;
		}
		++t2;
		if (time != history_len + ClearHash) value = v*v*t2;
		else value += v*v*t2;
		*/
		//		double b = (NCNodes + 1) / (NCMidNodes + 1);
		//		double s = m;
		//		for (int i = 0;i < v;++i) s = s*v;
		double b = (m*v)*v;
		//if (v == 0) b = m;
		//else b = m*exp(log_table[v]*(NCNodes + 1) / (NCMidNodes + 1));

		if (time != history_len + ClearHash) value = b;
		else value += b;
		time = history_len + ClearHash;
	}
	double get()
	{
		if (time != history_len + ClearHash) return 0;
		return value;
	}
	HH()
	{
		time = -1;
		value = 0;
	}
};



HH EmptyHH;
HH HHTable[(NUM_PIECE_SLOTS + 1)*(NUM_PIECE_SLOTS + 1)*(h1 - a8 + 1) * 2 * (h1 - a8 + 1)];
HH &GetHH(bool quiescent, const RelativeMove &r)
{
	if (r.from == NO_SLOT) return EmptyHH;
	//	return CounterMoveTable[s + (h1 - a8 + 1)*(from - a8) + ((h1 - a8 + 1)*(h1 - a8 + 1))*(to - a8)];
	HH & h = HHTable[(r.to - a8) + (h1 - a8 + 1)*((r.from_pos - a8) + (h1 - a8 + 1)*(r.from + NUM_PIECE_SLOTS*(r.slot_taken + (quiescent ? NUM_PIECE_SLOTS : 0)
		)))];
	//massert(h.magic == 1238972149);
	return h;
}

Move EmptyM;
double HistoryParam = .2225;
double HistoryNotBetaParam = 1.0;
#define LONGINF 1e100
//((long long)1<<59)
struct MoveList {
	struct Entry {
		int index;
		int key;
	};
	Move moves[MAX_MOVES_PER_PLY*MAX_PLY];
	int value[MAX_MOVES_PER_PLY*MAX_PLY];
	int hist[MAX_MOVES_PER_PLY*MAX_PLY];
	int base[MAX_PLY];
	int best_index[MAX_PLY];
	int second_best_index[MAX_PLY];
	int third_best_index[MAX_PLY];
	int fourth_best_index[MAX_PLY];
	int ply;
	MoveList() :ply(0) { base[0] = 0; }
	void inc_ply()
	{
		base[ply + 1] = base[ply];
		ply = ply + 1;
		best_index[ply] = -1;
		second_best_index[ply] = -1;
		third_best_index[ply] = -1;
		fourth_best_index[ply] = -1;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void dec_ply() { ply = ply - 1; }
	void push(Move m)
	{
		moves[base[ply]++] = m;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void push(Move m, int v)
	{
		value[base[ply]] = v;
		hist[base[ply]] = 0.0;
		moves[base[ply]++] = m;
		assert(base[ply] < MAX_MOVES_PER_PLY*MAX_PLY);
	}
	void push_list(ImmediateMoveList &i)
	{
		while (!i.empty()) {
			push(i.back());
			i.pop();
		}
	}
	void push_list(SortingMoveList &i)
	{
		i.sort();
		while (!i.empty()) {
			push(i.back(), i.back_value());
			i.pop();
		}
	}
	int index()
	{
		return base[ply];
	}
	void add_history(bool q)
	{
		//		if (CurrentPly > 10) return;
		for (int i = first();i < base[ply]; ++i) {
			if (!moves[i].empty() && hist[i]==0.0) {
				//value[i] += (GetHH(q, RelativeMove(moves[i])).get() + 15) >> 4;
				hist[i] = (GetHH(q, RelativeMove(moves[i])).get());//*.225;
			}
		}
		best_index[ply] = second_best_index[ply] = third_best_index[ply] = fourth_best_index[ply] = -1;
	}

	bool next_unmarked()
	{
		if (empty()) return false;
		if (best_index[ply] == -1)
		{
			best_index[ply] = first();
		}
		else {
			//			marked[best_index[ply]] = true;
			++best_index[ply];
		}
		if (best_index[ply] == base[ply]) return false;
		return true;
	}

	bool find_best()
	{
		if (best_index[ply] != -1) {
			best().clear();
		}
		if (second_best_index[ply] != -1) {
			best_index[ply] = second_best_index[ply];
			second_best_index[ply] = -1;
			return true;
		}
		if (third_best_index[ply] != -1) {
			best_index[ply] = third_best_index[ply];
			third_best_index[ply] = -1;
			return true;
		}
		if (fourth_best_index[ply] != -1) {
			best_index[ply] = fourth_best_index[ply];
			fourth_best_index[ply] = -1;
			return true;
		}
		while (!empty() && back().empty()) pop();
		if (empty()) return false;
		double v = -LONGINF;
		int index = -1;
		int second = -1;
		int third = -1;
		int fourth = -1;
		for (int i = first();i < base[ply]; ++i) {
			if (!moves[i].empty() && value[i]+hist[i] > v) {
				fourth = third;
				third = second;
				second = index;
				index = i;
				v = value[i]+hist[i];
			}
		}
		best_index[ply] = index;
		second_best_index[ply] = second;
		third_best_index[ply] = third;
		fourth_best_index[ply] = fourth;
		return v != -LONGINF;
	}
	void unmark()
	{
		//		for (int i = first();i < base[ply]; ++i) {
		//			marked[i] = false;
		//		}
		best_index[ply] = -1;
	}
	bool no_best()
	{
		return best_index[ply] == -1;
	}
	Move &best()
	{
		if (best_index[ply] == -1) return EmptyM;
		return moves[best_index[ply]];
	}
	int & unmarked_value()
	{
		return value[best_index[ply]];
	}
	int best_value()
	{
		return value[best_index[ply]];
	}
	int back_value()
	{
		return value[base[ply] - 1];
	}
	Move &back()
	{
		return moves[base[ply] - 1];
	}
	bool empty() const { return base[ply] == 0 || (ply != 0 && base[ply] == base[ply - 1]); }
	void pop() { --base[ply]; }
	void clear() {
		ply = 0;
		base[0] = 0;
		best_index[0] = -1;
		second_best_index[0] = -1;
		third_best_index[0] = -1;
		fourth_best_index[0] = -1;
	}
	int first()
	{
		if (ply > 0) return base[ply - 1];
		return 0;
	}
	int end()
	{
		return base[ply];
	}
	Move &operator [] (int i) { return moves[i]; }
};


HashType ZobristSource[NUM_PIECE_TYPES*NUM_COLORS*BOARD_SIZE];
//HashType ColorsZobrist[NUM_COLORS];
inline int ZobristIndex(Colors c, PieceType p, Pos b)
{
	return c + (p << 1) + b*(NUM_COLORS*NUM_PIECE_TYPES);
}

inline int ZobristIndex(PieceSlotType s)
{
	return ZobristIndex(color(s), Players.pieces[s], Players.positions[s]);
}

inline void update_hash(PieceSlotType s)
{
	Hash ^= ZobristSource[ZobristIndex(s)];
}

void update_hash(Pos p)
{
	update_hash(Board[p]);
	assert(is_piece(Players.pieces[Board[p]]) || ZobristSource[ZobristIndex(Board[p])].is_zero());
#ifndef NDEBUG
	if (Board[p] == OFF_BOARD || Board[p] == NO_SLOT) assert(ZobristSource[ZobristIndex(Board[p])].is_zero());
#endif
}


void init_zobrist()
{

	LightHash.rand();
	//ColorsZobrist[LIGHT].rand();
	//ColorsZobrist[DARK].rand();

	for (int i = 0;i < NUM_PIECE_TYPES;++i)
		for (int c = 0;c < NUM_COLORS;++c) {
			for (int j = 0;j < BOARD_SIZE;++j)
				if (is_piece((PieceType)i)) ZobristSource[ZobristIndex((Colors)c, (PieceType)i, (Pos)j)].rand();
				else ZobristSource[ZobristIndex((Colors)c, (PieceType)i, (Pos)j)].clear();
#ifdef GEN_ZOBRIST			
				Log << "\n uint64_t ZobristSource[NUM_PIECE_TYPES][BOARD_SIZE] = \n{\n" << hex;
				for (int i = 0;i < NUM_PIECE_TYPES;++i) {
					Log << "{";
					for (int j = 0;j < BOARD_SIZE;++j) {
						if (j % 10 == 0) Log << endl;
						Log << "0x" << ZobristSource[i][j] << ", ";
					}
					Log << "},\n";
				}
				Log << "}\n" << dec;
#endif
		}
}

ImmediateMoveList Promotions;
ImmediateMoveList KingThreats;
SortingMoveList Captures;
ImmediateMoveList VanillaMoves;
MoveList MovesOrdered;
MoveList MovesIID;

bool sort_pv(Move &m)
{
	if (m.empty()) return false;
	const int first = MovesOrdered.first(), end = MovesOrdered.end();
	for (int i = first; i < end; ++i)
		if (MovesOrdered[i].from == m.from && MovesOrdered[i].to == m.to) {
			MovesOrdered.push(MovesOrdered[i], MovesOrdered.value[i]);
			MovesOrdered[i].clear();
			return true;
		}
	return false;
}
bool sort_pv(RelativeMove &m)
{
	if (m.empty()) return false;
	const int first = MovesOrdered.first(), end = MovesOrdered.end();
	for (int i = first; i < end; ++i)
		if (MovesOrdered[i].from == m.from && MovesOrdered[i].to == m.to) {
			MovesOrdered.push(MovesOrdered[i], MovesOrdered.value[i]);
			MovesOrdered[i].clear();
			return true;
		}
	return false;
}


Move History[MAX_MOVES];

#define REPEAT_BINS_LN2 12
#define REPEAT_BIN_LEN_LN2 4

#define REPEAT_BINS (1<<REPEAT_BINS_LN2)
#define REPEAT_BIN_LEN (1<<REPEAT_BIN_LEN_LN2)

struct RepeatBin
{
	int len;
	HashType list[REPEAT_BIN_LEN];
	RepeatBin() { clear(); }

	void clear() {
		len = 0;
	}
	int count(HashType hash) const
	{
		int sum = 0;
		for (int i = 0;i < len;++i) if (hash == list[i]) ++sum;
		return sum;
	}
	bool full() const { return len == REPEAT_BIN_LEN; }
	void add(HashType hash)
	{
		list[len++] = hash;
	}
	HashType back()
	{
		return list[len - 1];
	}
	void remove()
	{
		--len;
		massert(len >= 0);
	}
};


struct RepeatListStruct {
	int bin_history[MAX_MOVES];
	int history;
	RepeatBin bins[REPEAT_BINS];

	RepeatListStruct() {
		clear();
	}
	void clear()
	{
		for (int i = 0;i < REPEAT_BINS;++i) bins[i].clear();
		history = 0;
	}
	void add(HashType hash)
	{
		int bin = ((int)hash.low & (REPEAT_BINS - 1));
		while (bins[bin].full()) bin = ((bin + 1) & (REPEAT_BINS - 1));
		bins[bin].add(hash);
		bin_history[history++] = bin;
		//	assert(bins[bin_history[history - 1]].back() == Hash);
	}
	void add(Colors c)
	{
		if (PlySide() != c) add(Hash ^ LightHash);
		else add(Hash);
	}

	void remove()
	{
		//		assert(bins[bin_history[history - 1]].back() == Hash);
		massert(history > 0);
		bins[bin_history[--history]].remove();
	}
	int count(HashType hash)
	{
		int sum = 0;
		int bin = ((int)hash.low & (REPEAT_BINS - 1));
		do {
			sum += bins[bin].count(hash);
			if (!bins[bin].full()) {
				//if (sum >= 3) cout << "%";
				return sum;
			}
			bin = ((bin + 1) & (REPEAT_BINS - 1));
		} while (true);
	}
	int count(Colors c)
	{
		if (PlySide() != c) return count(Hash ^ LightHash);
		return count(Hash);
	}

};

Pos UpDir[NUM_COLORS] = {-10, -10 };

RepeatListStruct RepeatList;
Pos RankCalc[NUM_COLORS][BOARD_SIZE] = {
	{
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,8,8,8,8,8,8,8,8,0,
		0,7,7,7,7,7,7,7,7,0,
		0,6,6,6,6,6,6,6,6,0,
		0,5,5,5,5,5,5,5,5,0,
		0,4,4,4,4,4,4,4,4,0,
		0,3,3,3,3,3,3,3,3,0,
		0,2,2,2,2,2,2,2,2,0,
		0,1,1,1,1,1,1,1,1,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,

	},
	{
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,1,1,1,0,
		0,2,2,2,2,2,2,2,2,0,
		0,3,3,3,3,3,3,3,3,0,
		0,4,4,4,4,4,4,4,4,0,
		0,5,5,5,5,5,5,5,5,0,
		0,6,6,6,6,6,6,6,6,0,
		0,7,7,7,7,7,7,7,7,0,
		0,8,8,8,8,8,8,8,8,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,

	},
};

const Pos CenterManhattanDistance[BOARD_SIZE] = { // char is sufficient as well, also unsigned
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0, 6, 5, 4, 3, 3, 4, 5, 6, 0,
	0, 5, 4, 3, 2, 2, 3, 4, 5, 0,
	0, 4, 3, 2, 1, 1, 2, 3, 4, 0,
	0, 3, 2, 1, 0, 0, 1, 2, 3, 0,
	0, 3, 2, 1, 0, 0, 1, 2, 3, 0,
	0, 4, 3, 2, 1, 1, 2, 3, 4, 0,
	0, 5, 4, 3, 2, 2, 3, 4, 5, 0,
	0, 6, 5, 4, 3, 3, 4, 5, 6, 0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
};

int ManhattanDistance(Pos a, Pos b)
{
	return abs(SquareToRowIndex[a] - SquareToRowIndex[b]) + abs(SquareToColIndex[a] - SquareToColIndex[b]);
}

int ChebyshevDistance(Pos a, Pos b)
{
	const int rank_distance = abs(SquareToRowIndex[a] - SquareToRowIndex[b]);
	const int file_distance = abs(SquareToColIndex[a] - SquareToColIndex[b]);
	return __max(rank_distance, file_distance);
}


//47*CenterManhattanDistance[Players.posision[KINGP+other_base]]+16*(14-ManhattanDistance(Players.posision[KINGP_DARK],Players.posision[KINGP_LIGHT]);
//int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner)
//NumPins[c]=calc_pins(c, Players[KINGP+base].positions,Pins[c],Pinners[c]);
PieceSlotType Pinners[NUM_COLORS][8];
PieceSlotType Pins[NUM_COLORS][8];
int NumPins[NUM_COLORS];

Pos PawnsRank[NUM_COLORS][10];
double PawnsTemp[NUM_COLORS];
double EvalTemp[NUM_COLORS];
int NumPinMoves[NUM_COLORS];
Pos PinMoves[NUM_COLORS][64];


const int * pawn_tables[NUM_COLORS] = { EndgamePawnSquareTableL,EndgamePawnSquareTableD };

#define KP_SCALE .3

double eval_kp(Colors c, Colors o, Pos f)
{
	double r;

	if (PawnsRank[c][f] == 2)
		r = 0;
	else if (PawnsRank[c][f] == 3)
		r = (-13 );
	else if (PawnsRank[c][f] != 9)
		r = (-26 );
	else
		r = (-33 );

	if (PawnsRank[o][f] == 9)
		return r - (20 );
	else if (PawnsRank[o][f] == 6)
		return r - (13 );
	else if (PawnsRank[o][f] == 5)
		return r - (7 );
	return r;
}

double MaterialMultiplier[2];

double eval_king(Pos kc, Colors c, Colors o)
{
	double r = 0;
	if (kc < 4) {
		r = ((eval_kp(c, o, 1) + eval_kp(c, o, 2)) * 2) + eval_kp(c, o, 3);
	}
	else if (kc > 5) {
		r = ((eval_kp(c, o, 8) + eval_kp(c, o, 7)) * 2) + eval_kp(c, o, 6);
	}
	else {
		for (int i = kc - 1;i <= kc + 1;++i) {
			if (PawnsRank[o][i] == 9 && PawnsRank[c][i] == 9) r -= 13;
		}
	}
	return r*MaterialMultiplier[c]* KP_SCALE;
}
int mobility(PieceSlotType s);
int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner);

int LowestPassed[NUM_COLORS];

bool Threatened(Colors c, Pos p);

bool KP_END[NUM_COLORS];
int pawn_weight[NUM_COLORS][8];
Colors PromotionTempo[10];
int SEE(Pos);

void simple_calc()
{
	clearEvalDirty();
	for (int i = PAWN1;i < NUM_PIECE_SLOTS;++i) Players.pinned[i] = NotPinned;
	EvalTemp[LIGHT] = EvalTemp[DARK] = 0;
	for (int c = LIGHT;c < NUM_COLORS;++c) {
		KP_END[c] = MaterialSums[c][MAJOR_MINOR_COUNT] == 0;
		int base = base_by_color((Colors)c);
		//		if (Players.pieces[BISHOP1 + base] != EMPTY && Players.pieces[BISHOP2 + base] != EMPTY) EvalTemp[c] += 30;
		//		if (Players.pieces[KNIGHT1 + base] != EMPTY && Players.pieces[KNIGHT2 + base] != EMPTY) EvalTemp[c] += 30;
		{
			const int cq = count_slot(base + QUEENP);
			const int cr = count_slot(base + ROOK1) + count_slot(base + ROOK2);
			if (cq + cr > 1) {
				EvalTemp[c] += (5 * cq + (cr << 1))*PAWN_VALUE >> 5;
			}
		}
		NumPins[c] = 0;//calc_pins((Colors)c, Players.positions[KINGP + base], Pins[c], Pinners[c]);

		//for (int j = NumPins[c] - 1;j >= 0;--j) {
			//int temp = SEE(Players.positions[Players.pieces[Pins[c][j]]]) - (SEE(Players.positions[Players.pieces[Pinners[c][j]]])>>1);
			//EvalTemp[c] -=// __max(temp, 0)>>3;
			//	__max(EValuePerPiece[Players.pieces[Pins[c][j]]] - EValuePerPiece[Players.pieces[Pinners[c][j]]], 0) >> 2;
		//}
		for (int r = KNIGHT1;r <= QUEENP;++r) {
			if (Players.pinned[r] != NotPinned) EvalTemp[c] += .25*mobility((PieceSlotType)(r + base));
		}
	}
	if (MaterialSums[LIGHT][PAWN_COUNT] == 0 && MaterialSums[DARK][PAWN_COUNT] == 0 &&
		Players.pieces[DARK_KNIGHT1] == EMPTY && Players.pieces[DARK_KNIGHT2] == EMPTY &&
		Players.pieces[LIGHT_KNIGHT1] == EMPTY && Players.pieces[LIGHT_KNIGHT2] == EMPTY) {
		if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] != MaterialSums[DARK][MAJOR_MINOR_COUNT]) {
			if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] > MaterialSums[DARK][MAJOR_MINOR_COUNT])
				if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT]<2 * ROOK_VALUE)
					EvalTemp[LIGHT] += 3 * 47 * CenterManhattanDistance[Players.positions[DARK_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP]));
				else
					if (MaterialSums[DARK][MAJOR_MINOR_COUNT]<2 * ROOK_VALUE)
						EvalTemp[DARK] += 3 * 47 * CenterManhattanDistance[Players.positions[LIGHT_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP]));
		}
	}
	//*/

	if (PlySide() == LIGHT) PawnsValue = EvalTemp[LIGHT] - EvalTemp[DARK];
	else PawnsValue = EvalTemp[DARK] - EvalTemp[LIGHT];
}

#define CALC_PAWN_SCALE 1
int see_u(Colors side, Pos root_pos, int just_captured, int depth);
int CALC_SEE(Colors c, Pos root_pos, PieceSlotType exclude, int depth)
{
	Board[Players.positions[exclude]] = NO_SLOT;
	int v = -see_u(c, root_pos, 0, depth);
	Board[Players.positions[exclude]] = exclude;
	return v;
}

int CALC_SEE(Pos root_pos)
{
	PieceSlotType s = Board[root_pos];
	if (!is_piece(s)) return 0;
	return CALC_SEE(color(s), root_pos, s, INF);
}

int positive_square_value_of_piece(Colors c, PieceType p, Pos s);

int value_of_piece(Colors c, PieceType p, Pos s)
{
	return positive_square_value_of_piece( c,  p,  s)+ (CheckForEndgame ? ValuePerPiece[p] : EValuePerPiece[p])*3;
}

int value_of_piece(PieceSlotType t)
{
	return (color(t), Players.pieces[t], Players.positions[t]);
}

int value_of_piece(Pos p)
{
	return (color(Board[p]), Players.pieces[Board[p]], p);
}


int Safety(Colors c, Pos root_pos);
bool king_in_check(Colors c);
void calc_pawns()
{
	//for (int i = LIGHT;i < NUM_COLORS;++i) 
		MaterialMultiplier[LIGHT] = __max(1.0,MaterialSums[DARK][MAJOR_MINOR_COUNT] * (1.0/(QUEEN_VALUE+2*(KNIGHT_VALUE+BISHOP_VALUE+ROOK_VALUE))));
		MaterialMultiplier[DARK] = __max(1.0, MaterialSums[LIGHT][MAJOR_MINOR_COUNT] * (1.0 / (QUEEN_VALUE + 2 * (KNIGHT_VALUE + BISHOP_VALUE + ROOK_VALUE))));
		//	PawnsDirty = true;
	//for (int i = PAWN1;i < NUM_PIECE_SLOTS;++i) Players.pinned[i] = NotPinned;
	EvalTemp[LIGHT] = EvalTemp[DARK] = 0;
	if (PawnsDirty()) 
	{
		//for (int i = 0;i < 10;++i) PromotionTempo[i] = NUM_COLORS;
		PawnsTemp[LIGHT] = PawnsTemp[DARK] = 0;

		KP_END[LIGHT] = MaterialSums[LIGHT][MAJOR_MINOR_COUNT] == 0;
		KP_END[DARK] = MaterialSums[DARK][MAJOR_MINOR_COUNT] == 0;
		LowestPassed[DARK] = LowestPassed[LIGHT] = 9;
		PawnsRank[LIGHT][PAWN1] = 

		PawnsRank[LIGHT][PAWN2] = 

		PawnsRank[LIGHT][PAWN3] = 

		PawnsRank[LIGHT][PAWN4] = 

		PawnsRank[LIGHT][PAWN5] = 

		PawnsRank[LIGHT][PAWN6] = 

		PawnsRank[LIGHT][PAWN7] =

		PawnsRank[LIGHT][PAWN8] = 
//
		PawnsRank[DARK][PAWN1] = 

		PawnsRank[DARK][PAWN2] = 

		PawnsRank[DARK][PAWN3] = 

		PawnsRank[DARK][PAWN4] = 

		PawnsRank[DARK][PAWN5] = 

		PawnsRank[DARK][PAWN6] = 

		PawnsRank[DARK][PAWN7] = 

		PawnsRank[DARK][PAWN8] = 9;


#define RANK_CALC(r,c) \
		{\
			if (Players.pieces[c##_##r]!=EMPTY) { \
			const Pos pp = Players.positions[c##_##r]; \
				pawn_weight[c][r] = 2; \
				const Pos col = SquareToColIndex[pp]; \
				const Pos pr = RankCalc[c][pp]; \
				if (pr < PawnsRank[c][col]) PawnsRank[c][col] = pr; \
			} else pawn_weight[c][r] = 0;\
		}
		RANK_CALC(PAWN1,LIGHT)
		RANK_CALC(PAWN2,LIGHT)
		RANK_CALC(PAWN3, LIGHT)
		RANK_CALC(PAWN4, LIGHT)
		RANK_CALC(PAWN5, LIGHT)
		RANK_CALC(PAWN6, LIGHT)
		RANK_CALC(PAWN7, LIGHT)
		RANK_CALC(PAWN8, LIGHT)
		RANK_CALC(PAWN1, DARK)
		RANK_CALC(PAWN2, DARK)
		RANK_CALC(PAWN3, DARK)
		RANK_CALC(PAWN4, DARK)
		RANK_CALC(PAWN5, DARK)
		RANK_CALC(PAWN6, DARK)
		RANK_CALC(PAWN7, DARK)
		RANK_CALC(PAWN8, DARK)
		for (int c = LIGHT;c < NUM_COLORS;++c) {
			int base = base_by_color((Colors)c);
			int oc = other_color((Colors)c);
			int other_base = base_by_color((Colors)oc);

			// /*

			for (int r = PAWN1;r <= PAWN8;++r) {
				const Pos pp = Players.positions[r + base];
				if (pp != 0 && is_pawn(Players.pieces[r + base])) {
					const Pos pr = RankCalc[c][pp];
					const Pos col = SquareToColIndex[pp];
					Pos pos = Players.positions[base + r];

					if (PawnsRank[c][col] != pr) PawnsTemp[c] -= CALC_PAWN_SCALE * 10;//double pawn penalty
					if (PawnsRank[c][col - 1] == 9 && PawnsRank[c][col + 1] == 9) PawnsTemp[c] -= CALC_PAWN_SCALE * 20; //isolated pawn penalty
					else if (PawnsRank[c][col - 1] > pr && PawnsRank[c][col + 1] > pr) {
						PawnsTemp[c] -= CALC_PAWN_SCALE * 8;//backward pawn penalty
						pawn_weight[c][r] = 3;
					}
					if (9 - PawnsRank[oc][col - 1] <= pr && 9 - PawnsRank[oc][col] <= pr && 9 - PawnsRank[oc][col + 1] <= pr) {
						//pr is a passed pawn
						//if king can't reach pawn, then count promotion early
						pawn_weight[c][r] = 6;
						//if (KP_END[oc] && __min(5, pr - 1) < ChebyshevDistance(pp + 10 * (pr - 1)*(c == LIGHT ? -1 : 1), Players.positions[KINGP + other_base]) - (PlySide() == oc ? 1 : 0))
						//	PromotionTempo[(__min(4, pr - 2) << 1) + (PlySide() == oc ? 1 : 0)] = (Colors)c;//PawnsTemp[c] += QUEEN_VALUE-(82+30+90);
						PawnsTemp[c] += //pawn_tables[c][pp] + 9;//
							.25*((7 - pr) * 40);
						if (LowestPassed[c] > pr) LowestPassed[c] = pr;//calculate nearest passed pawn for bonus for rook on other side of passed pawn
					}
				}
			}

			//		*/
		}
		//for (int i = 0;i < 10;++i) {
		//	if (PromotionTempo[i] != NUM_COLORS) {
		//		PawnsTemp[PromotionTempo[i]] += (QUEEN_VALUE - (82 + 30 + 90))>>3;
		//		break;
		//	}
		//}
	}
	for (int c = LIGHT;c < NUM_COLORS;++c) {
		int base = base_by_color((Colors)c);
		int o = 1 - c;

		const Pos king_col = SquareToColIndex[Players.pieces[KINGP + base]];
		EvalTemp[c] += eval_king(king_col, (Colors)c, (Colors)o);

		//for (int r = PAWN1;r < NUM_UNCOLORED_PIECE_SLOTS;++r) {
		//	if (is_piece((PieceSlotType)(r + base))) {
		//		PieceType t = Players.pieces[r + base];
		//		EvalTemp[c] += (CheckForEndgame ? ValuePerPiece[t] : EValuePerPiece[t])
		//			+ positive_square_value_of_piece((Colors)c, t, Players.positions[r + base]);
		//	}
			//for (int r = PAWN1;r < NUM_UNCOLORED_PIECE_SLOTS;++r) {
			//	if (Players.pieces[base + r] != EMPTY) {
			//		EvalTemp[c] += CALC_SEE(Players.positions[base+r]);
			//	}
			//}
			//*/
		//}
		//CheckForEndgame ? ValuePerPiece[t] : EValuePerPiece[t];
//square_value_of_piece(side, slot_side, t, p);
		{
//#define KING_SAFETY
#ifdef KING_SAFETY

			Pos king_pos = Players.positions[base + KINGP];
			int units = 0;
			int ys, ye;
			if (c == LIGHT) {
				ys = -20;ye = 10;
			}
			else {
				ys = -10;ye = 20;
			}
			for (Pos x = -1;x <= 1;++x) {
				for (Pos y = ys;y <= ye;y += 10) {
					//if ((x==0 && y==0) || Board[king_pos + x + y] == EMPTY) {
						units += Safety((Colors)c, king_pos + x + y);
					//}
				}
			}
			static const int SafetyTable[100] = {
				0,  0,   1,   2,   3,   5,   7,   9,  12,  15,
				18,  22,  26,  30,  35,  39,  44,  50,  56,  62,
				68,  75,  82,  85,  89,  97, 105, 113, 122, 131,
				140, 150, 169, 180, 191, 202, 213, 225, 237, 248,
				260, 272, 283, 295, 307, 319, 330, 342, 354, 366,
				377, 389, 401, 412, 424, 436, 448, 459, 471, 483,
				494, 500, 500, 500, 500, 500, 500, 500, 500, 500,
				500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
				500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
				500, 500, 500, 500, 500, 500, 500, 500, 500, 500
			};			
			EvalTemp[c] -= SafetyTable[units]*4;
			/*
			//king_safety
			Pos king_pos = Players.positions[base + KINGP];
			int escape = 0;
			bool in_check = Threatened((Colors)c, king_pos);
			int threatened = in_check?4:0;
			int danger = 0;
			for (Pos x = -1;x <= 1;++x) {
				for (Pos y = -10;y <= 10;y+=10) {
					if (!x == 0 && y == 0) {
						if (Board[king_pos + x + y] == EMPTY) {
							if (Safety((Colors)c, king_pos + x + y,escape)) ++threatened;
							else ++escape;
						}
					}
				}
			}
			if (threatened > 0) {
				if (escape == 0) danger += (threatened<<1)+10;
				else if (escape == 1) danger += (int)(threatened*1.5);
				else danger += threatened;
			}
			if (in_check) danger += 20 / (escape + 1) + 9;
			EvalTemp[c] -= (danger+1)>>1;
		*/
#else
			EvalTemp[c] -= 2*Safety((Colors)c,Players.positions[KINGP]);
#endif
			//bonus for keeping two of rooks+queen
			const int cq = count_slot(base + QUEENP);
			const int cr = count_slot(base + ROOK1) + count_slot(base + ROOK2);
			if (cq + cr > 1) {
				EvalTemp[c] += (5 * cq + (cr << 1))*PAWN_VALUE/16;
			}
		}

		/*	int nonlinear=0;
		if (count_slot(base + QUEENP) + count_slot(base + ROOK1) + count_slot(base + ROOK2) > 1) {
		nonlinear = (5 * count_slot(base + QUEENP) + ((count_slot(base + ROOK1) + count_slot(base + ROOK2))<<1))*PAWN_VALUE>>5;
		}
		*/
		//if (PawnsDirty()) 
		{
		}
		//		if (Players.pieces[BISHOP1 + base] != EMPTY && Players.pieces[BISHOP2 + base] != EMPTY) EvalTemp[c] += 30;
		//		if (Players.pieces[KNIGHT1 + base] != EMPTY && Players.pieces[KNIGHT2 + base] != EMPTY) EvalTemp[c] += 30;
		//mobility disabled
		//NumPins[c] = calc_pins((Colors)c, Players.positions[KINGP + base], Pins[c], Pinners[c]);
					   ///*		
		//for (int j = NumPins[c] - 1;j >= 0;--j) {
		//	EvalTemp[c] -= __max(EValuePerPiece[Players.pieces[Pins[c][j]]] - (EValuePerPiece[Players.pieces[Pinners[c][j]]]>>1), 0) >> 3;
		//}
		for (int r = KNIGHT1;r <= QUEENP;++r) {
			//if (Players.pinned[r] != NotPinned) 
				EvalTemp[c] += .5*mobility((PieceSlotType)(r + base));
		}
		//outposts
#define OUTPOST
#ifdef OUTPOST
		for (int r = KNIGHT1;r <= BISHOP2;++r) {
			if (Players.pieces[base + r] != EMPTY) {
				Pos pos = Players.positions[base + r];
				int rank = RankCalc[c][pos];
				if (rank <= 7 && rank >= 5 && !is_pawn_at((Pos)(pos + UpDir[c] - 1),(Colors)o) && !is_pawn_at((Pos)(pos + UpDir[c] + 1), (Colors)o)) {
					int outpost_count = 0;
					if (is_pawn_at((Pos)(pos - UpDir[c] - 1), (Colors)c)) ++outpost_count;
					if (is_pawn_at((Pos)(pos - UpDir[c] + 1), (Colors)c)) ++outpost_count;
					switch (outpost_count) {
					case 1:
						EvalTemp[c] += 10* .7;//(80)*.02*MaterialMultiplier[c];
						break;
					case 2:
						if (r <= KNIGHT2) EvalTemp[c] += 16* .7;//.04*(80)* MaterialMultiplier[c];
						else EvalTemp[c] += 10*.7;//.03*(80) * MaterialMultiplier[c];
						break;
					}
				}
			}
		}
#endif
		//*/
	}


	for (int c = LIGHT;c < NUM_COLORS;++c) {
		int base = base_by_color((Colors)c);
		int oc = other_color((Colors)c);
		int other_base = base_by_color((Colors)oc);
		for (int r = ROOK1;r <= ROOK2;++r) {
			if (is_piece(Players.pieces[r + base])) {
				const Pos rook_pos = Players.positions[r + base];
				const Pos rook_col = SquareToColIndex[rook_pos];
				if (PawnsRank[c][rook_col] == 9)
					if (PawnsRank[oc][rook_col] == 9) EvalTemp[c] += 15;//open file
					else EvalTemp[c] += 10; //semi open
					if (RankCalc[c][rook_col] > LowestPassed[c]) EvalTemp[c] += 35 * .7;
					else if (RankCalc[c][rook_pos] == 8)EvalTemp[c] += 20 * .7;//rook attacking last row
			}
		}
	}
	///*
	//mop up should handle knights differently
	if (MaterialSums[LIGHT][PAWN_COUNT] == 0 && MaterialSums[DARK][PAWN_COUNT] == 0 &&
		Players.pieces[DARK_KNIGHT1] == EMPTY && Players.pieces[DARK_KNIGHT2] == EMPTY &&
		Players.pieces[LIGHT_KNIGHT1] == EMPTY && Players.pieces[LIGHT_KNIGHT2] == EMPTY) {
		if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] != MaterialSums[DARK][MAJOR_MINOR_COUNT]) {
			if (MaterialSums[LIGHT][MAJOR_MINOR_COUNT] > MaterialSums[DARK][MAJOR_MINOR_COUNT]) {
				if (count_slot(LIGHT_ROOK1)+ count_slot(LIGHT_ROOK1) + count_slot(LIGHT_QUEENP)<2) {
					EvalTemp[LIGHT] += (3 * 47 * CenterManhattanDistance[Players.positions[DARK_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP])));
				}
			}
			else
				if (count_slot(DARK_ROOK1) + count_slot(DARK_ROOK1) + count_slot(DARK_QUEENP)<2) {
					EvalTemp[DARK] += (3 * 47 * CenterManhattanDistance[Players.positions[LIGHT_KINGP]] + 3 * 16 * (14 - ManhattanDistance(Players.positions[DARK_KINGP], Players.positions[LIGHT_KINGP])));
				}
		}
	}

	for (int kc = LIGHT;kc < NUM_COLORS;++kc) {
		if (MaterialSums[kc][MAJOR_MINOR_COUNT] <= BISHOP_VALUE + KNIGHT_VALUE && MaterialSums[other_color((Colors)kc)][MAJOR_MINOR_COUNT] <= BISHOP_VALUE) {
			int king_base = base_by_color((Colors)kc);
			const Pos kpos = Players.positions[KINGP + king_base];
			int kp_tropism = 0;
			int pawn_count = 0;
			for (int pc = LIGHT;pc < NUM_COLORS;++pc) {
				int pawn_base = base_by_color((Colors)pc);
				for (int index = PAWN1; index <= PAWN8;++index) {
					if (pawn_weight[pc][index] != 0) {
						++pawn_count;
						kp_tropism += pawn_weight[pc][index] * ChebyshevDistance(kpos, Players.positions[index + pawn_base]);
					}
				}
			}
			if (pawn_count>0) EvalTemp[kc] -= kp_tropism/ pawn_count;
		}
	}

	//*/ scale eval

	//if (PawnsDirty()) 
		PawnsPartValue = PawnsTemp[DARK] - PawnsTemp[LIGHT];
		PawnsValue = (PawnsPartValue + (EvalTemp[DARK] - EvalTemp[LIGHT]));
		

	if (PlySide() == LIGHT) PawnsValue = -PawnsValue;
	
	clearEvalDirty();
	clearPawnsDirty();
}

int positive_square_value_of_piece(Colors c, PieceType p, Pos s)
{
	//	if (!CheckForEndgame) 
	//		return 0;
	if (!is_piece(p)) return 0;
	//{}{}{} make more efficient later
//	return (!SideInEndgame(c) ? (c == LIGHT ? SquareTableL[p][s]+sSquareTableL[p][s] : SquareTableD[p][s]+sSquareTableD[p][s]) : (c == LIGHT ? EndgameSquareTableL[p][s]+ sEndgameSquareTableL[p][s] : sEndgameSquareTableD[p][s] +EndgameSquareTableD[p][s]));
	return (!SideInEndgame(c) ? (c == LIGHT ? sSquareTableL[p][s]  : sSquareTableD[p][s] ) : (c == LIGHT ? sEndgameSquareTableL[p][s]  :  sEndgameSquareTableD[p][s]));
//	return (!SideInEndgame(c) ? (c == LIGHT ? SquareTableL[p][s] : SquareTableD[p][s]) : (c == LIGHT ? EndgameSquareTableL[p][s] : EndgameSquareTableD[p][s]));
}


inline int square_value_of_piece(Colors side, Colors c, PieceType p, Pos s)
{
	if (!is_piece(p)) return 0;
	//{}{}{} make more efficient later
	const int v = positive_square_value_of_piece(c, p, s);
	if (c == side) return v;
	return -v;
}

int sign(int i)
{
	if (i < 0) return -1;
	return 1;
}
//model 1/30 chance of a pawn being queened
//treat each pawn as an independent variable probabilty that one side will queen - probability the other side will queen
float PbTable[10][17] = {
	{//0
		-.238,
		-.211,
		-.184,
		-.156,
		-.127,
		-.0967,
		-.0656,
		-0.0333,
		0,
		0.0333,
		.0656,
		.0967,
		.127,
		.156,
		.184,
		.211,
		.238,
	},
	{//1
		0,
		-0.204,
		-.178,
		-.151,
		-.123,
		-.0935,
		-.0634,
		-.322,
		0,
		.322,
		.0634,
		.0935,
		.123,
		.151,
		.178,
		.204,
		0,
	},
	{//2k
		0,
		0,
		-.172,
		-.146,
		-.119,
		-.0904,
		-.613,
		-.0311,
		0,
		.0311,
		.0613,
		.0904,
		.119,
		.146,
		.172,
		0,
		0,
	},
	{//3
		0,
		0,
		0,
		-.141,
		-.115,
		-.0874,
		-.0592,
		-.0301,
		0,
		.0301,
		.0592,
		.0874,
		.115,
		.141,
		0,
		0,
		0,
	},
	{//4
		0,
		0,
		0,
		0,
		-.111,
		-.0844,
		-.0572,
		-.0291,
		0,
		.0291,
		.0572,
		.0844,
		.111,
		0,
		0,
		0,
		0,
	},
	{//5
		0,
		0,
		0,
		0,
		0,
		-.0816,
		-.0553,
		-.0281,
		0,
		.0281,
		.0553,
		.0816,
		0,
		0,
		0,
		0,
		0,
	},
	{//6
		0,
		0,
		0,
		0,
		0,
		0,
		-.0534,
		-.0272,
		0,
		.0272,
		.0534,
		0,
		0,
		0,
		0,
		0,
		0,
	},
	{//6
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		-.0263,
		0,
		.0263,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	},
	{//7
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	},
	{//8
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	}, };

inline int pawn_balance(Colors c)
{
	int pv;
	float qv;
	if (CheckForEndgame) {
		pv = (int)(PAWN_VALUE*.95);
		qv = (QUEEN_VALUE*.2);
	}
	else {
		pv = (int)(EPAWN_VALUE*.95);
		qv = (EQUEEN_VALUE);
	}
	int d = MaterialSums[c][PAWN_COUNT] - MaterialSums[other_color(c)][PAWN_COUNT];
	int base = base_by_color(c);
	int other_base = base_by_color(other_color(c));
	if (d > 0) {
		float interference = MaterialSums[other_color(c)][MAJOR_MINOR_COUNT] * (1.0 / ROOK_VALUE);
		float help = MaterialSums[c][MAJOR_MINOR_COUNT] * (.5 / ROOK_VALUE);
		qv = qv / interference*__min(help, interference);
	}
	else if (d < 0) {
		float interference = MaterialSums[c][MAJOR_MINOR_COUNT] * (1.0 / ROOK_VALUE);
		float help = MaterialSums[other_color(c)][MAJOR_MINOR_COUNT] * (.5 / ROOK_VALUE);
		qv = qv / interference*__min(help, interference);
	}
	int nonlinear = 0;
	if (count_slot(base + QUEENP) + count_slot(base + ROOK1) + count_slot(base + ROOK2) > 1) {
		nonlinear = (5 * count_slot(base + QUEENP) + ((count_slot(base + ROOK1) + count_slot(base + ROOK2)) << 1))*PAWN_VALUE >> 5;
	}
	if (count_slot(other_base + QUEENP) + count_slot(other_base + ROOK1) + count_slot(other_base + ROOK2) > 1) {
		nonlinear -= (5 * count_slot(other_base + QUEENP) + ((count_slot(other_base + ROOK1) + count_slot(other_base + ROOK2)) << 1))*PAWN_VALUE >> 5;
	}
	int m = __min(MaterialSums[c][PAWN_COUNT], MaterialSums[other_color(c)][PAWN_COUNT]);
	return pv*d + (int)qv*PbTable[m][d + 8] + (int)nonlinear;
}

inline int eval()
{
	//	if (CheckForEndgame) 
	//		return simple_eval();

	if (EvalDirty()) //|| PawnsDirty()) //simple_calc();
		calc_pawns();
	const Colors o = other_color(_PlySide);
	const int material_count = //pawn_balance(_PlySide)+
		MaterialSums[_PlySide][PAWN_COUNT] - MaterialSums[o][PAWN_COUNT] +
		MaterialSums[_PlySide][DONT_COUNT] + MaterialSums[_PlySide][MAJOR_MINOR_COUNT] - MaterialSums[o][MAJOR_MINOR_COUNT] - MaterialSums[o][DONT_COUNT];
	return  material_count +
		PersistantValue + EphemeralValue +PawnsValue;
}

inline int simple_eval()
{
	//if (!PawnsDirty) return eval();
	//	if (EvalDirty) simple_calc();
	const Colors o = other_color(_PlySide);
	const int material_count = //pawn_balance(_PlySide)+
		MaterialSums[_PlySide][PAWN_COUNT] - MaterialSums[o][PAWN_COUNT] +
		MaterialSums[_PlySide][DONT_COUNT] + MaterialSums[_PlySide][MAJOR_MINOR_COUNT] - MaterialSums[o][MAJOR_MINOR_COUNT] - MaterialSums[o][DONT_COUNT];
	return  material_count +
		PersistantValue + EphemeralValue;// +PawnsValue;
}


inline int eval(Colors c)
{
	if (PlySide() == c) return eval();
	return -eval();
}
/*enum PieceType : signed char {
EMPTY = 0,
KING_NOT_MOVED = 1,
KING = 2,
KING_CASTLED = 3,
PAWN = 4,
PAWN_JUST_ADVANCED = 5,
KNIGHT = 6,
BISHOP = 7,
ROOK_NOT_MOVED = 8,
ROOK = 9,
QUEEN = 10,
NUM_PIECE_TYPES = 11,
};
*/
const bool IsSufficient[NUM_PIECE_TYPES] =
{
	false,//empty
	false,false,//king
	true,true,//pawn
	false,false,//knight, bishop
	true,true,//rook
	true //queen
};
const bool IsMinor[NUM_PIECE_TYPES] =
{
	false,//empty
	false,false,//king
	false,false,//pawn
	true,true,//knight, bishop
	false,false,//rook
	false //queen
};

int SufficientPieces;
int MinorPieces[NUM_COLORS];


inline void add_value(Colors side, PieceSlotType s)
{
	const Pos p = Players.positions[s];
	const PieceType t = Players.pieces[s];
	const Colors slot_side = color(s);

	SufficientPieces += IsSufficient[t] ? 1 : 0;
	MinorPieces[slot_side] += IsMinor[t];
	//	if (PieceCountIndex[t] == PAWN_COUNT) ++MaterialSums[slot_side][PAWN_COUNT];
	//	else
	MaterialSums[slot_side][PieceCountIndex[t]] += CheckForEndgame ? ValuePerPiece[t] : EValuePerPiece[t];

	PersistantValue += square_value_of_piece(side, slot_side, t, p);
	update_hash(s);
}
inline void sub_value(Colors side, PieceSlotType s)
{
	const Pos p = Players.positions[s];
	const PieceType t = Players.pieces[s];
	const Colors slot_side = color(s);

	SufficientPieces -= IsSufficient[t] ? 1 : 0;
	MinorPieces[slot_side] -= IsMinor[t];
	//	if (PieceCountIndex[t] == PAWN_COUNT) --MaterialSums[slot_side][PAWN_COUNT];
	//	else	
	MaterialSums[slot_side][PieceCountIndex[t]] -= CheckForEndgame ? ValuePerPiece[t] : EValuePerPiece[t];

	PersistantValue -= square_value_of_piece(side, slot_side, t, p);
	update_hash(s);
}

Move::Move(Pos f, Pos t PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became((PieceType)ChangePieceOnMove[initial]),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
move_flags(NotCastling),
//see(0),
bonus(SHORTINF)
INITLINE
{
	//	assert(t!=h1);//find bug
	massert(Board[f] != OFF_BOARD);
	massert(Board[f] != NO_SLOT);
	massert(slot_taken == NO_SLOT || color(slot_taken) != color(Board[f]));
	massert(slot_taken == NO_SLOT || Players.pieces[slot_taken] != EMPTY);
}

//assume that c is CastleLeft or CastleRight
Move::Move(Pos f, Pos t, MoveFlags c PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became((PieceType)ChangePieceOnMove[initial]),
slot_taken(NO_SLOT),
piece_taken(EMPTY),
move_flags(c),
//see(0),
bonus(SHORTINF)
INITLINE
{
	if (initial == KING_NOT_MOVED) became = KING_CASTLED;
}

Move::Move(Pos f, Pos t, PieceType type PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became(type),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
move_flags(NotCastling),
//see(0),
bonus(SHORTINF)
INITLINE
{
	massert(color(Board[f]) != OFF_BOARD);
	massert(color(Board[f]) != NO_SLOT);
	massert(slot_taken == NO_SLOT || color(slot_taken) != color(Board[f]) || from == to);
}

Move::Move(Pos f, Pos t, Pos enpassant_pos, CheckForEnpassantEnum PARAMLINE) :from(f),
to(t),
taken_at(enpassant_pos),
initial(Players.pieces[Board[f]]),
became(ChangePieceOnMove[initial]),
slot_taken(Board[enpassant_pos]),
piece_taken(Players.pieces[Board[enpassant_pos]]),
move_flags(NotCastling),
//see(0),
bonus(SHORTINF)
INITLINE
{
}

//from other player

Move::Move(Pos f, Pos t, CheckForEnpassantEnum PARAMLINE) :from(f),
to(t),
taken_at(t),
initial(Players.pieces[Board[f]]),
became(ChangePieceOnMove[initial]),
slot_taken(Board[t]),
piece_taken(Players.pieces[slot_taken]),
move_flags(NotCastling),
//see(0),
bonus(SHORTINF)
INITLINE
{
	if (initial == KING_NOT_MOVED && color(Board[f]) == LIGHT)
	{
		if (to == c1) move_flags = CastleLeft;
		else if (to == g1) move_flags = CastleRight;
		became = KING_CASTLED;
	}
	else if (initial == KING_NOT_MOVED && color(Board[f]) == DARK)
	{
		if (to == c8) move_flags = CastleLeft;
		else if (to == g8) move_flags = CastleRight;
		became = KING_CASTLED;
	}
	if (initial == PAWN || initial == PAWN_JUST_ADVANCED) {
		if (abs(to - from) == 20)
			*this = Move(from, to, PAWN_JUST_ADVANCED ATLINE);
		else if (abs(to - from) != 10 && Board[to] == NO_SLOT)
			*this = Move(from, to, from + (abs(to - from) - 10)*sign(to - from), Move::DoEnpassant ATLINE);
	}

}

Move::Move(const Move &m) :
	from(m.from),
	to(m.to),
	taken_at(m.taken_at),
	initial(m.initial),
	became(m.became),
	slot_taken(m.slot_taken),
	piece_taken(m.piece_taken),
	move_flags(m.move_flags),
	//see(m.see),
	bonus(m.bonus)
	//,hash(m.hash)
	COPYLINE
{}
void Move::operator = (const Move &m)
{
	from = m.from;
	to = m.to;
	taken_at = m.taken_at;
	initial = m.initial;
	became = m.became;
	slot_taken = m.slot_taken;
	piece_taken = m.piece_taken;
	move_flags = m.move_flags;
	//see = m.see;
	bonus = m.bonus;
	//hash = m.hash;
	SETLINE
}
Move::Move(Move &&m) :from(std::move(m.from)),
to(std::move(m.to)),
taken_at(std::move(m.taken_at)),
initial(std::move(m.initial)),
became(std::move(m.became)),
slot_taken(std::move(m.slot_taken)),
piece_taken(std::move(m.piece_taken)),
move_flags(std::move(m.move_flags)),
//see(std::move(m.see)),
bonus(std::move(m.bonus))
//,hash(std::move(m.hash))
COPYLINE
{}

void Move::make()
{
	//	hash = Hash;
	massert(!empty());
	massert(slot_taken == NO_SLOT || Players.pieces[slot_taken] != EMPTY);
	//board_consistent();
	if (empty()) return;

	//	if (taken_at != to) {
	//		printf("move %s to %s taking at %s\n", PosToStandard[from], PosToStandard[to], PosToStandard[taken_at]);
	//	}
	///*
	if (MoveNumber + history_len > 1
		&& Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] == PAWN_JUST_ADVANCED) {
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] = PAWN;
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		//		cout << "- "<< MoveNumber + history_len - 2<<" " <<PosToStandard[En_passant_history[MoveNumber + history_len - 2]];
		//board_consistent();
	}
	//*/
	if (became == PAWN_JUST_ADVANCED) {
		En_passant_history[MoveNumber + history_len] = to;
		En_passant_colors_history[MoveNumber + history_len] = color(Board[to]);

		//		cout << "* "<< MoveNumber + history_len << " " <<PosToStandard[to];
	}
	else En_passant_history[MoveNumber + history_len] = 0;

	const PieceSlotType slot_moving = Board[from];
	movement_bonuses();
	add_bonus(color(slot_moving), bonus*.25);
	Colors side = PlySide();//color(slot_moving);
							//	if (not_move()) {
							//		sub_value(side,slot_moving);
							//		Players.pieces[Board[from]]= became; //Players.pieces[Board()[from]] = became;
							//		add_value(side,slot_moving);
							//		piece_threats(color(became));
							//		RepeatList.add();
							//		return;
							//	}
	sub_value(side, slot_moving);
	sub_value(side, slot_taken);
	switch (move_flags) {
	case CastleLeft:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK1);
			Players.pieces[LIGHT_ROOK1] = ROOK;
			set_position(d1, LIGHT_ROOK1);
			Board[a1] = NO_SLOT;
			add_value(side, LIGHT_ROOK1);
			//board_consistent();
		}
		else {
			sub_value(side, DARK_ROOK1);
			Players.pieces[DARK_ROOK1] = ROOK;
			set_position(d8, DARK_ROOK1);
			Board[a8] = NO_SLOT;
			add_value(side, DARK_ROOK1);
			//board_consistent();
		}
		break;
	case CastleRight:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK2);
			Players.pieces[LIGHT_ROOK2] = ROOK;
			set_position(f1, LIGHT_ROOK2);
			Board[h1] = NO_SLOT;
			add_value(side, LIGHT_ROOK2);
			//board_consistent();
		}
		else {
			sub_value(side, DARK_ROOK2);
			Players.pieces[DARK_ROOK2] = ROOK;
			set_position(f8, DARK_ROOK2);
			Board[h8] = NO_SLOT;
			add_value(side, DARK_ROOK2);
			//board_consistent();
		}
		break;
	}
	Players.pieces[slot_moving] = became;
	set_position(to, slot_moving);
	if (taken_at != to) {
		//Players.en_passant[slot_taken] = MoveNumber+history_len+1;
		Board[taken_at] = NO_SLOT;
	}
	Players.pieces[slot_taken] = EMPTY;
	Players.positions[slot_taken] = 0;
	//Board()[to] = slot_moving;
	Board[from] = NO_SLOT;
	add_value(side, slot_moving);
	//	piece_threats();
	//	board_consistent();
	if (is_pawn(initial) || is_pawn(piece_taken))
		incPawnsDirty();
	incEvalDirty();

	RepeatList.add(color(slot_moving));
	//board_consistent();
}

void Move::unmake()
{
	//board_consistent();
	if (empty()) return;
	RepeatList.remove();

	const PieceSlotType slot_moving = Board[to];
	Colors side = PlySide();//color(slot_moving);
	add_bonus(color(slot_moving), -.25*bonus);

	//	if (not_move()) {
	//		sub_value(side,slot_moving);
	//		Players.pieces[slot_moving] = initial;
	//		add_value(side, slot_moving);
	//		RepeatList.remove();
	//		return;
	//	}
	sub_value(side, slot_moving);
	Board[to] = NO_SLOT;
	Players.pieces[slot_taken] = piece_taken;
	set_position(taken_at, slot_taken);
	set_position(from, slot_moving);
	Players.pieces[slot_moving] = initial;
	//Players.positions[slot_moving] = from;
	add_value(side, slot_moving);
	add_value(side, slot_taken);
	switch (move_flags) {
	case CastleLeft:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK1);
			Players.pieces[LIGHT_ROOK1] = ROOK_NOT_MOVED;
			Players.positions[LIGHT_ROOK1] = a1;
			Board[a1] = LIGHT_ROOK1;
			Board[d1] = NO_SLOT;
			add_value(side, LIGHT_ROOK1);
		}
		else {
			sub_value(side, DARK_ROOK1);
			Players.pieces[DARK_ROOK1] = ROOK_NOT_MOVED;
			Players.positions[DARK_ROOK1] = a8;
			Board[a8] = DARK_ROOK1;
			Board[d8] = NO_SLOT;
			add_value(side, DARK_ROOK1);
		}
		break;
	case CastleRight:
		if (color(slot_moving) == LIGHT) {
			sub_value(side, LIGHT_ROOK2);
			Players.pieces[LIGHT_ROOK2] = ROOK_NOT_MOVED;
			Players.positions[LIGHT_ROOK2] = h1;
			Board[h1] = LIGHT_ROOK2;
			Board[f1] = NO_SLOT;
			add_value(side, LIGHT_ROOK2);
		}
		else {
			sub_value(side, DARK_ROOK2);
			Players.pieces[DARK_ROOK2] = ROOK_NOT_MOVED;
			Players.positions[DARK_ROOK2] = h8;
			Board[h8] = DARK_ROOK2;
			Board[f8] = NO_SLOT;
			add_value(side, DARK_ROOK2);
		}
		break;
	}
	///*
	if (MoveNumber + history_len > 1
		&& Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] == PAWN
		&& En_passant_colors_history[MoveNumber + history_len - 2] == color(Board[En_passant_history[MoveNumber + history_len - 2]])) {
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		Players.pieces[Board[En_passant_history[MoveNumber + history_len - 2]]] = PAWN_JUST_ADVANCED;
		update_hash(Board[En_passant_history[MoveNumber + history_len - 2]]);
		//		cout << "+ " << MoveNumber + history_len - 2 << " " << PosToStandard[En_passant_history[MoveNumber + history_len - 2]];
	}
	//*/
	//	assert(hash == Hash);
	if (is_pawn(initial) || is_pawn(piece_taken)) 
		decPawnsDirty();
	decEvalDirty();
	//board_consistent();
}


bool king_moved(Colors c)
{
	const PieceSlotType king = (PieceSlotType)(base_by_color(c) + KINGP);
	return Players.pieces[king] != KING_NOT_MOVED;
}

bool left_rook_moved(Colors c)
{
	const PieceSlotType rook = (PieceSlotType)(base_by_color(c) + ROOK1);
	return Players.pieces[rook] != ROOK_NOT_MOVED;
}

bool right_rook_moved(Colors c)
{
	const PieceSlotType rook = (PieceSlotType)(base_by_color(c) + ROOK2);
	return Players.pieces[rook] != ROOK_NOT_MOVED;
}

bool can_castle_left(Colors c)
{
	const Pos * r = HomeRow[c];
	return 	!king_moved(c) && !left_rook_moved(c) && NO_SLOT == Board[r[2 - 1]] && NO_SLOT == Board[r[3 - 1]] && NO_SLOT == Board[r[4 - 1]]
		&& 0 == Threatened(c, r[3 - 1]) && 0 == Threatened(c, r[4 - 1]) && 0 == Threatened(c, r[5 - 1]);
}

bool can_castle_right(Colors c)
{
	const Pos * r = HomeRow[c];
	return !king_moved(c) && !right_rook_moved(c) && NO_SLOT == Board[r[6 - 1]] && NO_SLOT == Board[r[7 - 1]]
		&& 0 == Threatened(c, r[7 - 1]) && 0 == Threatened(c, r[6 - 1]) && 0 == Threatened(c, r[5 - 1]);
}

void clear_board()
{
	for (int i = 0;i < 20;++i) Board[i] = Board[100 + i] = OFF_BOARD;
	for (int i = 20;i < 100;i += 10) Board[i] = Board[9 + i] = OFF_BOARD;
	for (int j = 20;j < 100;j += 10) for (int i = 1;i < 9;++i) Board[j + i] = NO_SLOT;
}

int EndGamePoint = -1;

//median of the value of the last 4 moves - used to detect drops in value and use extra time
int fg[4] = { 0,0,0,0 };
int fg_index = 0;
int first_guess()
{
	int big = -INF;
	int little = INF;
	for (int i = 0;i < 4;++i) {
		if (big < fg[i]) big = fg[i];
		if (little > fg[i]) little = fg[i];
	}

	return (fg[0] + fg[1] + fg[2] + fg[3] - big - little) >> 1;
}
void add_first_guess(int i)
{
	fg[fg_index] = i;
	fg_index = (fg_index + 1) & 3;
}
void set_first_guess(int i)
{
	for (int i = 0;i < 4;++i) fg[i] = i;
}

int firstguess = 0;

int Ply0Alpha = 0;

int BestMovePerPlyIndex[MAX_PLY];

RelativeMove BestMovePerPly[8][MAX_PLY];

long long FailHighCount;
long long FailHighTotal;

void init_board()
{
	FailHighCount = 0;
	FailHighTotal = 0;

	for (int i = 0;i < MAX_PLY;++i) {
		for (int j = 0;j < 4; ++j) {
			//			CaptureKillers.BestMovePerPly[j][i].clear();
			BestMovePerPly[j][i].clear();
		}
		//		CaptureKillers.BestMovePerPlyIndex[i] = 0;
		BestMovePerPlyIndex[i] = 0;
	}
	MinorPieces[LIGHT] = MinorPieces[DARK] = 2;
	SufficientPieces = 8 * 2 + 2 + 4;
	for (int c = 0;c<NUM_COLORS;++c) for (int i = 0;i<NUM_MATERIAL_INDEXES;++i) MaterialSums[c][i] = 0;
	PawnsValue = 0;
	resetPawnsDirty();
	resetEvalDirty();
	for (int i = 0;i < MAX_MOVES + MAX_PLY;++i) {
		En_passant_history[i] = 0;
		En_passant_colors_history[i] = NO_COLOR;
	}
	firstguess = 0;
	Ply0Alpha = 0;
	Promotions.clear();
	KingThreats.clear();
	Captures.clear();
	VanillaMoves.clear();
	MovesOrdered.clear();
	MovesIID.clear();

	set_first_guess(0);
	ClearHash += MAX_MOVES * 2;
	RepeatList.clear();
	FakeLen = 0;
	EndGamePoint = -1;
	clear_board();
	for (int i = 0;i<NUM_PIECE_SLOTS;++i) {
		Players.pieces[i] = Initial_Pieces[i];
		const Pos pos = Players.positions[i] = Initial_Pos[i];
		Board[pos] = (PieceSlotType)i;
	}
	Players.pieces[NO_SLOT] = Players.pieces[OFF_BOARD] = EMPTY;
	Players.positions[NO_SLOT] = Players.positions[OFF_BOARD] = 0;
	_PlySide = LIGHT;
	CheckForEndgame = true;
	CurrentPly = 0;
	MovesOrdered.clear();
	DisableBook = false;
	PersistantValue = 0;
	EphemeralValue = 0;
	history_len = 0;
	Hash.clear();
	for (Pos i = a8;i <= h1;++i) if (is_piece(i)) add_value(LIGHT, Board[i]);
}

#include <sys/timeb.h>
int ftime_ok;
int millis() //needs different implementation for arduino
{
	struct timeb timebuffer;
	ftime(&timebuffer);
	if (timebuffer.millitm != 0)
		ftime_ok = 1;
	return (timebuffer.time * 1000) + timebuffer.millitm;
}

int StopTime;
int Nodes = 0;
int MidNodes = 0;

int get_ms()
{
	return millis();
}

bool TimedOut = false;
enum  OutOfTimeException { OutOfTime };

bool test_extend_time(int);

//used to be !pv[0][0].empty()

Move pv[MAX_PLY];
int pv_length = 0;
Move Ply0Move;
bool has_a_first_move()
{
	return !Ply0Move.empty();
}

void checkup()
{
	/* is the engine's time up? if so, longjmp back to the
	beginning of think() */
#ifndef DISABLE_TIME
	if (has_a_first_move() && get_ms() >= StopTime) {
		if (test_extend_time(Ply0Alpha)) {
			LOG(Log << "t+\n");
			return;
		}
		TimedOut = true;
		LOG(Log << "Out of time at Ply " << CurrentPly << endl);

		throw OutOfTime;
	}
#endif
}

void GenMoves(Colors c, int val, int depth);
void set_side(Colors s);
bool king_in_check(Colors c);

bool parse_move(Move &m, char *s)
{

	/* make sure the string looks like a move */
	if (s[0] < 'a' || s[0] > 'h' ||
		s[1] < '0' || s[1] > '9' ||
		s[2] < 'a' || s[2] > 'h' ||
		s[3] < '0' || s[3] > '9')
		return false;
	Pos from = s[0] - 'a' + 1 + 10 * (10 - (s[1] - '0'));
	Pos to = s[2] - 'a' + 1 + 10 * (10 - (s[3] - '0'));
	PieceType became = EMPTY;
	int became_char = 4;
	if (s[4] == '=') ++became_char;
	switch (s[became_char]) {
	case 'N':
	case 'n':
		became = KNIGHT;
		break;
	case 'B':
	case 'b':
		became = BISHOP;
		break;
	case 'R':
	case 'r':
		became = ROOK;
		break;
	case 'Q':
	case 'q':
		became = QUEEN;
		break;
	default:
		if (is_pawn(Players.pieces[Board[from]])) {
			if (to <= h8) became = QUEEN;
			else if (to >= a1) became = QUEEN;
		}
	}
	/*
	Move move((Pos)(s[0] - 'a' + 1 + 10 * (10 - (s[1] - '0'))),
	(Pos)(s[2] - 'a' + 1 + 10 * (10 - (s[3] - '0'))), Move::CheckForEnpassant ATLINE);
	switch (s[4]) {
	case 'N':
	case 'n':
	move.became = KNIGHT;
	break;
	case 'B':
	case 'b':
	move.became = BISHOP;
	break;
	case 'R':
	case 'r':
	move.became = ROOK;
	break;
	case 'Q':
	case 'q':
	move.became = QUEEN;
	break;
	default:
	if (move.became == PAWN) {
	if (move.to <= h8) move.became = QUEEN;
	}
	else if (move.became == PAWN) {
	if (move.to >= a1) move.became = QUEEN;
	}
	}
	*/
	//	set_side(other_color(PlySide()));
	GenMoves(PlySide(), 0, 1);
	m.clear();

	while (!MovesOrdered.empty()) {
		MovesOrdered.back().make();
		if (king_in_check(PlySide())) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			MovesOrdered.pop();
			continue;
		}
		if (became == EMPTY) {
			if (MovesOrdered.back().from == from && MovesOrdered.back().to == to)
				m = MovesOrdered.back();
		}
		else {
			if (became == MovesOrdered.back().became && MovesOrdered.back().from == from && MovesOrdered.back().to == to)
				m = MovesOrdered.back();
		}
		MovesOrdered.back().unmake();
		MovesOrdered.pop();
	}

	return !m.empty();
}

const char *move_str(const Move &m)
{
	static char str[6];

	if (m.empty()) return "";

	char c;

	if (m.became != (PieceType)ChangePieceOnMove[m.initial] && m.became != PAWN_JUST_ADVANCED && m.became != KING_CASTLED) {
		if (color(Board[m.from]) == LIGHT) {
			switch (m.became) {
			case KNIGHT:
				c = 'N';
				break;
			case BISHOP:
				c = 'B';
				break;
			case ROOK:
				c = 'R';
				break;
			case QUEEN:
				c = 'Q';
				break;
			default:
				c = '?';//we shouldn't get here
			}
		}
		else {
			switch (m.became) {
			case KNIGHT:
				c = 'n';
				break;
			case BISHOP:
				c = 'b';
				break;
			case ROOK:
				c = 'r';
				break;
			case QUEEN:
				c = 'q';
				break;
			default:
				c = '?';//we shouldn't get here
			}
		}
		massert(m.from <= h1 && m.from >= a8);
		massert(Board[m.from] != OFF_BOARD);
		massert(m.to <= h1 && m.to >= a8);
		massert(Board[m.to] != OFF_BOARD);

		sprintf(str, "%s%s%c",
			PosToStandard[m.from],
			PosToStandard[m.to],
			c);
	}
	else
		sprintf(str, "%s%s",
			PosToStandard[m.from],
			PosToStandard[m.to]);
	return str;
}
#ifdef LOGGING
void log_board()
{
	int i;

	Log << "\n/*";
	for (int row = 0;row < 80;row += 10) {
		Log << "\n" << 8 - row / 10 << " ";
		for (int col = a8; col <= h8; ++col) {
			if (Board[row + col] == NO_SLOT) Log << " . ";
			else Log << ' ' << piece_char(color(Board[row + col]), Players.pieces[Board[row + col]]) << piece_char2(Players.pieces[Board[row + col]]);
		}
	}
	Log << "\n   a  b  c  d  e  f  g  h\n*/\n";

	Log << "int board_init[BOARD_SIZE]\n{\n";
	for (int i = 0;i < BOARD_SIZE;++i) Log << (int)Board[i] << ",";
	Log << "\n};\n";
	Log << "int players_init[NUM_PIECE_SLOTS]\n{\n";
	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Log << (int)Players.pieces[i] << ",";
	Log << "\n};\n";

	Log.flush();
}
#else
void log_board()
{

}
#endif

void print_board()
{
	int i;

	printf("\n ");
	for (int row = 0;row < 80;row += 10) {
		printf("\n%d ", 8 - row / 10);
		for (int col = a8; col <= h8; ++col) {
			if (Board[row + col] == NO_SLOT) printf(" . ");
			else printf(" %c%c", piece_char(color(Board[row + col]), Players.pieces[Board[row + col]]), piece_char2(Players.pieces[Board[row + col]]));
		}
	}
	printf("\n\n   a  b  c  d  e  f  g  h\n\n");
}

//add c as color of sliding piece
//add value as value of sliding piece


#define CPOINT(direction,inc) \
	if (Board[root_pos+direction] != NO_SLOT) count+=inc;

#define CSLIDE(direction,inc) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] != NO_SLOT) break; \
	count+=inc;\
	continue; \
} while (true)


#define TSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (expanding != target) { \
		if (Board[expanding] != NO_SLOT) break; \
		continue; \
	}\
	if (Board[expanding] == NO_SLOT) { \
		return Move(root_pos,expanding ATLINE);\
	}\
	if (color(Board[expanding]) != c) \
		return Move(root_pos,expanding ATLINE);\
	break; \
} while (true)


#define HASH_LEN_LN2 23

const int HASH_LEN = 1 << HASH_LEN_LN2;
const int HASH_MASK = HASH_LEN - 1;

struct HashMove
{
	Pos from;
	Pos to;
	PieceType became;
	MoveFlags move_flags;
	HashMove() { clear(); }
	HashMove(const Move & m) :from(m.from), to(m.to), became(m.became), move_flags(m.move_flags){}
	HashMove(const RelativeMove &m) :from(m.from_pos), to(m.to), became(m.promotion),move_flags(m.move_flags) {}
	void operator = (const RelativeMove &m) {
		from = m.from_pos;
		to = m.to;
		became = m.promotion;
		move_flags = m.move_flags;
	}
	void operator = (const Move &m) {
		from = m.from;
		to = m.to;
		became = m.became;
		move_flags = m.move_flags;
	}
	void clear()
	{
		from = 0;
	}
	bool empty() const
	{
		return from == 0;
	}
};

class HashTableEntry
{


public:
	int get_lower(int depth)
	{
		if (lower_bound_depth >= depth)
			return lower_bound;
		return -INF;
	}
	int get_upper(int depth)
	{
		if (upper_bound_depth >= depth)
			return upper_bound;
		return INF;
	}
	void set_lower(int depth, int lower)
	{
		if (lower_bound_depth <= depth) {
			lower_bound = lower;
			lower_bound_depth = depth;
		}
	}
	void set_upper(int depth, int upper)
	{
		if (upper_bound_depth <= depth) {
			upper_bound = upper;
			upper_bound_depth = depth;
		}
	}
	void set_move(Move &m, int d)
	{
		move_depth = d;
		move = m;
	}

	void set_move(RelativeMove &m, int d)
	{
		move_depth = d;
		move = m;
	}
	HashMove & get_move()
	{
		return move;
	}
	int get_move_depth()
	{
		return move_depth;
	}
	void clear()
	{
		upper_bound_depth = lower_bound_depth = -127;
		move.clear();
		second_move.clear();
		eval_copy = INF;
		upper_exact = lower_exact = false;
	}
	bool is_exact() { return upper_exact || lower_exact; }

	int get_eval(bool simple)
	{
		if (upper_exact) {
			if (lower_exact) {
				if (upper_bound_depth > lower_bound_depth) return upper_bound;
				return lower_bound;
			}
		}
		if (lower_exact) return lower_bound;
		if (simple && upper_bound_depth != -127 && abs(upper_bound - lower_bound) < PAWN_VALUE >> 1) return  lower_bound;
		if (eval_copy != INF) return eval_copy;
		if (simple) return simple_eval();
		//		if (lower_bound_depth != -127) return lower_bound;
		//		if (upper_bound_depth == lower_bound_depth) return upper_bound;
		//		if (lower_bound_depth != -127) return lower_bound;//(upper_bound + lower_bound) >> 1;

		//		if (eval_copy == INF) 
		eval_copy = eval();
		return eval_copy;
	}
	HashTableEntry() : move_created(0) { }
	HashType key;

	bool upper_exact;
	bool lower_exact;
	int upper_bound;
	int lower_bound;
	int eval_copy;
	char upper_bound_depth;
	char lower_bound_depth;
	char move_depth;
	int move_created;
	HashMove move;
	HashMove second_move;
};


HashTableEntry *HashTable;//[HASH_LEN];
void init_hash()
{
	HashTable = new HashTableEntry[HASH_LEN];
	if (HashTable == nullptr) cout << "\nAllocation failed\n";
}

HashTableEntry * GetHash(bool q)
{
//	const int hoff = q ? HASH_LEN : 0;
	HashTableEntry * entry = &HashTable[((int)(Hash.low) & HASH_MASK)], *entry2;
	if ((history_len + ClearHash) - entry->move_created < MAX_MOVES  &&
		entry->key == Hash) return entry;

	entry2 = &HashTable[((int)Hash.high_mask() & HASH_MASK)];
	if ((history_len + ClearHash) - entry->move_created < MAX_MOVES &&
		entry2->key == Hash) return entry2;

	return nullptr;
}

int get_order_eval(bool &is_score, Colors c, int depth)
{
	HashTableEntry *e = nullptr;
	if (depth >= 0) e = GetHash(false);
	if (e != nullptr) {
		if (e->lower_bound_depth != -127 && e->upper_bound_depth != -127) {
			is_score = true;
			return -(e->lower_bound + e->upper_bound) >> 1;
		}
	}
	HashTableEntry *eq = nullptr;
	if (depth <= 1) eq = GetHash(true);
	if (eq != nullptr) {
		if (eq->lower_bound_depth != -127 && eq->upper_bound_depth != -127) {
			is_score = true;
			return -(eq->lower_bound + eq->upper_bound) >> 1;
		}
	}
	is_score = false;
	return 0;
}

HashTableEntry * GetOrMakeHash(bool q)
{
	//const int hoff = q ? HASH_LEN : 0;
	HashTableEntry * entry = &HashTable[((int)(Hash.low) & HASH_MASK)], *entry2;
	if ((history_len + ClearHash) - entry->move_created < MAX_MOVES &&
		entry->key == Hash) {
		entry->move_created = history_len + ClearHash;
		return entry;
	}
	entry2 = &HashTable[((int)Hash.high_mask() & HASH_MASK)];
	if ((history_len + ClearHash) - entry->move_created < MAX_MOVES &&
		entry2->key == Hash) {
		entry2->move_created = history_len + ClearHash;
		return entry2;
	}
	if ((history_len + ClearHash) - entry->move_created < MAX_MOVES) {
		if ((history_len + ClearHash) - entry->move_created >= MAX_MOVES) entry = entry2;
		else if (entry->move_created > entry2->move_created) entry = entry2;
		else if (!entry2->is_exact() && entry->is_exact()) entry = entry2;
		else if (entry2->is_exact() == entry->is_exact() && entry2->get_move_depth() < entry->get_move_depth()) entry = entry2;
	}
	entry->key = Hash;
	entry->clear();
	entry->move_created = history_len + ClearHash;

	return entry;
}

bool inc_ply();
bool dec_ply();

int QUIESCENT_DEPTH;

bool order_value(int &result, Colors c, Move &m, int depth)
{
	//	result = 0;
	//	return false;
	m.make();
	//int get_order_eval(bool &is_score, Colors c)
	//	set_PlySide(other_color(PlySide()));
	bool found = false;
	if (depth < 4 - QUIESCENT_DEPTH) result = 0;
	else result = get_order_eval(found, c, depth) << 9;
	m.unmake();
	return found;
}

#define LAST_MOVED_BONUS KING_VALUE
#define GENERATE_TO MovesOrdered


#define IID_NUM 3

//#define CAP_SCALE(x,y) (((x)<<10)-(y))

//#define CAP_SCALE(x,y) (((int)(x)<<10)-((y)>>1))
#define CAP_SCALE(x,y) ((int)(x)<<10)
bool ThreatenedExcluding(Colors o, Pos root_pos, PieceSlotType exclude);
int SEE(Colors c, Pos root_pos, PieceSlotType exclude, int depth);
//#define COUNTER(c,expanding,attacker,value) (depth<=IID_NUM?-SEE(c,expanding,attacker,INF):0)
//#define COUNTER(c,expanding,attacker,value) (ValuePerPiece[Players.pieces[Board[expanding]]]+ (ValuePerPiece[Players.pieces[Board[expanding]]]>=(value<<2)?0:SEE(c,expanding,attacker,INF)))

//#define COUNTER(c,expanding,attacker,value) (ValuePerPiece[Players.pieces[Board[expanding]]]+SEE(c,expanding,attacker,INF)-square_value-positive_square_value_of_piece(other_color(c), Players.pieces[Board[expanding]], expanding))
#define COUNTER(c,expanding,attacker,value) (ValuePerPiece[Players.pieces[Board[expanding]]]+SEE(c,expanding,attacker,INF))
//#define COUNTER(c,expanding,attacker,value) (-SEE(c,expanding,attacker,1))
//#define COUNTER(c,expanding,attacker,value) (ThreatenedExcluding(c,expanding,attacker)?-value:0)
//#define COUNTER(c,expanding,attacker,value) 0
// square_value - positive_square_value_of_piece(c, piece_type, expanding) ));


#define CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
Move m MOVE_PARAMS;\
GENERATE_TO.push(m,((MVV_LVA)));\
}

#define SLIDE_CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
Move m MOVE_PARAMS; \
GENERATE_TO.push(m,((MVV_LVA))); capture = &GENERATE_TO.back();\
}


/*
#define CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
Move m MOVE_PARAMS;\
int v; \
const bool found = order_value(v,c,m, depth);\
GENERATE_TO.push(m,found?v:(v+(MVV_LVA)-(val)));\
}


#define NONCAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
Move m MOVE_PARAMS;\
int v; \
const bool found = order_value(v,c,m, depth);\
GENERATE_TO.push(m,found?v:(v+(val<<10)+(MVV_LVA)));\
}
//*/
/*
#define CAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		GENERATE_TO.push(m,(val<<9)+(MVV_LVA));\
	}
//*/
#define NONCAPTURE_VALUATION(MOVE_PARAMS, MVV_LVA) { \
		Move m MOVE_PARAMS;\
		GENERATE_TO.push(m,(MVV_LVA));\
	} 


#define QUIET_VALUE (-KING_VALUE)
//
#define SLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, expanding) ));\
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD) { \
		if (color(Board[expanding]) != c){\
			SLIDE_CAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(COUNTER(c,expanding,attacker,value),0));\
		}else if (Players.pieces[Board[expanding]]==piece_type || Players.pieces[Board[expanding]]==QUEEN) opposite_found = true;\
	} \
	break; \
} while (true)

#define QTSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, expanding) ));\
		continue; \
	}\
	break; \
} while (true)


#define TPOINT(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction ATLINE);\
		} else if (color(Board[root_pos+direction]) != c) \
			return Move(root_pos,root_pos+direction ATLINE); \
		return Move();\
	}


//
//square_value - positive_square_value_of_piece(c, piece_type, root_pos+direction)
#define POINT(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, root_pos+direction)))); \
	} else if (Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(COUNTER(c,root_pos+direction,attacker,value),value))); \
	}

#define QTPOINT(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(QUIET_VALUE,square_value - positive_square_value_of_piece(c, piece_type, root_pos+direction)))); \
	} 

#define TPPOINT(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction ATLINE);\
		} \
		return Move();\
	}

#define PPOINT(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),CAP_SCALE(QUIET_VALUE,square_value -positive_square_value_of_piece(c, piece_type, root_pos) + direction));\
	}


#define PPOINT_DOUBLE(direction) \
	if (Board[root_pos+direction] == NO_SLOT && Board[root_pos+(direction>>1)] == NO_SLOT) { \
		NONCAPTURE_VALUATION((root_pos,root_pos+direction, PAWN_JUST_ADVANCED ATLINE),CAP_SCALE(QUIET_VALUE,square_value -positive_square_value_of_piece(c, piece_type, root_pos) + direction)); \
	}

#define TPPOINT_DOUBLE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT && Board[root_pos+(direction>>1)] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction, PAWN_JUST_ADVANCED ATLINE);\
		} \
		return Move();\
	}


#define PPOINT_PROMOTE(direction) \
	if (Board[root_pos+direction] == NO_SLOT) { \
	CAPTURE_VALUATION((root_pos,root_pos+direction, QUEEN ATLINE),CAP_SCALE(QUEEN_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, KNIGHT ATLINE),CAP_SCALE(KNIGHT_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, ROOK ATLINE),CAP_SCALE(ROOK_VALUE,0)) \
	CAPTURE_VALUATION((root_pos,root_pos+direction, BISHOP ATLINE),CAP_SCALE(BISHOP_VALUE,0)) \
	}

#define TQPOINT_PROMOTE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
			return Move(root_pos,root_pos+direction, promotion ATLINE); \
		}\
	}

#define QPOINT_PROMOTE(direction) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c){ \
		CAPTURE_VALUATION((root_pos,root_pos+direction, QUEEN ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+QUEEN_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, KNIGHT ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+KNIGHT_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, ROOK ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+ROOK_VALUE),PAWN_VALUE))) \
		CAPTURE_VALUATION((root_pos,root_pos+direction, BISHOP ATLINE),(CAP_SCALE((ValuePerPiece[Players.pieces[Board[root_pos+direction]]]+BISHOP_VALUE),PAWN_VALUE))) \
	}


#define TPPOINT_PROMOTE(direction) \
	if (target == root_pos+direction){ \
		if (Board[root_pos+direction] == NO_SLOT) { \
			return Move(root_pos,root_pos+direction, promotion ATLINE);\
		} \
		return Move();\
	}

int Enpassants = 0;

#define PAWNQPOINT(direction,d2) \
	enpassant_pos = root_pos+d2;\
	if (\
		PAWN_JUST_ADVANCED == Players.pieces[Board[enpassant_pos]] \
		&& color(Board[enpassant_pos]) != c \
		&& Board[root_pos + direction] == NO_SLOT ) {\
			CAPTURE_VALUATION((root_pos,root_pos+direction , enpassant_pos, Move::DoEnpassant ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[enpassant_pos]]],value))) \
			++Enpassants; \
		}\
	else if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]],0))) 

//#define PAWNQPOINT(direction,d2) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(ValuePerPiece[Players.pieces[Board[root_pos+direction]]])-value)) 

#define TPAWNQPOINT(direction) \
	if (target == root_pos+direction){ \
		enpassant_pos = enpassant_table[root_pos+direction];\
		if (enpassant_pos != 0 \
			&& PAWN_JUST_ADVANCED == Players.pieces[Board[enpassant_pos]] \
			&& color(Board[enpassant_pos]) != c \
			&& Board[root_pos + direction] == NO_SLOT ) \
				return Move(root_pos, root_pos+direction, enpassant_pos, Move::DoEnpassant ATLINE); \
		if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) \
			return Move(root_pos,root_pos+direction ATLINE); \
		return Move();\
	}


#define QPOINT(direction) \
	if (Board[root_pos+direction] != NO_SLOT && Board[root_pos+direction] != OFF_BOARD && color(Board[root_pos+direction]) != c) {\
		CAPTURE_VALUATION((root_pos,root_pos+direction ATLINE),(CAP_SCALE(COUNTER(c,root_pos+direction,attacker,value),0)));\
	}


Move test_pawn_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			TPPOINT_PROMOTE(-10);
			TQPOINT_PROMOTE(-9);
			TQPOINT_PROMOTE(-11);
		}
		else {
			if (root_pos >= a2) TPPOINT_DOUBLE(-20);
			TPPOINT(-10);
			TPAWNQPOINT(-9);
			TPAWNQPOINT(-11);
		}
	}
	else {
		if (root_pos >= a2) {
			TPPOINT_PROMOTE(10);
			TQPOINT_PROMOTE(9);
			TQPOINT_PROMOTE(11);
		}
		else {
			if (root_pos <= h7) TPPOINT_DOUBLE(20);
			TPPOINT(10);
			TPAWNQPOINT(9);
			TPAWNQPOINT(11);
		}
	}
	return Move();
}


void generate_pawn_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = PAWN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			PPOINT_PROMOTE(-10);
			QPOINT_PROMOTE(-9);
			QPOINT_PROMOTE(-11);
		}
		else {
			if (root_pos >= a2) PPOINT_DOUBLE(-20);
			PPOINT(-10);
			PAWNQPOINT(-9, 1);
			PAWNQPOINT(-11, -1);
		}
	}
	else {
		if (root_pos >= a2) {
			PPOINT_PROMOTE(10);
			QPOINT_PROMOTE(9);
			QPOINT_PROMOTE(11);
		}
		else {
			if (root_pos <= h7) PPOINT_DOUBLE(20);
			PPOINT(10);
			PAWNQPOINT(9, -1);
			PAWNQPOINT(11, 1);
		}
	}
}

void generate_quiet_pawn_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = PAWN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			PPOINT_PROMOTE(-10);
		}
		else {
			if (root_pos >= a2) PPOINT_DOUBLE(-20);
			PPOINT(-10);
		}
	}
	else {
		if (root_pos >= a2) {
			PPOINT_PROMOTE(10);
		}
		else {
			if (root_pos <= h7) PPOINT_DOUBLE(20);
			PPOINT(10);
		}
	}
}


Move test_knight_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	const Pos direction = KnightDirection[root_pos][target];
	if (direction != 0) {
		TPOINT(direction);
	}
	return Move();
}

void generate_knight_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KNIGHT_VALUE;
	const PieceType piece_type = KNIGHT;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	POINT(-21);
	POINT(-19);
	POINT(-12);
	POINT(-8);
	POINT(8);
	POINT(12);
	POINT(19);
	POINT(21);
}
void generate_quiet_knight_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KNIGHT_VALUE;
	const PieceType piece_type = KNIGHT;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	QTPOINT(-21);
	QTPOINT(-19);
	QTPOINT(-12);
	QTPOINT(-8);
	QTPOINT(8);
	QTPOINT(12);
	QTPOINT(19);
	QTPOINT(21);
}

Move test_king_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	const Pos direction = KingDirection[root_pos][target];
	if (direction != 0) {
		TPOINT(direction);
	}
	return Move();
}


void generate_king_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = KING;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	const int value = KING_VALUE;
	POINT(-11);
	POINT(-10);
	POINT(-9);
	POINT(-1);
	POINT(1);
	POINT(9);
	POINT(10);
	POINT(11);
}

void generate_quiet_king_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = KING;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	const int value = KING_VALUE;
	QTPOINT(-11);
	QTPOINT(-10);
	QTPOINT(-9);
	QTPOINT(-1);
	QTPOINT(1);
	QTPOINT(9);
	QTPOINT(10);
	QTPOINT(11);
}


Move test_king_castle_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	if (can_castle_left(c)) {
		if (c == LIGHT) { if (target == c1)  return Move(e1, c1,CastleLeft ATLINE); }
		else { if (target == c8)  return Move(e8, c8, CastleLeft ATLINE); }
	}
	if (can_castle_right(c)) {
		if (c == LIGHT) { if (target == g1) return Move(e1, g1, CastleRight ATLINE); }
		else { if (target == g8) return Move(e8, g8, CastleRight ATLINE); }
	}
	return test_king_moves(c, root_pos, target, promotion);
}

int Castles = 0;

void generate_king_castle_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	if (can_castle_left(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, c1, CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		else GENERATE_TO.push(Move(e8, c8, CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		++Castles;
	}
	if (can_castle_right(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, g1, CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		else GENERATE_TO.push(Move(e8, g8, CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		++Castles;
	}
	generate_king_moves(c, root_pos, attacker, val, depth);
}

void generate_quiet_king_castle_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	if (can_castle_left(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, c1, CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		else GENERATE_TO.push(Move(e8, c8, CastleLeft ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		++Castles;
	}
	if (can_castle_right(c)) {
		if (c == LIGHT) GENERATE_TO.push(Move(e1, g1, CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		else GENERATE_TO.push(Move(e8, g8, CastleRight ATLINE), CAP_SCALE(KING_CASTLING_BONUS, 0));
		++Castles;
	}
	generate_quiet_king_moves(c, root_pos, attacker, val, depth);
}


Move test_queen_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = QueenDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}

int count_null_moves(const Colors c, const Pos root_pos)
{
	return 0;
}

#define QUEEN_COUNT 1
#define KNIGHT_COUNT 15
#define ROOK_HOR_COUNT 2
#define ROOK_VIR_COUNT 7
#define BISHOP_COUNT 3
int count_queen_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-11, QUEEN_COUNT);
	CSLIDE(-10, QUEEN_COUNT);
	CSLIDE(-9, QUEEN_COUNT);
	CSLIDE(-1, QUEEN_COUNT);
	CSLIDE(1, QUEEN_COUNT);
	CSLIDE(9, QUEEN_COUNT);
	CSLIDE(10, QUEEN_COUNT);
	CSLIDE(11, QUEEN_COUNT);
	return count>>1;
}
int count_knight_moves(const Colors c, const Pos root_pos)
{
	int count = 0;
	CPOINT(-21, KNIGHT_COUNT);
	CPOINT(-19, KNIGHT_COUNT);
	CPOINT(-12, KNIGHT_COUNT);
	CPOINT(-8, KNIGHT_COUNT);
	CPOINT(8, KNIGHT_COUNT);
	CPOINT(12, KNIGHT_COUNT);
	CPOINT(19, KNIGHT_COUNT);
	CPOINT(21, KNIGHT_COUNT);
	return count;
}

int count_bishop_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-11, BISHOP_COUNT);
	CSLIDE(-9, BISHOP_COUNT);
	CSLIDE(9, BISHOP_COUNT);
	CSLIDE(11, BISHOP_COUNT);
	return count;
}

int count_rook_moves(const Colors c, const Pos root_pos)
{
	Pos expanding;
	int count = 0;
	CSLIDE(-10, ROOK_VIR_COUNT);
	CSLIDE(-1, ROOK_HOR_COUNT);
	CSLIDE(1, ROOK_HOR_COUNT);
	CSLIDE(10, ROOK_VIR_COUNT);
	return count;
}

typedef int CountMoveFn(const Colors c, const Pos root_pos);
CountMoveFn* CountMoveTable[NUM_PIECE_TYPES] =
{
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_null_moves,
	count_knight_moves,//knight
	count_bishop_moves,
	count_rook_moves,
	count_rook_moves,
	count_queen_moves,
};

int mobility(PieceSlotType s)
{
	return CountMoveTable[Players.pieces[s]](color(s), Players.positions[s]);
}
//#define BATTERY_BONUS 40;

void generate_queen_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = QUEEN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = QUEEN_VALUE;
	bool opposite_found=false;
	Move *capture=nullptr;
	SLIDE(-11);
	SLIDE(11);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	SLIDE(-10);
	SLIDE(10);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	SLIDE(-9);
	SLIDE(9);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	SLIDE(-1);
	SLIDE(1);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}
void generate_quiet_queen_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = QUEEN;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = QUEEN_VALUE;
	QTSLIDE(-11);
	QTSLIDE(-10);
	QTSLIDE(-9);
	QTSLIDE(-1);
	QTSLIDE(1);
	QTSLIDE(9);
	QTSLIDE(10);
	QTSLIDE(11);
}

Move test_rook_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = RookDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}

void generate_rook_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = ROOK;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = ROOK_VALUE;
	bool opposite_found = false;
	Move *capture = nullptr;
	SLIDE(-1);
	SLIDE(1);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	SLIDE(10);
	SLIDE(-10);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}
void generate_quiet_rook_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = ROOK;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = ROOK_VALUE;
	QTSLIDE(-10);
	QTSLIDE(-1);
	QTSLIDE(1);
	QTSLIDE(10);
}

Move test_bishop_moves(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion)
{
	Pos expanding;
	const Pos direction = BishopDirection[root_pos][target];
	if (direction != 0) {
		TSLIDE(direction);
	}
	return Move();
}


void generate_bishop_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = BISHOP;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = BISHOP_VALUE;
	bool opposite_found = false;
	Move *capture = nullptr;
	SLIDE(-11);
	SLIDE(11);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	SLIDE(-9);
	SLIDE(9);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}

void generate_quiet_bishop_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const PieceType piece_type = BISHOP;
	const int square_value = positive_square_value_of_piece(c, piece_type, root_pos);
	Pos expanding;
	const int value = BISHOP_VALUE;
	QTSLIDE(-11);
	QTSLIDE(-9);
	QTSLIDE(9);
	QTSLIDE(11);
}

#define QSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD) { \
		if (color(Board[expanding]) != c){\
			SLIDE_CAPTURE_VALUATION((root_pos,expanding ATLINE),CAP_SCALE(COUNTER(c,expanding,attacker,value),0));\
		}else if (Players.pieces[Board[expanding]]==piece_type || Players.pieces[Board[expanding]]==QUEEN) opposite_found = true;\
	} \
	break; \
} while (true)

void quiesent_generate_pawn_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos enpassant_pos;
	const int value = PAWN_VALUE;
	if (c == LIGHT) {
		if (root_pos <= h7) {
			PPOINT_PROMOTE(-10);
			QPOINT_PROMOTE(-9);
			QPOINT_PROMOTE(-11);
		}
		else {
			PAWNQPOINT(-9, 1);
			PAWNQPOINT(-11, -1);
		}
	}
	else {
		if (root_pos >= a2) {
			PPOINT_PROMOTE(10);
			QPOINT_PROMOTE(9);
			QPOINT_PROMOTE(11);
		}
		else {
			PAWNQPOINT(9, -1);
			PAWNQPOINT(11, 1);
		}
	}
}


void quiesent_generate_knight_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KNIGHT_VALUE;
	const int square_value = positive_square_value_of_piece(c, KNIGHT, root_pos);

	QPOINT(-21);
	QPOINT(-19);
	QPOINT(-12);
	QPOINT(-8);
	QPOINT(8);
	QPOINT(12);
	QPOINT(19);
	QPOINT(21);
}


void quiesent_generate_king_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	const int value = KING_VALUE;
	const int square_value = positive_square_value_of_piece(c, KING, root_pos);
	QPOINT(-11);
	QPOINT(-10);
	QPOINT(-9);
	QPOINT(-1);
	QPOINT(1);
	QPOINT(9);
	QPOINT(10);
	QPOINT(11);
}


void quiesent_generate_queen_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	PieceType piece_type = QUEEN;
	const int value = QUEEN_VALUE;
	const int square_value = positive_square_value_of_piece(c, QUEEN, root_pos);
	bool opposite_found=false;
	Move *capture=nullptr;
	QSLIDE(-11);
	QSLIDE(11);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	QSLIDE(-9);
	QSLIDE(9);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	QSLIDE(1);
	QSLIDE(-1);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	QSLIDE(10);
	QSLIDE(-10);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}

void quiesent_generate_rook_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	const int value = ROOK_VALUE;
	PieceType piece_type = ROOK;
	const int square_value = positive_square_value_of_piece(c, ROOK, root_pos);
	bool opposite_found = false;
	Move *capture = nullptr;
	QSLIDE(-10);
	QSLIDE(10);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	QSLIDE(-1);
	QSLIDE(1);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}

void quiesent_generate_bishop_moves(const Colors c, const Pos root_pos, PieceSlotType attacker, int val, int depth)
{
	Pos expanding;
	const int value = BISHOP_VALUE;
	PieceType piece_type = ROOK;
	const int square_value = positive_square_value_of_piece(c, BISHOP, root_pos);
	bool opposite_found = false;
	Move *capture = nullptr;
	QSLIDE(-11);
	QSLIDE(11);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
	opposite_found = false; capture = nullptr;
	QSLIDE(-9);
	QSLIDE(9);
	if (opposite_found && capture != nullptr) capture->move_flags = Extend;
}

typedef void GenMoveFn(const Colors, const Pos, PieceSlotType attacker, int val, int depth);
typedef Move TestMoveFn(const Colors c, const Pos root_pos, const Pos target, const PieceType promotion);

/*enum PieceType : signed char {
EMPTY = 0,
KING_NOT_MOVED = 1,
KING = 2,
KING_CASTLED = 3,
PAWN = 4,
PAWN_JUST_ADVANCED = 5,
KNIGHT = 6,
BISHOP = 7,
ROOK_NOT_MOVED = 8,
ROOK = 9,
QUEEN = 10,
NUM_PIECE_TYPES = 11,
};*/

void generate_empty_moves(const Colors, const Pos, PieceSlotType attacker, int val, int depth) {}
Move test_empty_moves(const Colors, const Pos, const Pos, const PieceType) { return Move(); }

TestMoveFn* TestMoveTable[NUM_PIECE_TYPES] =
{
	test_empty_moves,
	test_king_castle_moves,
	test_king_moves,
	test_king_moves,
	test_pawn_moves,
	test_pawn_moves,
	test_knight_moves,
	test_bishop_moves,
	test_rook_moves,
	test_rook_moves,
	test_queen_moves,
};

GenMoveFn* GenQuietMoveTable[NUM_PIECE_TYPES] =
{
	generate_empty_moves,
	generate_quiet_king_castle_moves,
	generate_quiet_king_moves,
	generate_quiet_king_moves,
	generate_quiet_pawn_moves,
	generate_quiet_pawn_moves,
	generate_quiet_knight_moves,
	generate_quiet_bishop_moves,
	generate_quiet_rook_moves,
	generate_quiet_rook_moves,
	generate_quiet_queen_moves,
};

GenMoveFn* GenMoveTable[NUM_PIECE_TYPES] =
{
	generate_empty_moves,
	generate_king_castle_moves,
	generate_king_moves,
	generate_king_moves,
	generate_pawn_moves,
	generate_pawn_moves,
	generate_knight_moves,
	generate_bishop_moves,
	generate_rook_moves,
	generate_rook_moves,
	generate_queen_moves,
};

GenMoveFn* QGenMoveTable[NUM_PIECE_TYPES] =
{
	generate_empty_moves,
	quiesent_generate_king_moves,
	quiesent_generate_king_moves,
	quiesent_generate_king_moves,
	quiesent_generate_pawn_moves,
	quiesent_generate_pawn_moves,
	quiesent_generate_knight_moves,
	quiesent_generate_bishop_moves,
	quiesent_generate_rook_moves,
	quiesent_generate_rook_moves,
	quiesent_generate_queen_moves,
};

//only used at top level loop
void set_side(Colors s)
{
	if (PlySide() != s) {
		EphemeralValue = -EphemeralValue;
		PersistantValue = -PersistantValue;
		PawnsValue = -PawnsValue;
	}
	set_PlySide(s);
}
bool inc_ply()
{
	if (CurrentPly == MAX_PLY - 1)return false;
	++CurrentPly;
	++MoveNumber;
	MovesOrdered.inc_ply();
	PersistantValue = -PersistantValue;
	EphemeralValue = -EphemeralValue;
	PawnsValue = -PawnsValue;
	EvalDirtyNegate = -EvalDirtyNegate;
	set_PlySide(other_color(PlySide()));

	return true;
}

bool dec_ply()
{
	if (CurrentPly == 0)return false;
	--CurrentPly;
	--MoveNumber;
	MovesOrdered.dec_ply();
	PersistantValue = -PersistantValue;
	EphemeralValue = -EphemeralValue;
	PawnsValue = -PawnsValue;
	EvalDirtyNegate = -EvalDirtyNegate;
	set_PlySide(other_color(PlySide()));

	return true;
}

Move TestMove(Colors c, PieceSlotType p, Pos target, PieceType promotion)
{
	if (color(p) != c) return Move();
	return TestMoveTable[Players.pieces[p]](c, Players.positions[p], target, promotion);
}

void GenMove(PieceSlotType p, int val, int depth)
{
	//	if (Players.pieces[p] == EMPTY) return;
	GenMoveTable[Players.pieces[p]](color(p), Players.positions[p], p, val, depth);
}
void GenQuietMove(PieceSlotType p, int val, int depth)
{
	//	if (Players.pieces[p] == EMPTY) return;
	GenQuietMoveTable[Players.pieces[p]](color(p), Players.positions[p], p, val, depth);
}

void QGenMove(PieceSlotType p, int val, int depth)
{
	//	if (Players.pieces[p] == EMPTY) return;
	QGenMoveTable[Players.pieces[p]](color(p), Players.positions[p], p, val, depth);
}

void GenMoves(PieceSlotType p, int val, int depth)
{
	GenMove(p, val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}
void GenQuietMoves(PieceSlotType p, int val, int depth)
{
	GenQuietMove(p, val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}

int GenPinMoves(Colors c, int &num_pin_move, Pos *prev_pin_moves, int val, int depth)
{
	const int start_index = MovesOrdered.index();
	GenMoves((PieceSlotType)(KINGP + base_by_color(c)), val, depth);
	const int end_index = MovesOrdered.index();
	for (int i = start_index;i < end_index;++i) {
		for (int j = 0;j < num_pin_move;++j) {
			if (!MovesOrdered[i].empty() && MovesOrdered[i].to == prev_pin_moves[j]) MovesOrdered[i].clear();
		}
	}
	int count_pin_moves = 0;
	for (int i = start_index;i < end_index;++i) {
		if (!MovesOrdered[i].empty()) {
			++count_pin_moves;
			prev_pin_moves[num_pin_move++] = MovesOrdered[i].to;
		}
	}
	return count_pin_moves;
}
void QGenMoves(PieceSlotType p, int val, int depth)
{
	QGenMove(p, val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}
/*
bool LazyGenMove(int &i, bool quiescent, Colors c, Move *killer_moves, int num_killer)
{
do {
if (i == NUM_UNCOLORED_PIECE_SLOTS) return false;
if (quiescent) QGenMove((PieceSlotType)(i + base_by_color(c)));
else GenMove((PieceSlotType)(i + base_by_color(c)));
//		MovesOrdered.push_list(VanillaMoves);
//		MovesOrdered.push_list(Captures);
++i;
} while (MovesOrdered.empty());
for (int i = 0;i < num_killer;++i) {
if (sort_pv(killer_moves[i])) MovesOrdered.pop();
}
return true;
}
*/
void GenMoves(Colors c, int val, int depth)
{
	PieceSlotType base = base_by_color(c);
	for (int i = PAWN1;i < NUM_UNCOLORED_PIECE_SLOTS;++i) GenMove((PieceSlotType)(i + base), val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}
void GenQuietMoves(Colors c, int val, int depth)
{
	PieceSlotType base = base_by_color(c);
	for (int i = PAWN1;i < NUM_UNCOLORED_PIECE_SLOTS;++i) GenQuietMove((PieceSlotType)(i + base), val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}

void QGenMoves(Colors c, int val, int depth)
{
	PieceSlotType base = base_by_color(c);
	for (int i = PAWN1;i < NUM_UNCOLORED_PIECE_SLOTS;++i) QGenMove((PieceSlotType)(i + base), val, depth);
	//	MovesOrdered.push_list(VanillaMoves);
	//	MovesOrdered.push_list(Captures);
}


const PieceType ComparisonPiece[] =
{
	EMPTY,
	KING,
	KING,
	KING,
	PAWN,
	PAWN,
	KNIGHT,
	BISHOP,
	ROOK,
	ROOK,
	QUEEN,
};

#define REV_HVSLIDE_KN(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK: units+=3; break;\
			case QUEEN: units+=5;\
		}\
	break; \
} while (true)


#define REV_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK:case QUEEN: return true;\
		}\
	break; \
} while (true)

#define EX_REV_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT || Board[expanding]==exclude) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK:case QUEEN: return true;\
		}\
	break; \
} while (true)


#define REV_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP:case QUEEN: return true;\
		}\
	break; \
} while (true)

#define REV_DSLIDE_KN(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP: units+=2; break;\
			case QUEEN: units+= 5;\
		}\
	break; \
} while (true)


#define REV_GEN_DSLIDE(direction) \
expanding = root_pos ;\
stop=false;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case QUEEN: \
				delay = true; \
			case BISHOP:\
			{ \
				Move m(expanding,root_pos ATLINE);\
				MovesOrdered.push(m,CAP_SCALE(COUNTER(c,root_pos,Board[expanding],ValuePerPiece[Players.pieces[Board[expanding]]]),0));\
				stop = true;\
			} \
		}\
	break; \
} while (!stop)

#define REV_GEN_HVSLIDE(direction) \
expanding = root_pos ;\
stop=false;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case QUEEN:\
				delay = true; \
			case ROOK_NOT_MOVED: case ROOK:\
			{ \
				Move m(expanding,root_pos ATLINE);\
				MovesOrdered.push(m,CAP_SCALE(COUNTER(c,root_pos,Board[expanding],ValuePerPiece[Players.pieces[Board[expanding]]]),ValuePerPiece[Players.pieces[Board[expanding]]]));\
				stop = true;\
			} \
		}\
	break; \
} while (!stop)

#define REV_GEN_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) {\
		CAPTURE_VALUATION((root_pos+direction, root_pos ATLINE),(CAP_SCALE(COUNTER(c,root_pos,Board[root_pos+direction],ValuePerPiece[Players.pieces[Board[root_pos+direction]]]),0)));\
}

#define REV_GEN_PAWN \
	if (c==LIGHT) {REV_GEN_POS(-9,PAWN);REV_GEN_POS(-11,PAWN);} else {REV_GEN_POS(9,PAWN);REV_GEN_POS(11,PAWN); }


#define EX_REV_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT || Board[expanding] == exclude) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP:case QUEEN: return true;\
		}\
	break; \
} while (true)


#define DPINSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) == c) \
	{\
		PinTypes pt;\
		if (Players.pieces[Board[expanding]]!=BISHOP && Players.pieces[Board[expanding]]!=QUEEN) pt=Pinned;\
		else pt=PartiallyPinned;\
		const PieceSlotType pinned_piece = Board[expanding]; \
		pins[pin_count] = Board[expanding];\
		do {\
			expanding+=direction;\
			if (Board[expanding] == NO_SLOT) { \
				continue; \
			}\
			if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
				switch(Players.pieces[Board[expanding]]){\
					case BISHOP:case QUEEN: \
					pinner[pin_count++] = Board[expanding];\
					Players.pinned[pinned_piece] = pt;\
				}\
			break;\
		}while(true);\
	}\
	break; \
} while (true)

#define HVPINSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) == c) \
	{\
		PinTypes pt;\
		if (Players.pieces[Board[expanding]]!=ROOK && Players.pieces[Board[expanding]]!=ROOK_NOT_MOVED && Players.pieces[Board[expanding]]!=QUEEN) pt=Pinned;\
		else pt=PartiallyPinned;\
		const PieceSlotType pinned_piece = Board[expanding]; \
		pins[pin_count] = Board[expanding];\
		do {\
			expanding+=direction;\
			if (Board[expanding] == NO_SLOT) { \
				continue; \
			}\
			if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
				switch(Players.pieces[Board[expanding]]){\
					case ROOK_NOT_MOVED: case ROOK:case QUEEN: \
					pinner[pin_count++] = Board[expanding];\
					Players.pinned[pinned_piece] = pt;\
				}\
			break;\
		}while(true);\
	}\
	break; \
} while (true)

int calc_pins(Colors c, Pos root_pos, PieceSlotType *pins, PieceSlotType *pinner)
{
	int pin_count = 0;
	int expanding;
	DPINSLIDE(-11);
	HVPINSLIDE(-10);
	DPINSLIDE(-9);
	HVPINSLIDE(-1);
	HVPINSLIDE(1);
	DPINSLIDE(9);
	HVPINSLIDE(10);
	DPINSLIDE(11);
	return pin_count;
}


//used for knight and king
#define REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;

#define REV_POS_KN(direction,piece,value) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) units+=value;


#define EX_REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && Board[root_pos+direction] != exclude && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;

#define FIND_ATTACKER_HVSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case ROOK_NOT_MOVED: case ROOK: return Board[expanding];\
			case QUEEN: found_queen = Board[expanding];\
		}\
	break; \
} while (true)


#define FIND_ATTACKER_DSLIDE(direction) \
expanding = root_pos ;\
do { \
	expanding+=direction;\
	if (Board[expanding] == NO_SLOT) { \
		continue; \
	}\
	if (Board[expanding] != OFF_BOARD && color(Board[expanding]) != c) \
		switch(Players.pieces[Board[expanding]]){\
			case BISHOP: return Board[expanding];\
			case QUEEN: found_queen = Board[expanding];\
		}\
	break; \
} while (true)


#define FIND_ATTACKER_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return Board[root_pos+direction];

#define FIND_ATTACKER_PAWN \
	if (c==LIGHT) {FIND_ATTACKER_POS(-9,PAWN);FIND_ATTACKER_POS(-11,PAWN);} else {FIND_ATTACKER_POS(9,PAWN);FIND_ATTACKER_POS(11,PAWN); }


#define WEIGHT_REV_POS(direction,piece) \
if (is_piece((Pos)(root_pos+direction)) && color(Board[root_pos+direction]) != c && ComparisonPiece[Players.pieces[Board[root_pos+direction]]]==piece) return true;


#define REV_PAWN \
	if (c==LIGHT) {REV_POS(-9,PAWN);REV_POS(-11,PAWN);} else {REV_POS(9,PAWN);REV_POS(11,PAWN); }

#define REV_PAWN_KN \
	if (c==LIGHT) {REV_POS_KN(-9,PAWN,1);REV_POS_KN(-11,PAWN,1);} else {REV_POS_KN(9,PAWN,1);REV_POS_KN(11,PAWN,1); }

#define EX_REV_PAWN \
	if (c==LIGHT) {EX_REV_POS(-9,PAWN);EX_REV_POS(-11,PAWN);} else {EX_REV_POS(9,PAWN);EX_REV_POS(11,PAWN); }

int KnightDirections[] =
{
	-21,-19,-12,-8,8,12,19,21,21,-19,-12,-8,8,12,19
};
int DSlideDirections[] =
{
	-11,-9,9,11,-11,-9,9,11,-11,-9,9,11,-11,-9,9,
};
int HSlideDirections[] = 
{
	-10,-1,1,10,-10,-1,1,10,-10,-1,1,10,-10,-1,1,
};
int KingDirections[] =
{
	-10,-1,1,10,-11,-9,9,11,-11,-10,-1,1,10,-11,-9,9,11,
};
///*
PieceSlotType LeastAttacker(Colors c, Pos root_pos)
{
PieceSlotType found_queen = NO_SLOT;
int expanding;
FIND_ATTACKER_PAWN;
FIND_ATTACKER_POS(-21, KNIGHT);
FIND_ATTACKER_POS(-19, KNIGHT);
FIND_ATTACKER_POS(-12, KNIGHT);
FIND_ATTACKER_POS(-8, KNIGHT);
FIND_ATTACKER_POS(8, KNIGHT);
FIND_ATTACKER_POS(12, KNIGHT);
FIND_ATTACKER_POS(19, KNIGHT);
FIND_ATTACKER_POS(21, KNIGHT);

FIND_ATTACKER_DSLIDE(-11);
FIND_ATTACKER_DSLIDE(-9);
FIND_ATTACKER_DSLIDE(9);
FIND_ATTACKER_DSLIDE(11);
FIND_ATTACKER_HVSLIDE(-10);
FIND_ATTACKER_HVSLIDE(-1);
FIND_ATTACKER_HVSLIDE(1);
FIND_ATTACKER_HVSLIDE(10);

if (found_queen != NO_SLOT) return found_queen;

const PieceSlotType KingS = (PieceSlotType)(KINGP + base_by_color(other_color(c)));
const Pos KingPos = Players.positions[KingS];
switch (KingPos - root_pos)
{
case -11:case -10:case -9:case-1:case 1:case 9:case 10:case 11: return KingS;
}

return NO_SLOT;
}
//*/
/*
PieceSlotType LeastAttacker(Colors c, Pos root_pos)
{
	PieceSlotType found_queen = NO_SLOT;
	int expanding;
	int permute = (int)Hash.low & 7;
	FIND_ATTACKER_PAWN;
	FIND_ATTACKER_POS(KnightDirections[permute], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+1], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+2], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+3], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+4], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+5], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+6], KNIGHT);
	FIND_ATTACKER_POS(KnightDirections[permute+7], KNIGHT);

	FIND_ATTACKER_DSLIDE(DSlideDirections[permute]);
	FIND_ATTACKER_DSLIDE(DSlideDirections[permute+1]);
	FIND_ATTACKER_DSLIDE(DSlideDirections[permute+2]);
	FIND_ATTACKER_DSLIDE(DSlideDirections[permute+3]);
	FIND_ATTACKER_HVSLIDE(HSlideDirections[permute]);
	FIND_ATTACKER_HVSLIDE(HSlideDirections[permute+1]);
	FIND_ATTACKER_HVSLIDE(HSlideDirections[permute+2]);
	FIND_ATTACKER_HVSLIDE(HSlideDirections[permute+3]);

	if (found_queen != NO_SLOT) return found_queen;

	FIND_ATTACKER_POS(KingDirections[permute], KING);
	FIND_ATTACKER_POS(KingDirections[permute+1], KING);
	FIND_ATTACKER_POS(KingDirections[permute+2], KING);
	FIND_ATTACKER_POS(KingDirections[permute+3], KING);
	FIND_ATTACKER_POS(KingDirections[permute+4], KING);
	FIND_ATTACKER_POS(KingDirections[permute+5], KING);
	FIND_ATTACKER_POS(KingDirections[permute+6], KING);
	FIND_ATTACKER_POS(KingDirections[permute+7], KING);

	return NO_SLOT;
}
*/
int see_u(Colors side, Pos root_pos, int just_captured, int depth)
{
	if (depth == 0) return 0;
	PieceSlotType least = LeastAttacker(side, root_pos);
	if (least == NO_SLOT) return 0;
	if ((least&UNCOLORED_SLOT_MASK) == KINGP) {
		Board[Players.positions[least]] = NO_SLOT;
		bool cant_take_with_king = LeastAttacker(other_color(side), root_pos)!=NO_SLOT;
		Board[Players.positions[least]] = least;
		if (cant_take_with_king) return 0;
		return just_captured;
	}
//	const int at_value = positive_square_value_of_piece(other_color(side), Players.pieces[least], root_pos);
//	const int from_value = positive_square_value_of_piece(other_color(side), Players.pieces[least], Players.positions[least]);
	Board[Players.positions[least]] = NO_SLOT;
	int v = just_captured 
		//+ from_value 
		//- at_value 
		- see_u(other_color(side), root_pos, ValuePerPiece[Players.pieces[least]]
			//+ at_value
			, depth - 1);
	Board[Players.positions[least]] = least;
	if (v < 0) return 0;
	return v;
}

int SEE(Colors c, Pos root_pos, PieceSlotType exclude, int depth)
{
	Board[Players.positions[exclude]] = NO_SLOT;
	//int at_value = positive_square_value_of_piece(c, Players.pieces[exclude], root_pos);
	int v =//at_value 
		-see_u(c, root_pos, ValuePerPiece[Players.pieces[exclude]]//+ at_value
			, depth);
	Board[Players.positions[exclude]] = exclude;
	return v;
}

int SEE(Pos root_pos)
{
	PieceSlotType s = Board[root_pos];
	if (!is_piece(s)) return 0;
	return SEE(color(s), root_pos, s, INF);
}

bool ThreatenedExcluding(Colors c, Pos root_pos, PieceSlotType exclude)
{
	int expanding;
	EX_REV_POS(-21, KNIGHT);
	EX_REV_POS(-19, KNIGHT);
	EX_REV_POS(-12, KNIGHT);
	EX_REV_POS(-11, KING);
	EX_REV_POS(-10, KING);
	EX_REV_POS(-9, KING);
	EX_REV_POS(-8, KNIGHT);
	EX_REV_POS(-1, KING);
	EX_REV_PAWN;
	EX_REV_POS(1, KING);
	EX_REV_POS(8, KNIGHT);
	EX_REV_POS(9, KING);
	EX_REV_POS(10, KING);
	EX_REV_POS(11, KING);
	EX_REV_POS(12, KNIGHT);
	EX_REV_POS(19, KNIGHT);
	EX_REV_POS(21, KNIGHT);
	EX_REV_DSLIDE(-11);
	EX_REV_HVSLIDE(-10);
	EX_REV_DSLIDE(-9);
	EX_REV_HVSLIDE(-1);
	EX_REV_HVSLIDE(1);
	EX_REV_DSLIDE(9);
	EX_REV_HVSLIDE(10);
	EX_REV_DSLIDE(11);
	return false;
}

int Safety(Colors c, Pos root_pos)
{
	int units=0;
	int expanding;
	REV_DSLIDE_KN(-11);
	REV_HVSLIDE_KN(-10);
	REV_DSLIDE_KN(-9);
	REV_HVSLIDE_KN(-1);
	REV_HVSLIDE_KN(1);
	REV_DSLIDE_KN(9);
	REV_HVSLIDE_KN(10);
	REV_DSLIDE_KN(11);
	REV_POS_KN(-21, KNIGHT,2);
	REV_POS_KN(-19, KNIGHT, 2);
	REV_POS_KN(-12, KNIGHT, 2);
	REV_POS_KN(-11, KING,1);
	REV_POS_KN(-10, KING,1);
	REV_POS_KN(-9, KING,1);
	REV_POS_KN(-8, KNIGHT, 2);
	REV_POS_KN(-1, KING,1);
	REV_POS_KN(1, KING,1);
	REV_POS_KN(8, KNIGHT, 2);
	REV_POS_KN(9, KING,1);
	REV_POS_KN(10, KING,1);
	REV_POS_KN(11, KING,1);
	REV_POS_KN(12, KNIGHT, 2);
	REV_POS_KN(19, KNIGHT, 2);
	REV_POS_KN(21, KNIGHT, 2);
	REV_PAWN_KN;
	return units;
}


bool Threatened(Colors c, Pos root_pos)
{
	int expanding;
	REV_PAWN;
	const PieceSlotType KingS = (PieceSlotType)(KINGP + base_by_color(other_color(c)));
	const Pos KingPos = Players.positions[KingS];
	switch (KingPos - root_pos)
	{
	case -11:case -10:case -9:case-1:case 1:case 9:case 10:case 11: return true;
	}

	REV_POS(-21, KNIGHT);
	REV_POS(-19, KNIGHT);
	REV_POS(-12, KNIGHT);
	REV_POS(-8, KNIGHT);
	REV_POS(8, KNIGHT);
	REV_POS(12, KNIGHT);
	REV_POS(19, KNIGHT);
	REV_POS(21, KNIGHT);

	REV_DSLIDE(-11);
	REV_HVSLIDE(-10);
	REV_DSLIDE(-9);
	REV_HVSLIDE(-1);
	REV_HVSLIDE(1);
	REV_DSLIDE(9);
	REV_HVSLIDE(10);
	REV_DSLIDE(11);
	return false;
}
/*
bool GenThreat(int &i, Colors c, Pos root_pos, int val, int depth)
{
	int expanding;
	bool stop;
	bool delay = false;
	switch (i)
	{
	case 0:
		if (c == LIGHT) { REV_GEN_POS(-9, PAWN); }
		else { REV_GEN_POS(9, PAWN); }
		i = 1;
		if (!MovesOrdered.empty()) return true;
	case 1:
		if (c == LIGHT) { REV_GEN_POS(-11, PAWN); }
		else { REV_GEN_POS(11, PAWN); }
		i = 2;
		if (!MovesOrdered.empty()) return true;
	case 2:
		REV_GEN_POS(-21, KNIGHT);
		i = 3;
		if (!MovesOrdered.empty()) return true;
	case 3:
		REV_GEN_POS(-19, KNIGHT);
		i = 4;
		if (!MovesOrdered.empty()) return true;
	case 4:
		REV_GEN_POS(-12, KNIGHT);
		i = 5;
		if (!MovesOrdered.empty()) return true;
	case 5:
		REV_GEN_POS(-8, KNIGHT);
		i = 6;
		if (!MovesOrdered.empty()) return true;
	case 6:
		REV_GEN_POS(8, KNIGHT);
		i = 7;
		if (!MovesOrdered.empty()) return true;
	case 7:
		REV_GEN_POS(12, KNIGHT);
		i = 8;
		if (!MovesOrdered.empty()) return true;
	case 8:
		REV_GEN_POS(19, KNIGHT);
		i = 9;
		if (!MovesOrdered.empty()) return true;
	case 9:
		REV_GEN_POS(21, KNIGHT);
		i = 10;
		if (!MovesOrdered.empty()) return true;
	case 10:
		REV_GEN_DSLIDE(-11);
		i = 11;
		if (!delay && !MovesOrdered.empty()) return true;
	case 11:
		REV_GEN_DSLIDE(-9);
		i = 12;
		if (!delay && !MovesOrdered.empty()) return true;
	case 12:
		REV_GEN_DSLIDE(9);
		i = 13;
		if (!delay && !MovesOrdered.empty()) return true;
	case 13:
		REV_GEN_DSLIDE(11);
		i = 14;
		if (!delay && !MovesOrdered.empty()) return true;
	case 14:
		REV_GEN_HVSLIDE(-10);
		i = 15;
		if (!delay && !MovesOrdered.empty()) return true;
	case 15:
		REV_GEN_HVSLIDE(-1);
		i = 16;
		if (!delay && !MovesOrdered.empty()) return true;
	case 16:
		REV_GEN_HVSLIDE(1);
		i = 17;
		if (!delay && !MovesOrdered.empty()) return true;
	case 17:
		REV_GEN_HVSLIDE(10);
		i = 18;
		if (!MovesOrdered.empty()) return true;
	case 18:
		REV_GEN_POS(-11, KING);
		i = 19;
		if (!MovesOrdered.empty()) return true;
	case 19:
		REV_GEN_POS(-10, KING);
		i = 20;
		if (!MovesOrdered.empty()) return true;
	case 20:
		REV_GEN_POS(-9, KING);
		i = 21;
		if (!MovesOrdered.empty()) return true;
	case 21:
		REV_GEN_POS(-1, KING);
		i = 22;
		if (!MovesOrdered.empty()) return true;
	case 22:
		REV_GEN_POS(1, KING);
		i = 23;
		if (!MovesOrdered.empty()) return true;
	case 23:
		REV_GEN_POS(9, KING);
		i = 24;
		if (!MovesOrdered.empty()) return true;
	case 24:
		REV_GEN_POS(10, KING);
		i = 25;
		if (!MovesOrdered.empty()) return true;
	case 25:
		REV_GEN_POS(11, KING);
		i = 26;
		if (!MovesOrdered.empty()) return true;
	case 26:
		break;
	}
	return false;
}
*/

bool king_in_check(Colors c)
{
	return Threatened(c, Players.positions[base_by_color(c) + KINGP]);
}
/*
// fail-soft alpha-beta search
int alphabeta(int depth, int alpha, int beta)
{
move bestmove;
int current = -WIN;
if (game over or depth <= 0) return winning score or eval();
for (each possible move m) {
make move m;
score = -alphabeta(depth - 1, -beta, -alpha)
unmake move m;
if (score >= current) {
current = score;
bestmove = m;
if (score >= alpha) alpha = score;
if (score >= beta) break;
}
}
return current;
}

int test_search(int depth, int beta)
{
move bestmove;
int current = -WIN;
if (game over or depth <= 0) return winning score or eval();
for (each possible move m) {
make move m;
score = -test_search(depth - 1, -beta+1)
unmake move m;
if (score >= current) {
current = score;
bestmove = m;
if (score >= beta) break;
}
}
return current;
}



The main difference is that with normal alpha/beta, _all_ scores you
store are >=alpha and <=beta.  With fail-soft, you store whatever is
backed up, even if it is > beta or < alpha.  When you have searched _all_
moves at a node, you have two outcomes:

(1) best score is > alpha and < beta (if it were >= beta you should have
already stopped searching.)  This is an EXACT score.

(2) best score is <= alpha.  This means this score is an upper bound,
that the true score could be lower.

int test = 0;
for (;;) {
score = test_search(depth, test+1);
if (test == score) break;
test = score;
}
RECORD TransTableEntry IS
Tag : INTEGER;
Value : INTEGER;
Bound : (LB, UB, Exact);
Depth : INTEGER;
BestMove : INTEGER;
Aged : BOOLEAN;
END;
The Tag is used to distinguish positions. The field Value stores
the search result for the corresponding node, and Bound indicates whether this is a
lower bound, upper bound, or exact. Depth stores the search depth to which the node
was searched. BestMove identifies the child that is most likely the best. If Depth is
zero, the entry caches an evaluation value, and BestMove is void. The field Aged is
used to mark the entry as being old. After the tree is searched completely and the
computer made a move, all entries in the table are marked as old. Old entries can still
be used in the next search, but if multiple positions compete for a place in the same
cache line, old entries are evicted first, as described later.

*/

#define HALF_KILLERS 8
#define NUM_KILLERS 8

RelativeMove KillerTemp[HALF_KILLERS];
void clear_killer()
{
	for (int i = 0;i < MAX_PLY;++i) {
		for (int j = 0;j < 4; ++j) BestMovePerPly[j][i].clear();
		BestMovePerPlyIndex[i] = 0;
	}
}





void add_killer(Move &c)
{
	RelativeMove m(c);
	assert(m.from <= NO_SLOT);
	int b = BestMovePerPlyIndex[CurrentPly];
	if (BestMovePerPly[(b - 1) & (HALF_KILLERS - 1)][CurrentPly] == m) return;
	for (int i = 1;i < HALF_KILLERS;++i) {
		if (BestMovePerPly[(b - 1 - i) & (HALF_KILLERS - 1)][CurrentPly] == m) {
			KillerTemp[0] = m;
			int k = 1;
			for (int j = 0;j < HALF_KILLERS;++j) {
				if (j != i) KillerTemp[k++] = BestMovePerPly[(b - 1 - j) & (HALF_KILLERS - 1)][CurrentPly];
			}
			for (int j = 0;j < HALF_KILLERS;++j) {
				BestMovePerPly[(b - 1 - j) & (HALF_KILLERS - 1)][CurrentPly] = KillerTemp[j];
			}
			return;
		}
	}
	BestMovePerPly[BestMovePerPlyIndex[CurrentPly]][CurrentPly] = m;
	BestMovePerPlyIndex[CurrentPly] = (1 + BestMovePerPlyIndex[CurrentPly]) & (HALF_KILLERS - 1);
}

bool get_killers(RelativeMove **dest, int &i)
{
	int b = BestMovePerPlyIndex[CurrentPly];
	int bn = BestMovePerPlyIndex[CurrentPly - 2];
	switch (i)
	{
	case 0:
	{
		RelativeMove &m = BestMovePerPly[(b - 1)&(HALF_KILLERS - 1)][CurrentPly];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 1:
	{
		RelativeMove &m = BestMovePerPly[(b - 2)&(HALF_KILLERS - 1)][CurrentPly];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 2:
	{
		RelativeMove &m = BestMovePerPly[(b - 3)&(HALF_KILLERS - 1)][CurrentPly];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 3:
	{
		RelativeMove &m = BestMovePerPly[(bn - 1)&(HALF_KILLERS - 1)][CurrentPly - 2];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 4:
	{
		RelativeMove &m = BestMovePerPly[(b - 4)&(HALF_KILLERS - 1)][CurrentPly];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 5:
	{
		RelativeMove &m = BestMovePerPly[(bn - 2)&(HALF_KILLERS - 1)][CurrentPly - 2];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 6:
	{
		RelativeMove &m = BestMovePerPly[(b - 5)&(HALF_KILLERS - 1)][CurrentPly];
		assert(m.from <= NO_SLOT);
		++i;
		if (!m.empty()) {
			*dest = &m;
			return true;
		}
	}
	case 7:
	{
	RelativeMove &m = BestMovePerPly[(bn - 3)&(HALF_KILLERS - 1)][CurrentPly - 2];
	assert(m.from <= NO_SLOT);
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
/*
	case 8:
	{
	RelativeMove &m = BestMovePerPly[(b - 6)&(HALF_KILLERS - 1)][CurrentPly];
	assert(m.from <= NO_SLOT);
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 9:
	{
	RelativeMove &m = BestMovePerPly[(bn - 4)&(HALF_KILLERS - 1)][CurrentPly - 2];
	assert(m.from <= NO_SLOT);
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 10:
	{
	RelativeMove &m = BestMovePerPly[(b - 7)&(HALF_KILLERS - 1)][CurrentPly];
	assert(m.from <= NO_SLOT);
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 11:
	{
	RelativeMove &m = BestMovePerPly[(b - 8)&(HALF_KILLERS - 1)][CurrentPly];
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 12:
	{
	RelativeMove &m = BestMovePerPly[(bn - 5)&(HALF_KILLERS - 1)][CurrentPly - 2];
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 13:
	{
	RelativeMove &m = BestMovePerPly[(bn - 6)&(HALF_KILLERS - 1)][CurrentPly - 2];
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 14:
	{
	RelativeMove &m = BestMovePerPly[(bn - 7)&(HALF_KILLERS - 1)][CurrentPly - 2];
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	case 15:
	{
	RelativeMove &m = BestMovePerPly[(bn - 8)&(HALF_KILLERS - 1)][CurrentPly - 2];
	++i;
	if (!m.empty()) {
	*dest = &m;
	return true;
	}
	}
	*/
	}
	return false;
}

//KillerMoves QuietKillers;
//KillerMoves CaptureKillers;

HashMove EmptyRelativeMove;
//RelativeMove CounterMoveTable[NUM_PIECE_SLOTS*(h1 - a8 + 1)*(h1 - a8 + 1)];

struct CountMoveStruct
{
	HashMove move;
	int age;
	void set(Move &m)
	{
		move = m;
		age = history_len + ClearHash;
	}
	HashMove &get()
	{
		if (history_len + ClearHash - age < 4) return move;
		return EmptyRelativeMove;
	}
	CountMoveStruct() :age(0) {}
};

CountMoveStruct EmptyCMS;

CountMoveStruct CounterMoveTable[NUM_PIECE_SLOTS*NUM_PIECE_SLOTS*(h1 - a8 + 1) * 2 * (h1 - a8 + 1)];

CountMoveStruct &CounterMove(bool quiescent, RelativeMove &r)
{
	if (r.from == NO_SLOT) return EmptyCMS;
	//	return CounterMoveTable[s + (h1 - a8 + 1)*(from - a8) + ((h1 - a8 + 1)*(h1 - a8 + 1))*(to - a8)];
	return CounterMoveTable[(r.to - a8) + (h1 - a8 + 1)*((r.from_pos - a8) + (h1 - a8 + 1)*(r.from + NUM_PIECE_SLOTS*(r.slot_taken + (quiescent ? NUM_PIECE_SLOTS : 0)
		)))];
}

//bool EnableHistory;
struct MoveGenerator
{
	enum State { Initial, Second, PositiveCaptures, DoCounterMove, Killers, AfterKillers, GeneratedMoves, BEFORE_IID, IID };
	Move killer_moves[NUM_KILLERS + 3];
	int num_killer;
	bool EnableHistory;
	int killer_iterator;
	int capture_iterator;
	bool initial_ok;
	bool second_ok;
	HashMove second_move;
	bool quiescent;
	State state;
	Colors side;
	bool history_sorted;
	int num_pin_moves;
	bool found;
	int count_positive;
	PieceSlotType last_piece_moved;
	RelativeMove last_move;
	int val;
	int depth;
	bool try_iid;
	bool gen_rest;
	int count_killers;
	void init(int d, const Move &initial, const HashMove &second, const RelativeMove &lm, int v, bool ti)
	{
		count_killers = 0;
		gen_rest = true;
		try_iid = ti;
		val = v;
		history_sorted = false;
		count_positive = 0;
		last_move = lm;
		last_piece_moved = last_move.from;
		num_pin_moves = 0;
		num_killer = 0;
		killer_iterator = 0;
		capture_iterator = 0;
		initial_ok = second_ok = false;
		depth = d;
		quiescent = (d <= 0);
		state = Initial;
		side = PlySide();
		if (!initial.empty())
		{
			initial_ok = true;
			killer_moves[num_killer++] = initial;
			second_move = second;
			if (!second.empty()) {
				second_ok = true;
			}
		}
	}
	MoveGenerator(int depth, const Move &initial, const HashMove &second, const RelativeMove &lpm, int v, bool ti)
	{
		init(depth, initial, second, lpm, v, ti);
	}
	MoveGenerator()
	{
	}
	void clean_up()
	{
		NumPinMoves[side] -= num_pin_moves;
	}
	//returns see value of move or -INF for done
	int next(Move &c, State *kind = nullptr, int *value = nullptr)
	{
		if (value != nullptr)*value = 0;
		switch (state) {
		case Initial:
			if (kind) *kind = state;
			if (initial_ok) {
				c = killer_moves[0];

				c.make();
				if (king_in_check(side)) {//illegal to make a move that leaves your king in check
					c.unmake();
				}
				else {
					state = Second;
					//initial_ok = false;
					return 1 << 10;//dummy value
				}
				--num_killer;
			}
		case Second:
			if (kind) *kind = state;
			if (second_ok) {
				if (!second_move.empty()) c = TestMove(PlySide(), Board[second_move.from], second_move.to, second_move.became);
				if (!c.empty()) {
					c.move_flags = second_move.move_flags;
					killer_moves[num_killer++] = c;
					c.make();
					if (king_in_check(side)) {//illegal to make a move that leaves your king in check
						c.unmake();
					}
					else {
						state = BEFORE_IID;
						//initial_ok = false;
						return 1 << 10;//dummy value
					}
					second_ok = false;
					--num_killer;
				}
			}
		case BEFORE_IID:
			state = IID;
			if (kind) *kind = state;
			if (quiescent //|| !try_iid
				) {
				//if (NumPins[side] != 0) {
				//	num_pin_moves = GenPinMoves(side, NumPinMoves[side], PinMoves[side],val,depth);
				//}
				QGenMoves(side, val, depth);
			}
			else {
				GenMoves(side, val, depth);
			}
			if (num_killer>0) {
				if (sort_pv(killer_moves[0])) MovesOrdered.pop();
				if (num_killer>1) {
					if (sort_pv(killer_moves[1])) MovesOrdered.pop();
				}
			}
			if (//!initial_ok && 
				try_iid) {
				return 0;
			}
		case IID:
			state = PositiveCaptures;
		case PositiveCaptures:
			if (kind) *kind = state;
			found = false;
			if (EnableHistory)
			while (MovesOrdered.find_best() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
											//			while (!MovesOrdered.empty() //|| LazyGenMove(lazy, quiescent, side, killer_moves, num_killer)
				) {
				if (MovesOrdered.best().empty()) continue;
				//				if (last_piece_moved != OFF_BOARD && MovesOrdered.best().slot_taken == last_piece_moved && MovesOrdered.best().is_enpassant()==false) continue;
				if (++count_positive > 2 ||
					MovesOrdered.best_value() >> 10 <= 0) {
					//				if (MovesOrdered.back_value() >> 10 <= 0) {
					found = true;
					break;
				}
				if (is_king(MovesOrdered.best().piece_taken)) {
					//				if (is_king(MovesOrdered.back().piece_taken)) {
					//					MovesOrdered.pop();
					continue;
				}
				//				cout << '.';
				MovesOrdered.best().make();
				//				MovesOrdered.back().make();
				if (king_in_check(side)) {//illegal to make a move that leaves your king in check
					MovesOrdered.best().unmake();
					//					MovesOrdered.back().unmake();
					//					MovesOrdered.pop();
					continue;
				}
				c = MovesOrdered.best();
				//				c = MovesOrdered.back();
				//				int v = MovesOrdered.back_value();
				int v = MovesOrdered.best_value();
				//MovesOrdered.pop();
				if (kind) *kind = state;
				return v;
			}
			//			if (CurrentPly < 7) {
			//				state = GeneratedMoves;
			//				MovesOrdered.add_history(quiescent);
			//			}
			//		else
			count_positive = -1;
#define KILLERS
#ifdef KILLERS
			state = Killers;
		case Killers:
			//if (EnableHistory && (initial_ok || depth < IID_NUM + 2))
			if (!quiescent && EnableHistory) {
				if (kind) *kind = state;
				RelativeMove *m;
				c.clear();
				int retval;
				if (count_positive == 1 && found && MovesOrdered.best_value() > QUIET_VALUE << 10
					) {
					c = MovesOrdered.best();
					retval = MovesOrdered.best_value();
					found = MovesOrdered.find_best();
				}
				bool found_killer = false;
				while (!c.empty() || get_killers(&m, killer_iterator)) {
					if (c.empty()) {
						retval = 1 << 10;
						if (Players.pieces[m->from] == EMPTY) continue;
						bool duplicate = false;
						for (int i = 0;i < num_killer;++i) if (*m == killer_moves[i]) { duplicate = true; break; }
						if (duplicate) continue;
						if (Board[m->from_pos] == m->from && (Board[m->to] == NO_SLOT || color(Board[m->to]) != side)) {
							if (!sort_pv(*m)) continue;
							c = MovesOrdered.back();
							MovesOrdered.pop();
						}
						else continue;
						if (c.empty()) continue;
						found_killer = true;
						++count_killers;
					}
					c.make();
					if (king_in_check(side)) {//illegal to make a move that leaves your king in check
						c.unmake();
						c.clear();
						continue;
					}
					if (found_killer) killer_moves[num_killer++] = c;
					//					cout << '+';
					//				if (++count_positive > 1 && found)// && (!found||MovesOrdered.best_value()>>10<=0)) || count_positive > 3)
					if (count_killers == 6)
						state = AfterKillers;
					count_positive = ((count_positive + 1) & 1);
					if (kind) *kind = state;
					return retval;//dummy value
				}
			}
#endif
			//for (int i = 0;i < num_killer;++i) {
			//	if (sort_pv(killer_moves[i])) {
			//		killer_moves[i].clear();
			//		MovesOrdered.pop();
			//	}
			//}

		case AfterKillers:
#define HISTORY_HEURISTIC
#ifdef HISTORY_HEURISTIC
			if (EnableHistory) 
				MovesOrdered.add_history(quiescent);
#endif

			//			if (found || !MovesOrdered.empty()) 
			//		state = GeneratedMoves;
			//			else return -INF;

			//			*/
			//bool LazyGenMove(int &i, bool quiescent, Colors c, Move *killer_moves, int num_killer)
			state = GeneratedMoves;

		case GeneratedMoves:
			if (kind) *kind = state;
			while (true) {
				if (!(found || MovesOrdered.find_best())) {
					if (false && gen_rest) {
						if (!try_iid && !quiescent) {
							GenQuietMoves(side, val, depth);

							for (int i = 0;i < num_killer;++i) {
								if (sort_pv(killer_moves[i])) MovesOrdered.pop();
							}
#define HISTORY_HEURISTIC
#ifdef HISTORY_HEURISTIC
							//if (//initial_ok 
							//	(!try_iid || depth < IID_NUM + 2) && EnableHistory) 
							MovesOrdered.add_history(quiescent);
#endif
							gen_rest = false;
						}
						else break;
					}
					else break;
					if (!MovesOrdered.find_best()) break;
				}

				found = false;
				if (MovesOrdered.best().empty()) continue;
				//					if (!history_sorted && MovesOrdered.best_value() <= 0) {
				//						history_sorted = true;
				//						MovesOrdered.add_history(quiescent);
				//						found = true;
				//						continue;
				//					}
				//				if (MovesOrdered.back().empty()) { MovesOrdered.pop(); continue; }

				//					if (last_piece_moved != OFF_BOARD && MovesOrdered.best().slot_taken == last_piece_moved && MovesOrdered.best().is_enpassant() == false) continue;
				//				if (is_king(MovesOrdered.back().piece_taken)) {
				if (is_king(MovesOrdered.best().piece_taken)) {
					//					MovesOrdered.pop();
					continue;
				}
				//					cout << ';';
				MovesOrdered.best().make();
				//					MovesOrdered.back().make();
				if (king_in_check(side)) {//illegal to make a move that leaves your king in check
					MovesOrdered.best().unmake();
					//						MovesOrdered.back().unmake();
					//						MovesOrdered.pop();
					continue;
				}
				c = MovesOrdered.best();
				//					c = MovesOrdered.back();
				//					int v = MovesOrdered.back_value();
				int v = MovesOrdered.best_value();
				//					MovesOrdered.pop();

				if (kind) *kind = state;
				//					return MovesOrdered.best_value();
				return v;
			}
			/*
			if (!MovesOrdered.empty()) {
			c = MovesOrdered.back();
			if (value) *value = MovesOrdered.back_value();
			c.make();
			MovesOrdered.pop();
			if (kind) *kind = state;
			return true;
			}*/
			return -INF;
		}
		return -INF;
	}
};

MoveGenerator MoveGenerators[MAX_PLY];

int CapturesC = 0;
int Checks = 0;
int Checkmates = 0;


int _perft(int d, bool partition)
{
	int nodes = 0;
	int moves = 0;
	bool check = king_in_check(PlySide());
	int e = Enpassants;
	inc_ply();
	GenMoves(other_color(PlySide()), 0, -20);
	if (d != 1) Enpassants = e;
	while (!MovesOrdered.empty()) {
		int e_2 = Enpassants;
		MovesOrdered.back().make();
		if (king_in_check(other_color(PlySide()))) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			Enpassants = e_2;
			MovesOrdered.pop();
			continue;
		}
		//		bool p = d==2 && MovesOrdered.back().from == e5 && MovesOrdered.back().to == d7;
		++moves;
		if (d > 0) {
			if (MovesOrdered.back().piece_taken != EMPTY && d == 1) ++CapturesC;
			int p_nodes = _perft(d - 1, false);
			if (partition) printf("%s %d\n", move_str(MovesOrdered.back()), p_nodes);
			nodes += p_nodes;
		}
		MovesOrdered.back().unmake();
		MovesOrdered.pop();
	}
	dec_ply();

	if (check) {
		if (d == 0 && moves == 0) ++Checkmates;
		if (d == 0) ++Checks;
	}
	if (d == 0) return 1;
	return nodes;
}

int perft(int d)
{
	CapturesC = 0;
	Checks = 0;
	Checkmates = 0;
	Enpassants = 0;
	Castles = 0;
	return _perft(d, true);
}


double inv_sqrt_table[] = {
	0,
	1,
	1 / 1.4142135624,
	1 / 1.7320508076,
	1 / 2,
	1 / 2.2360679775,
	1 / 2.4494897428,
	1 / 2.6457513111,
	1 / 2.8284271247,
	1 / 3,
	1 / 3.1622776602,
	1 / 3.3166247904,
	1 / 3.4641016151,
	1 / 3.6055512755,
	1 / 3.7416573868,
	1 / 3.8729833462,
	1 / 4,
	1 / 4.1231056256,
	1 / 4.2426406871,
	1 / 4.3588989435,
	1 / 4.472135955,
	1 / 4.582575695,
	1 / 4.6904157598,
	1 / 4.7958315233,
	1 / 4.8989794856,
	1 / 5,
	1 / 5.0990195136,
	1 / 5.1961524227,
	1 / 5.2915026221,
	1 / 5.3851648071,
	1 / 5.4772255751,
	1 / 5.5677643628,
	1 / 5.6568542495,
	1 / 5.7445626465,
	1 / 5.8309518948,
	1 / 5.9160797831,
	1 / 6,
	1 / 6.0827625303,
	1 / 6.164414003,
	1 / 6.2449979984,
	1 / 6.3245553203,
	1 / 6.4031242374,
	1 / 6.4807406984,
	1 / 6.5574385243,
	1 / 6.6332495807,
	1 / 6.7082039325,
	1 / 6.7823299831,
	1 / 6.8556546004,
	1 / 6.9282032303,
	1 / 7,
	1 / 7.0710678119,
	1 / 7.1414284285,
	1 / 7.2111025509,
	1 / 7.2801098893,
	1 / 7.3484692283,
	1 / 7.4161984871,
	1 / 7.4833147735,
	1 / 7.5498344353,
	1 / 7.6157731059,
	1 / 7.6811457479,
	1 / 7.7459666924,
	1 / 7.8102496759,
	1 / 7.874007874,
	1 / 7.9372539332,
	1 / 8,

};

#define STAND_PAT

inline bool close_to_mate(int score)
{
	return abs(abs(score) - KING_VALUE) < (KING_VALUE >> 1);
}

#define FUTILITY
#define REVERSE_FUTILITY
#define LMR
#define NULL_MOVE
//#define SIMPLE_EVAL
#define SMART_EVAL


//#define IGNORE_TT


bool USE_TT = true;

int See(Pos);

RelativeMove EmptyMove;

int CheckupNodes;


int NumFailHighNodes = 0;
int NumberOnFirstMove = 0;
int NumberOfFailHighMoves = 0;
int MinDepth;

bool InIID = false;
bool Smart = false;
int LMR_THIN_THRESHOLD;

int NegaScout(bool verify, int alpha, int beta, int d, bool late, bool somewhere_in_null, int beta_real, const RelativeMove &last_move, bool in_check, int realdepth, int extensions)
{
	PieceSlotType last_piece_moved = last_move.from;
	if (d <= 0) {
		++Nodes;
		++MidNodes;
	}
	else {
		++NCNodes;
		++NCMidNodes;
	}

	++CheckupNodes;
	if ((CheckupNodes & 1023) == 0)
		checkup();
	if (d == 0) {
		NumPinMoves[PlySide()] = 0;
	}
	Colors my_color = PlySide();
	HashTableEntry *n = nullptr;
	Move m2;
	HashMove m3;
	int move_depth = -127;
#ifndef IGNORE_TT
	//if (d>0)
	{
		n = GetOrMakeHash(d <= 0);
		int lower = n->get_lower(d);
		int upper = n->get_upper(d);
		bool hash_move_repeat = false;
		HashMove *m = &n->get_move();
		if (!m->empty()) m2 = TestMove(PlySide(), Board[m->from], m->to, m->became);
		if (!m2.empty()) {
			m2.move_flags = m->move_flags;
			move_depth = n->get_move_depth();
			inc_ply();
			m2.make();
			hash_move_repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
			if (hash_move_repeat) {
				//				upper = lower = -n->get_eval() >> 1;
				if ((CurrentPly & 1) == 0) upper = lower = -2 * PAWN_VALUE;
				else upper = lower = 2 * PAWN_VALUE;
			}
			m2.unmake();
			dec_ply();
		}
		if (!m2.empty()) {
			if (!hash_move_repeat && lower >= beta) {

				if (CurrentPly == 0) {
					if (!m2.empty()) {
//						Ply0Move = m2;
						if (d <= 0) --MidNodes; else {
							--NCMidNodes;
						}
						return lower;
					}
					else {
						lower = alpha;
						upper = beta;
					}
				}
				else {
					if (d <= 0) { --MidNodes; }
					else {
						/*
						int NumFailHighNodes = 0;
						int NumberOnFirstMove = 0;
						int NumberOfFailHighMoves = 0;
						*/
						//					++NumFailHighNodes;
						//					++NumberOnFirstMove;
						--NCMidNodes;
					}
					return lower;
				}
				;
			}
			if (!hash_move_repeat && (upper <= alpha || upper == lower)) {
				if (CurrentPly == 0) {
					if (!m2.empty()) {
						Ply0Move = m2;
						if (d <= 0) --MidNodes; else --NCMidNodes;
						return lower;
					}
					else {
						lower = alpha;
						upper = beta;
					}
				}
				else {
					if (d <= 0) --MidNodes; else --NCMidNodes;
					return upper;
				}
			}
			if (CurrentPly == 0 && Ply0Move.empty()) {
				if (!m2.empty()) {
					Ply0Move = m2;
				}
			}
			if (CurrentPly != 0) {
				alpha = __max(alpha, lower);
				beta = __min(beta, upper);
			}
		}
		else if (CurrentPly == 0) m2 = Ply0Move;

		m3 = n->second_move;
	}
	//else if (CurrentPly == 0) m2 = Ply0Move;
#endif
	int g, a;
	int second_best_value = -INF;
	const bool ninpv =
#ifdef SMART_EVAL
		InIID;
#else
#ifdef SIMPLE_EVAL
		true;
#else
		!Smart && (InIID || alpha == beta - 1);
#endif
#endif
	const int QD =
		//ninpv ? QUIESCENT_DEPTH - 6 : 
		QUIESCENT_DEPTH;
	if (d <= -QD) {
		g = (n == nullptr ? (ninpv ? simple_eval() : eval()) : n->get_eval(ninpv)); /* leaf node */
																					//if (ninpv && abs(beta - g) < PAWN_VALUE>>1) g = (n == nullptr ? eval(): n->get_eval(false));

																					//if (MinDepth<6 && last_piece_moved != OFF_BOARD) g = g - SEE(Players.positions[last_piece_moved]);
																					//if (ninpv&&last_piece_moved != OFF_BOARD) g+CALC_SEE(Players.positions[last_piece_moved]);
	}
	else {
		int val = (n == nullptr ? simple_eval() : n->get_eval(true));



		if (last_piece_moved != OFF_BOARD) val = val;// -SEE(Players.positions[last_piece_moved]);
		int lower_val = (n == nullptr ? val : (n->get_lower(-QUIESCENT_DEPTH) == -INF ? val : n->get_lower(-QUIESCENT_DEPTH)));
		lower_val = __max(lower_val, val);
		//		const bool in_check = king_in_check(PlySide());

#ifdef FUTILITY
		if (CheckForEndgame && d>0 &&
			(late||InIID||alpha == beta - 1) && 
			!in_check //&& d <= 3 
			&& !(close_to_mate(alpha) || close_to_mate(beta))) {
			if (n != nullptr && n->get_upper(d - 1) + ROOK_VALUE < alpha) {
				if (d <= 0) --MidNodes; else --NCMidNodes;
				return n->get_upper(d - 1);
			}
			//			if (n != nullptr && n->get_upper(d - 2) + QUEEN_VALUE + PAWN_VALUE< alpha) {
			//				if (d<=0) --MidNodes; else --NCMidNodes;
			//				return n->get_upper(d - 2);
			//			}
			//			if (n != nullptr && n->get_upper(d - 3) + QUEEN_VALUE + PAWN_VALUE< alpha) {
			//				if (d <= 0) --MidNodes; else --NCMidNodes;
			//				return n->get_upper(d - 2);
			//			}
			//			if (d == 1 && val + BISHOP_VALUE < alpha) return val;
			//			if (d == 2 && val + ROOK_VALUE < alpha) return val;
		}
#endif
		if (d < 1 && !in_check)
		{
			if (lower_val >= beta) {
				if (d <= 0) --MidNodes; else {
					--NCMidNodes;
				}
				return lower_val; //stand pat
			}
			//			if (n != nullptr){
			//				int l = n->get_lower(-QUIESCENT_DEPTH);
			//				if (l >= beta) {
			//					if (d <= 0) --MidNodes; else --NCMidNodes;
			//					return l;
			//				}
			//			}
		}

#ifdef REVERSE_FUTILITY
		if (CheckForEndgame && d>0 &&
			(late|| InIID || alpha == beta - 1) &&
			!in_check //&& d <= 3 
			&& !(close_to_mate(alpha) || close_to_mate(beta))) 
		{
			if (n != nullptr && n->get_lower(d - 1) - BISHOP_VALUE > beta) {
				if (d <= 0) { --MidNodes; }
				else {
					--NCMidNodes;
					//					++NumFailHighNodes;
					//					++NumberOnFirstMove;
				}
				return n->get_lower(d - 1);
			}
			if (n != nullptr && n->get_lower(d - 2) - ROOK_VALUE > beta) {
				if (d <= 0) { --MidNodes; }
				else {
					//					++NumFailHighNodes;
					//					++NumberOnFirstMove;
					--NCMidNodes;
				}
				return n->get_lower(d - 2);
			}
			/*
			if (n != nullptr && n->get_lower(d - 3) - QUEEN_VALUE - PAWN_VALUE > beta) {
			if (d <= 0) { --MidNodes; }
			else {
			//					++NumFailHighNodes;
			//					++NumberOnFirstMove;
			--NCMidNodes;
			}
			return n->get_lower(d - 3);
			}
			if (CurrentPly > 3 && d == 1 && val - BISHOP_VALUE > beta) return val;
			if (beta_real && CurrentPly > 3 && d == 2 && val - ROOK_VALUE > beta) return val;
			*/
			//if (CurrentPly > 3 && d == 1 && lower_val - BISHOP_VALUE > beta) return val;
			//			if (beta_real && CurrentPly > 3 && d == 2 && lower_val - ROOK_VALUE > beta) return val;
		}
#endif

		bool fail_high = false;
		int verify_inc = 1;
		//bool found_checks=false;
		//endgame test should be side to move has 2 or fewer minor or major pieces
#ifdef NULL_MOVE
		if (//beta_real &&
			(late|| InIID || alpha == beta - 1) &&
			val >= beta &&// - BISHOP_VALUE - PAWN_VALUE &&
			//val < beta + BISHOP_VALUE &&
			//beta != INF &&
			//!in_null 
			//!in_null
			//&&
			//			CurrentPly>1 &&
			!in_check &&
			//!SideInEndgame_for_null(my_color) &&
			d >= 3 &&
			(somewhere_in_null || RepeatList.count(my_color) < 3)
			) {
			inc_ply();
			int new_value;
			int new_depth;
			try {
				new_depth = __min(2, __max(d - 4, 1));//
				//new_depth = __max(d - 3, 1);//
													  //(d>6?d - 5: __max(d - 4, 0));
				new_value = -NegaScout(verify, -beta, -beta + 1, new_depth, false, somewhere_in_null, -alpha, EmptyMove, false, new_depth, INF);
			}
			catch (OutOfTimeException) {
				dec_ply();
				throw OutOfTime;
			}
			dec_ply();
			if (new_value >= beta-10) {
				if (!verify || InIID)//|| !SideInEndgame_for_null(my_color)) 
					return __max(beta,new_value);
				if (!SideInEndgame_for_null(my_color)) verify_inc = d- __max(d - 3, 1);
				fail_high = true;
				d-=verify_inc;
				verify=false;
//				new_value = NegaScout(beta - 1, beta, new_depth, true, true, beta, last_move, in_check, new_depth, INF);
//				if (new_value >= beta && !fail_high) {
//					if (d <= 0)  --MidNodes; else --NCMidNodes;
//					return new_value;
//				}
				//somewhere_in_null = false;
			}
		}
#endif
		if (d == 1)--NCMidNodes;
	re_search:;
		Move c;
		Move best_move, second_best_move;
		int last_depth = d - 1;
		int best_value;
		MoveGenerator::State best_move_type;

		MoveGenerator &moves = MoveGenerators[CurrentPly];
		moves.EnableHistory = true;
		moves.init(d//in_check ? (__max(1, d)) : d
			, m2, m3, last_move, val, alpha != beta - 1 && val<beta //!SideInEndgame_for_null(other_color(my_color)) //&& CheckForEndgame
																										  //||val>beta
		);
		if (d <= 0) {
			g = val; a = __max(alpha, lower_val);
		}
		else {
			g = -INF;
			a = alpha; /* save original alpha value */
		}
		inc_ply();
		int move_count = 0;
		MoveGenerator::State move_type;
		int reduced = 0;
		int iid_value;
		MovesIID.inc_ply();

		bool in_endgame = SideInEndgame(my_color);
		double sum_above_alpha = 0;
		double sum_above_inc = 7;
		int num_moves = 0;
		if (SufficientPieces == 0 && MinorPieces[LIGHT] < 2 && MinorPieces[DARK] < 2) {
			//g = 0;
			if ((CurrentPly & 1) == 1) g = -2 * PAWN_VALUE;
			//if ((CurrentPly & 1) == 1 && val > -PAWN_VALUE*3>>1 && val < PAWN_VALUE*3>>1) val1 = -PAWN_VALUE*3>>2;
			else g = 2 * PAWN_VALUE;
			if (d <= 0)  --MidNodes; else --NCMidNodes;
		}
		else {
			int move_value;
			bool other_in_check;
			RelativeMove r;

			while ((g < beta) && (g<KING_VALUE || CurrentPly == 1) && -INF != (move_value = moves.next(c, &move_type, &iid_value))) {
				int val1;
				++num_moves;
				if (move_type == MoveGenerator::IID) {
//					if (a != alpha) 
					if (beta != alpha+1)
							moves.EnableHistory = false;

					int iid_depth = d * 717 >> 10;
					if (iid_depth > d - 3) iid_depth = d - 3;
					else if (iid_depth < 1)iid_depth = 1;
					if (move_depth >= iid_depth) {
						moves.EnableHistory = true;
						//if (move_depth > d-4) EnableHistory = true;
						//else iid_depth = move_depth + 1;
					}
					if (d > IID_NUM && !moves.EnableHistory
						) {
						bool in_iid_temp = InIID;
						InIID = true;
						moves.state = MoveGenerator::GeneratedMoves;
						try {
							MovesOrdered.unmark();
							val1 = g;//(alpha != beta - 1 ? g : (beta - 1));
							while (MovesOrdered.next_unmarked())
							{
								c = MovesOrdered.best();
								if (c.empty()) continue;
								c.make();
								{
									//		intptr_t h = (intptr_t)&HashTable[((int)(Hash.low) & HASH_MASK)];
									//		intptr_t aligned = h&-64;
									//		intptr_t len = h - aligned + sizeof(HashTableEntry);
									//		_mm_prefetch((char *)(h), _MM_HINT_T0);
									//		_mm_prefetch((char *)(aligned+64), _MM_HINT_T0);
									//		_mm_prefetch((char *)(aligned+128), _MM_HINT_T0);

									//				for (intptr_t i = 0;i < len;i += 64)
									//					_mm_prefetch((char *)(i + aligned), _MM_HINT_T0);
								}

								const bool other_in_check = king_in_check(PlySide());
								//if (other_in_check) found_checks = true;
								//int val2 = -INF;
								//if (val1 != -INF) val2 = NegaScout(verify, -val1 + 1, -val1, iid_depth, false, somewhere_in_null, -a, RelativeMove(c), other_in_check, iid_depth, INF);
								//if (val2 > val1 || val2 == -INF) val2 = -NegaScout(verify, -beta, -val1, iid_depth, false, somewhere_in_null, -a, RelativeMove(c), other_in_check, iid_depth, INF);
								//if (val2 > val1) val1 = val2;
								int val2 = -NegaScout(verify, -beta, -a, iid_depth, false, somewhere_in_null, -a, RelativeMove(c), other_in_check, iid_depth, INF);
								
								//if (val2 > beta) {
								//	InIID=in_iid_temp;
								//	val2 = -NegaScout(verify, -beta, -beta+1, d-1, false, somewhere_in_null, -a, RelativeMove(c), other_in_check, realdepth-1,extensions);
								//   if (val2 > beta) {
								//		val1 = val2;
								//		goto register_move;
								//	}
								//	InIID = true;
								//	val1 = __max(val1, val2);
								//}
								MovesOrdered.unmarked_value() = (val2 - val) << 10;
								c.unmake();
							}
						}
						catch (OutOfTimeException)
						{
							c.unmake();
							MovesIID.dec_ply();
							dec_ply();
							moves.clean_up();
							throw OutOfTime;
						}
						InIID = in_iid_temp;
						MovesOrdered.unmark();
						moves.EnableHistory = false;
					}
					continue;
				}
				if (d <= 0 && (move_value < 0)) {
					c.unmake();
					break;
				}
				{
					//					intptr_t h = (intptr_t)&HashTable[((int)(Hash.low) & HASH_MASK)];
					//		intptr_t aligned = h&-64;
					//		intptr_t len = h - aligned + sizeof(HashTableEntry);
					//					_mm_prefetch((char *)(h), _MM_HINT_T0);
					//		_mm_prefetch((char *)(aligned+64), _MM_HINT_T0);
					//		_mm_prefetch((char *)(aligned+128), _MM_HINT_T0);

					//				for (intptr_t i = 0;i < len;i += 64)
					//					_mm_prefetch((char *)(i + aligned), _MM_HINT_T0);
				}
				other_in_check = king_in_check(PlySide());


				r = c;
				int delay = 0;
				++move_count;
				//moves.next calls c.make()
				int new_depth = d - 1;

				int lmr_dec = 0;   //middle
				int delay_inc = 1; //
				bool n_late = false;

//				if (d >= MinDepth - 3) { //root
//					lmr_dec = (MinDepth - 4) - d;
//					delay_inc = 1;
//				}
								   //			else 
/*
				if (//d <= 4 &&           //leaves
					d<__min(MinDepth >> 1, MinDepth - 5))
					//					d<LMR_THIN_THRESHOLD)
					//|| d<MinDepth - 7
				{
					lmr_dec = 1;
					//					delay_inc = 1;
				}
//*/
				//			if (d<MinDepth >> 2) delay_inc = 0;

				//				lmr_dec = 1;
				//				delay_inc = 0;


				if (other_in_check  || !(c.became == c.initial || is_pawn(c.became) || is_rook(c.initial) || is_king(c.initial))) {
					if (new_depth<realdepth - 1) new_depth = realdepth - 1;
					if (other_in_check && extensions < 1) {
						//++new_depth;
						++realdepth;
						++extensions;
					}
				} else if (c.move_flags == Extend && new_depth < realdepth - 2) new_depth = realdepth - 2;

				else if (new_depth<realdepth - 1 && move_value > PAWN_VALUE << 10 && move_value+val<beta_real) {
				//	if (move_value >(KNIGHT_VALUE - 2 * PAWN_VALUE) << 10) {
				//		new_depth = realdepth - 1;
				//		if (move_value >(ROOK_VALUE - 2 * PAWN_VALUE) << 10 && extensions < 1) {
				//			++realdepth;
				//			++extensions;
				//		}
				//	}
				//	else if (new_depth < realdepth - 2)
					new_depth = realdepth - 2;
				}

				//if (move_value >(ROOK_VALUE - 2 * PAWN_VALUE) << 10 && extensions < 3) {
				//					++realdepth;
				//					++extensions;
				//				}
				//bool skip_high_fail = false;
				/*

				if (move_type == MoveGenerator::IID) {
				if (++reduced > 1 && d > 3) {
				skip_high_fail = true;
				new_depth = d - 3;
				}
				else {
				new_depth = d - 2;
				if (d==2) skip_high_fail = true;
				}
				}
				else {
				delay = d > 2 && !in_check && (move_type != MoveGenerator::GeneratedMoves) && c.slot_taken == NO_SLOT && c.became == c.initial && !is_king(c.initial);
				if (delay) new_depth = d - 3;
				else new_depth = d - 1;
				}
				*/
				//				if (d < 3 && ((CurrentPly & 1) == 1) && move_count > 1 && move_type == MoveGenerator::GeneratedMoves && c.slot_taken != NO_SLOT) {
				//					c.unmake();
				//					continue;
				//				}
#ifdef LMR


				else if (!other_in_check
					&& d>0 //&& d<MinDepth-2 
					&& !in_check //&& move_type == MoveGenerator::GeneratedMoves //(iid_value >> 10 <= 0)  // || move_count>=3) 
								 //&&  a == beta - 1
					&& CurrentPly>2
					&& (c.became == c.initial || is_pawn(c.became) || is_rook(c.initial) || is_king(c.initial))
					&& !is_king(c.initial)
					&& !(is_pawn(c.initial)))
				{
					if ((move_value <= 0&& move_count > 1) || move_count > 3) n_late = true;
					if (a == beta - 1 //|| InIID
						) {
						if (c.slot_taken != NO_SLOT) {
							//non pv, non capture
							if (move_value <= 0 || move_count > 3) // && CheckForEndgame 
							{
								++reduced;
								--new_depth;
								if (d > 2 && reduced + lmr_dec > 3) {
									--new_depth;
									if (//lmr_dec>=0 && 
										d > 3 && reduced + lmr_dec * 2 > 7) {
										--new_depth;
										++delay;
										if (d > 4 && reduced + lmr_dec * 3 > 13) {
											--new_depth;
											++delay;
										}
									}
								}
							}
						}
						else {
							//non pv, capture
							if (move_value <= 0 || move_count + lmr_dec > 3) // && CheckForEndgame 
							{
								++reduced;
								--new_depth;
								delay += delay_inc;
								//if (//lmr_dec >= 0 && 
								//	d > 2 && reduced + lmr_dec > 3) {
								//	--new_depth;
									//delay += delay_inc;
								//}
							}
						}
					}
					else {
						if (c.slot_taken != NO_SLOT) {
							//pv, non capture
							if (move_value <= 0 && move_count + lmr_dec > 2) // && CheckForEndgame 
							{
								++reduced;
								--new_depth;
								//++delay;
								//if (//lmr_dec >= 0 &&
								//	d > 2 && reduced + lmr_dec > 3) {
								//	--new_depth;
									//									delay += delay_inc;
								//}
							}
						}
						else {
							//pv, capture
							if (move_value <= 0 && move_count > 2) // && CheckForEndgame 
							{
								++reduced;
								--new_depth;
								++delay;
							}
						}
					}
				}//else if (other)
				bool wasIID = InIID;
				//				if (delay>0) {
				//					InIID = true;
				//				if (alpha == beta - 1 && 

				//c.slot_taken != NO_SLOT &&
				//	d > 3 && reduced > 4 //&& move_value <=0
				//	)
				//	new_depth = d - 3; else new_depth = d - 2;
				//				}
				//				if (delay && c.slot_taken != NO_SLOT && a != beta - 1) ++new_depth;
				//				if (a != beta - 1 && (CurrentPly & 3) == 1) ++new_depth;
				//if (iid_value >> 10 <= 0 && move_count > 3) {
				//	delay = true;
				//	new_depth = d - 2;
				//}

				bool repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
				try {
#define VERIFYLMR

#ifdef VERIFYLMR
					if (!repeat && delay) {
						if (a != -INF) {
							//							val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to],other_in_check,realdepth-1);
							val1 = -NegaScout(verify, -(a + 1), -a, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
							//							val1 = -NegaScout(verify, -beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, Board[c.to],other_in_check,realdepth-1);
							if (val1 > a) {
								new_depth += delay;
								//new_depth = d - 1;
								delay = 0;
							}
						}
						else {
							//							val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to],other_in_check,realdepth-1);
							new_depth = d - 1;
							delay = 0;
						}
						delay = 0;
					}
#else
					bool wasIID = InIID;
					bool repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
					try {
#endif
#else
				bool wasIID = InIID;
				bool repeat = !somewhere_in_null && RepeatList.count(my_color) >= 3;
				try {
#endif
					last_depth = new_depth;
					if (repeat) {
						if ((CurrentPly & 1) == 1) val1 = -2 * PAWN_VALUE;
						//if ((CurrentPly & 1) == 1 && val > -PAWN_VALUE*3>>1 && val < PAWN_VALUE*3>>1) val1 = -PAWN_VALUE*3>>2;
						else val1 = 2 * PAWN_VALUE;
						++Nodes;
					}
					else if (delay != 0);

					else if (a == beta - 1) {
						val1 = -NegaScout(verify, -beta, -a, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
						//						if (new_depth!=d-1 && val1 > a) {
						//							delay = false;
						//							new_depth = d - 1;
						//							val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, Board[c.to],other_in_check,realdepth-1);
						//						}
					}
					else if (a == -INF && beta == INF //|| (d>0 && CounterMove(false, last_move).get().empty())
						) {
						//							val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, true, true, r,other_in_check,realdepth-1);
						///*
#define ASPIRATION_WINDOW
#ifdef ASPIRATION_WINDOW
						//#define TWO_PASS
#if !defined(SMART_EVAL) && !defined(SIMPLE_EVAL) && defined(TWO_PASS)

						for (int pass = 0;pass < 2;++pass) {

							if (pass == 0) {
								InIID = true;
								Smart = false;
							}
							else {
								InIID = false;
								//Smart = true;
								firstguess = val1;
							}
#else 
						const int pass = 1;
#endif
						int inc = 16;
						int low = firstguess - inc;
						int high = firstguess + inc;

						val1 = -NegaScout(verify, -high, -low, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
						if (val1 < low) {
							do {
								//inc <<= 1;
								low = val1 - inc;
								inc = inc + (inc >> 1);
								int val2 = -NegaScout(verify, -val1, -low, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
								if (val2 > val1) {
									//									 inc = (inc<<1)+val2-val1;
									val1 = val2;
								}
								else {
									val1 = val2;
									if (val1 >= low) break;
									if (pass == 0 && low - val1 < KNIGHT_VALUE >> 1) {
										val1 = (val1 + low) >> 1;
										break;
									}
								}
							} while (true);
						}
						else if (val1 >= high) {
							do {
								//								inc <<= 1;
								high = val1 + inc;
								inc = inc + (inc >> 1);
								int val2 = -NegaScout(verify, -high, -val1, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
								if (val2 < val1) {
									//									inc = (inc << 1) + val1 - val2;
									val1 = val2;
								}
								else {
									val1 = val2;
									if (val1 < high) break;
									if (pass == 0 && val1 - high < KNIGHT_VALUE >> 1) {
										val1 = (val1 + high) >> 1;
										break;
									}
								}
							} while (true);
						}
#if !defined(SMART_EVAL) && !defined(SIMPLE_EVAL) && defined TWO_PASS
						}
#endif
#else
						int inc = 16;
						int low = firstguess - inc;
						int high = firstguess + inc;
						bool afound = false;
						val1 = -NegaScout(verify, -high, -low, new_depth, false, somewhere_in_null, false, false, r, other_in_check, realdepth - 1);
						if (val1 < low) {
							//inc <<= 1;
							low = val1 - 64;
							int val2 = -NegaScout(verify, -val1, -low, new_depth, false, somewhere_in_null, true, false, r, other_in_check, realdepth - 1);

							if (val2 > val1) {
							}
							else {
								if (val2 >= low) afound = true;
							}
							val1 = val2;
						}
						else if (val1 >= high) {
							high = val1 + 32;
							int val2 = -NegaScout(verify, -high, -val1, new_depth, false, somewhere_in_null, false, true, r, other_in_check, realdepth - 1);
							if (val2 < val1) {
							}
							else {
								if (val2 < high) afound = true;
							}
							val1 = val2;
						}
						if (!afound) {
							val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, true, true, r, other_in_check, other_in_check, realdepth - 1);
						}
#endif
						//*/
						/*
						val1 = -NegaScout(verify, -(firstguess+1), -firstguess, new_depth, false, somewhere_in_null, false, false, r,other_in_check,realdepth-1);
						if (val1<firstguess) {
						do {
						firstguess = __min(val1,firstguess);
						val1 = -NegaScout(verify, -(firstguess + 1), -firstguess, new_depth, false, somewhere_in_null, false, false, r,other_in_check,realdepth-1);
						} while (val1 < firstguess);
						}
						else {
						do {
						firstguess = __max(val1,firstguess);
						val1 = -NegaScout(verify, -(firstguess + 1), -firstguess, new_depth, false, somewhere_in_null, false, false, r,other_in_check,realdepth-1);
						} while (val1 >= firstguess);
						}
						*/
					}
					else {
						if (a == -INF) {
							val1 = -NegaScout(verify, -beta, -beta + 1, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
							//							if (new_depth != d - 1 && val1 > a) {
							//								delay = false;
							//								new_depth = d - 1;
							//								val1 = -NegaScout(verify, -beta, -beta + 1, new_depth, false, somewhere_in_null, true, false, Board[c.to],other_in_check,realdepth-1);
							//							}
							if (val1 < beta) {
								val1 = -NegaScout(verify, -val1, -a, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
								//								int low, inc = 16;
								//								do {
								//									low = val1 - inc;
								//									inc = inc +(inc>> 1);
								//									val1 = -NegaScout(verify, -val1, -low, new_depth, false, somewhere_in_null, true, false, r,other_in_check,realdepth-1);
								//								} while (val1 < low);
							}
						}
						else if (beta == INF) {
#ifdef ASPIRATION_WINDOW
							val1 = -NegaScout(verify, -(a + 1), -a, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
							if (val1 >= a) {
								int inc = 16;
								do {
									int val2 = -NegaScout(verify, -(val1 + inc), -val1, new_depth, false, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
									inc += inc >> 1;
									if (val2 < val1) {
										//										inc = (inc<<1)+(val2-val1);
										//										val1 = val2;
									}
									else {
										if (val2 <= val1 + inc) {
											val1 = val2;
											break;
										}
									}
									val1 = val2;
								} while (true);
								//								if (abs(val2 - val1) < PAWN_VALUE) val1 = (val1 + val2) >> 1;
								//								else val1 = -NegaScout(verify, -val2, -val1, new_depth, false, somewhere_in_null, true, false, r,other_in_check,realdepth-1);
							}
#else
							val1 = -NegaScout(verify, -(a + 1), -a, new_depth, false, somewhere_in_null, false, alpha_real, r, other_in_check, realdepth - 1);
							bool afound = false;
							if (val1 >= a) {
								int inc = 32;
								int val2 = -NegaScout(verify, -(val1 + inc), -val1, new_depth, false, somewhere_in_null, false, true, r, other_in_check, realdepth - 1);
								//inc += inc >> 1;
								if (val2 < val1) {
									val1 = a;
								}
								else {
									if (val2 <= val1 + inc) {
										afound = true;
									}
								}
								val1 = val2;
								if (!afound) {
									val2 = -NegaScout(verify, -beta, -val1, new_depth, false, somewhere_in_null, beta_real, alpha_real, r, other_in_check, realdepth - 1);
									if (val2 < val1) val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, r, other_in_check, realdepth - 1);
									else val1 = val2;
								}
							}
#endif
						}
						else {
							//#define BINARY_SCOUT
#ifdef BINARY_SCOUT
							int val2;
							val1 = -NegaScout(verify, -(a + 1), -(a), new_depth, false, somewhere_in_null, false, alpha_real, r, other_in_check, realdepth - 1);
							if (val1 < beta && val1 >= a) {
								val2 = -NegaScout(verify, -beta, -beta + 1, new_depth, false, somewhere_in_null, beta_real, alpha_real, r, other_in_check, realdepth - 1);
								int count = 0;
								while (abs(val1 - val2)>20) {
									if (++count > 0) {
										val1 = val2 = -NegaScout(verify, -val2, -val1 + 1, new_depth, false, somewhere_in_null, beta_real, alpha_real, r, other_in_check, realdepth - 1);
										break;
									}
									int between = (val1 + val2) >> 1;
									int m = -NegaScout(verify, -between, -between + 1, new_depth, false, somewhere_in_null, beta_real, alpha_real, r, other_in_check, realdepth - 1);
									if (m <= val1) break;
									if (m >= val2) {
										val1 = val2;
										break;
									}
									if (m >= between) {
										val2 = m;
									}
									else {
										val1 = m;
									}
								}
								val1 = (val1 + val2) >> 1;
								//								if (val2 < val1) val1 = -NegaScout(verify, -beta, -a, new_depth, false, somewhere_in_null, beta_real, alpha_real, r);
								//								else val1 = val2;
							}
#else
#ifdef SIMPLE_EVAL
#define MARGIN 0
#else
#define MARGIN PAWN_VALUE
#endif
							int val2;
							val1 = -NegaScout(verify, -(a + 1), -(a), new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
							bool interesting;
#ifdef SMART_EVAL
							interesting = val1 < beta && val1 >= a;
#else
							if (InIID || Smart) interesting = val1 < beta && val1 >= a;
							else interesting = val1 < beta + MARGIN && val1 >= a - MARGIN;
#endif
							if (interesting) {
								val2 = -NegaScout(verify, -beta, -val1, new_depth, n_late, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
								if (val2 < val1) val1 = -NegaScout(verify, -val2, -a, new_depth, false, somewhere_in_null, -a, r, other_in_check, realdepth - 1, extensions);
								else val1 = val2;
							}
#endif
						}
					}
					//if (delay) MovesIID.push(c, val1);
					//else r
				}
				catch (OutOfTimeException)
				{
					c.unmake();
					MovesIID.dec_ply();
					dec_ply();
					moves.clean_up();
					throw OutOfTime;
				}
			register_move:
				if (val1 > g) {
					g = val1;
					second_best_move = best_move;
					best_move = c;
					best_move_type = move_type;
					if (CurrentPly == 1) Ply0Move = c;
					best_value = move_value;
				}
				if (g > a) {
					a = g;
				}
				InIID = wasIID;
				c.unmake();
			}

			if (g >= beta && second_best_move.empty() && !MovesOrdered.empty() && (moves.found || MovesOrdered.find_best())) {
				second_best_move = MovesOrdered.best();
			}

			if (!c.empty() && move_count == 1 && g < beta && CurrentPly + realdepth<MAX_MOVES + QUIESCENT_DEPTH + 1) {
				c.make();
				int val1;
				try {
					int val2;
					val1 = -NegaScout(verify, -(a + 1), -(a), last_depth + 1, false, somewhere_in_null, -a, r, other_in_check, realdepth, extensions);
					if (val1 < beta && val1 >= a) {
						val2 = -NegaScout(verify, -beta, -val1, last_depth + 1, false, somewhere_in_null, -a, r, other_in_check, realdepth, extensions);
						if (val2 < val1) val1 = -NegaScout(verify, -beta, -a, last_depth + 1, false, somewhere_in_null, -a, r, other_in_check, realdepth, extensions);
						else val1 = val2;
					}
				}
				catch (OutOfTimeException)
				{
					c.unmake();
					MovesIID.dec_ply();
					dec_ply();
					moves.clean_up();
					throw OutOfTime;
				}
				c.unmake();
				if (alpha + 1 != beta) {
					if (val1 >= alpha) {
						sum_above_alpha += sum_above_inc;
						sum_above_inc *= .82;
						//if (EnableHistory) {
						//	GetHH(d <= 0, r).set(d + QUIESCENT_DEPTH + 1, 1);
						//}
					}
				}
				if (val1 > g) {
					second_best_value = g;
					g = val1;
					second_best_move = best_move;
					best_move = c;
					best_value = move_value;
					best_move_type = move_type;
					if (CurrentPly == 1) Ply0Move = c;
				}
				else if (val1 > second_best_value) second_best_value = val1;
				if (g > a) {
					a = g;
				}
			}
		}
		moves.clean_up();
		MovesIID.dec_ply();

		if ((g < beta) && fail_high) {
			d += verify_inc;
			fail_high = false;
			verify = true;
			dec_ply();
			goto re_search;
		}
		if (g >= beta) {
			if (num_moves) ++FailHighCount;
			FailHighTotal += num_moves;

			++NumFailHighNodes;
			if (move_count == 1) ++NumberOnFirstMove;
		}
		else if (g>alpha) {
			//g -= g >> 5;
			if (second_best_value != -INF && second_best_value >= alpha && d>0 //&& g < beta// && (CurrentPly&1)!=0
				) {
				//g = __min(beta_real-1,g + (sum_above_alpha*2/sqrt_table[d]));
				g = g + sum_above_alpha *inv_sqrt_table[d];
				//else g += ((second_best_value * 0.04)
				//	+ sum_above_alpha);
			}
			;
		}

		/*		if (//(g >= beta || d<=0) &&
		!best_move.empty() //&& (best_move.slot_taken == NO_SLOT  || d<=0)
		&& !last_move.empty()
		//&& d>0
		) {
		CounterMove(d<=0,last_move).set(best_move);
		}
		*/
#ifdef HISTORY_HEURISTIC
		//if (!best_move.empty()) GetHH(d <= 0, RelativeMove(best_move)).set(d + QUIESCENT_DEPTH + 1, (g >= beta ? 4 : 1));
		if (g >= beta && !best_move.empty()) GetHH(d <= 0, RelativeMove(best_move)).set(d + QUIESCENT_DEPTH + 1, 4);

		//		if (!best_move.empty()) GetHH(d <= 0, RelativeMove(best_move)).set((d + QUIESCENT_DEPTH + 1) << (g >= beta ?
		//			2//(beta_real ? 2 : 1) 
		//			: 0));
#endif

#ifdef KILLERS
		if (g >= beta &&
			!best_move.empty() //&& best_value >> 10 <= 0
			&& best_move.piece_taken == EMPTY//best_move_type == MoveGenerator::GeneratedMoves //&& d>0 
			) {
			add_killer(best_move);
		}
#endif
		dec_ply();
#ifndef IGNORE_TT

		if (n != nullptr && !(n->key == Hash)) {
			if (alpha != beta - 1) n = GetOrMakeHash(d <= 0);
			else n = nullptr;
		}
#endif
		if (n != nullptr && !best_move.empty()) {
			//			if (!(Hash == n->key)) n = nullptr;
			//			else 
			n->set_move(best_move, d);
			if (!second_best_move.empty()) n->second_move = second_best_move;
		}
		if (g == -INF) {
#ifdef SMART_EVAL
			if (d < 1) return (n == nullptr ? (ninpv ? simple_eval() : eval()) : n->get_eval(ninpv));
#else
#ifdef SIMPLE_EVAL
			if (d < 1) return (n == nullptr ? simple_eval() : n->get_eval(true));
#else
			if (d < 1) return (n == nullptr ? (ninpv ? simple_eval() : eval()) : n->get_eval(alpha == beta - 1));
#endif
#endif
			if (in_check) return -KING_VALUE - d - QUIESCENT_DEPTH;//includes waiting penalty
			return 0;
		}
	}


	if (n != nullptr)// && n->key == Hash)
	{
		/* Traditional transposition table storing of bounds */
		/* Fail high result implies a lower bound */
		//n->singular = false;
		if (g >= beta) {
			//if (beta_real)
			{
				n->set_lower(d, g);
				n->lower_exact = false;
			}
		}
		/* Fail low result implies an upper bound */
		else if (g <= alpha) {
			//if (alpha_real) 
			{
				n->set_upper(d, g);
				n->upper_exact = false;
			}
		}
		/* Found an accurate minimax value - will not occur if called with zero window */
		else {
			//if(alpha_real) 
			n->set_lower(d, g);
			//if (beta_real) 
			n->set_upper(d, g);
			//if (alpha_real && beta_real) 
			n->upper_exact = n->lower_exact =
#ifdef SIMPLE_EVAL
				true;
#else
				!ninpv;
#endif
			//	if (g - second_best_value >= PAWN_VALUE >> 1)n->singular = true;
		}
	}
	return g;
}


int MTDF(int g, int d)
{
	//LMR_THIN_THRESHOLD = __max(MinDepth / 3, MinDepth - 5);
	InIID = false;
	Smart = false;
	const bool other_in_check = king_in_check(PlySide());
	return NegaScout(true, -INF, INF, d, false, false, INF, RelativeMove(), other_in_check, d + 1, 0);
	int upperbound = INF;
	int lowerbound = -INF;
	do {
		int beta;
		if (g == lowerbound) beta = g + 1; else beta = g;
		assert(CurrentPly == 0);
		g = NegaScout(true, beta - 1, beta, d, false, false, beta, RelativeMove(), other_in_check, d, 0);
		assert(CurrentPly == 0);
		if (g < beta) upperbound = g; else lowerbound = g;
	} while (lowerbound < upperbound);
	return g;
}

int DepthIncBy = 0;
int TimeExtendCounter = 0;
int MaxTime;
int StartTime;
int MaxDepth;
int TimeIncBy = 0;
int Clock;
bool TimeExtended;
bool add_time()
{
	if (MaxDepth == MAX_PLY) {
		if (Clock > MaxTime << 4) {
			Clock -= MaxTime;
			TimeIncBy += MaxTime;
			StopTime += MaxTime;
			TimeExtended = true;
			//			printf("-t");
		}
		else return false;
	}
	else {
		DepthIncBy += 1;
		MaxDepth += 1;
		//		printf("-d");
	}
	++TimeExtendCounter;
	return true;
}
bool extended_time()
{
	return DepthIncBy != 0 || TimeIncBy != 0;
}
void restore_time()
{
	TimeExtendCounter = 0;
	MaxDepth -= DepthIncBy;
	DepthIncBy = 0;
	TimeIncBy = 0;
}

bool test_extend_time(int x)
{
	return false;
	if (x < PAWN_VALUE - (PAWN_VALUE >> 2) && first_guess() - x >= PAWN_VALUE - (PAWN_VALUE >> 2)) {
		int limit;
		if (x >= ROOK_VALUE - (PAWN_VALUE >> 2)) limit = 20;
		else if (x > KNIGHT_VALUE - (PAWN_VALUE >> 2)) limit = 15;
		else limit = 8;
		if (TimeExtendCounter >= limit) {
			return false;
		}
		return add_time();
	}
	return false;
}


void endgame_check()
{
	if (!CheckForEndgame) return;
	if (SideInEndgame(LIGHT) && SideInEndgame(DARK)) {

		for (int i = LIGHT_PAWN1; i < NUM_PIECE_SLOTS; ++i) if (Players.pieces[i]!=EMPTY) sub_value(PlySide(), (PieceSlotType)i);
		CheckForEndgame = false;
		for (int i = LIGHT_PAWN1; i < NUM_PIECE_SLOTS; ++i) if (Players.pieces[i] != EMPTY) add_value(PlySide(), (PieceSlotType)i);
		EndGamePoint = history_len; //for takeback
		ClearHash += MAX_MOVES * 2;
	}
}

void think(int output)
{
	NumFailHighNodes = 0;
	NumberOnFirstMove = 0;

	USE_TT = true;
	EphemeralValue *= .94;
	TimeExtended = false;
	int i, j, x;
	for (i = 0;i < MAX_PLY - 2;++i) {
		for (j = 0;j < 4; ++j) {
			//			CaptureKillers.BestMovePerPly[j][i].clear();
			BestMovePerPly[j][i] = BestMovePerPly[j][i + 2];
		}
		//		CaptureKillers.BestMovePerPlyIndex[i] = 0;
		BestMovePerPlyIndex[i] = BestMovePerPlyIndex[i + 2];
	}
	for (;i < MAX_PLY;++i) {
		for (j = 0;j < 4; ++j) {
			//			CaptureKillers.BestMovePerPly[j][i].clear();
			BestMovePerPly[j][i].clear();
		}
		//		CaptureKillers.BestMovePerPlyIndex[i] = 0;
		BestMovePerPlyIndex[i] = 0;
	}
	Ply0Move.clear();

	/*
	if (!DisableBook && book_move()) {
	pv[0][0] = MovesOrdered.back();
	MovesOrdered.clear();
	return;
	}
	*/
	endgame_check();

	TimedOut = false;
	StartTime = get_ms();
	StopTime = StartTime + MaxTime;
	Nodes = 0;
	MidNodes = 0;
	NCNodes = 0;
	NCMidNodes = 0;
	//	memset(history, 0, sizeof(history));
	if (output == 1)
		printf("ply      nodes  score  pv\n");
	for (i = 1; i <= __min(MaxDepth, MAX_PLY - 21); ++i) {
		//		if (i == 5)USE_TT = true;

		//if (i < 6) QUIESCENT_DEPTH = 5;//5;
		//else
			QUIESCENT_DEPTH = 5;//11;

		MinDepth = i;
		HashType test = Hash;
		try {
			x = MTDF(firstguess, i);
//			assert(test == Hash);
			Ply0Alpha = x;
			firstguess = x;
		}
		catch (OutOfTimeException)
		{
			assert(CurrentPly == 0);
			break;
		}

		//get principle variation
		pv[0] = Ply0Move;
		if (Ply0Move.empty())
		{
			pv_length = 0;
		}
		else {
			pv_length = 1;

			for (j = 0;j < MAX_PLY - 2;++j) {
				pv[j].make();
				inc_ply();
				HashTableEntry *e = GetHash(false);
				if (e != nullptr) {
					HashMove *m = &(e->get_move());
					if (!m->empty()) {
						Move c = TestMove(PlySide(), Board[m->from], m->to, m->became);
						if (!c.empty()) {
							c.move_flags = m->move_flags;
							pv[j + 1] = c;
							pv_length = j + 2;
							continue;
						}
					}
				}
				break;
			}
			while (CurrentPly != 0) {
				dec_ply();
				pv[CurrentPly].unmake();
			}
//			assert(test == Hash);
		}
		//4000

		double failhigh = 0;
		static int numfailhigh = 1;
		if (NumFailHighNodes != 0) {
			failhigh = (double)NumberOnFirstMove / NumFailHighNodes;
			//++numfailhigh;
		}
		int y = x;
		if (y > 500) y = 500;
		if (y < -500) y = -500;
		int end_time = get_ms();
		if (output == 1)
			printf("%3d  %9d  %7d  %5d %f nps ", i, Nodes, (pv[0].from / 10 - 2) * 8 + (pv[0].from % 10 - 1), y * 20, Nodes*1000.0 / (end_time - StartTime));   // @ED
		else if (output == 2) {
			printf("%d %d %d %d %.4g %.2g %.2g %.2g",
				MinDepth, x, (end_time - StartTime) / 10, Nodes, (double)FailHighTotal / FailHighCount,

				(double)Nodes / MidNodes, (double)NCNodes / NCMidNodes, failhigh / numfailhigh
			);
			LOG(Log << "depth:" << MinDepth << " score" << x << " time:" << (end_time - StartTime) / 10 << " Nodes:" << Nodes << " median branching factor quiescent:" << (double)Nodes / MidNodes << " median branching factor:" << (double)NCNodes / NCMidNodes << " fail high on first:" << (double)NumberOnFirstMove / NumFailHighNodes) << endl;
		}
		if (output) {
			for (j = 0; j < pv_length; ++j) {
				if (pv[j].empty()) break;
				printf(" %s", move_str(pv[j]));
			}
		}

		printf("\n");
		fflush(stdout);

		if (TimedOut || x >= KING_VALUE || x <= -KING_VALUE)
			break;
	};
	if (extended_time()) { LOG(Log << "extended time " << MaxTime << endl); }
	LOG(Log << "computer moved at " << move_str(pv[0]) << endl);
	restore_time();
	if (TimeExtended) set_first_guess(Ply0Alpha);
	else add_first_guess(Ply0Alpha);
}

bool whitespace(char i)
{
	return i == ' ' || i == '\t' || i == '\n' || i == '\r' || i == '\v' || i == '\f';
}

char *gets(char *str, int num) {
	return fgets(str, num, stdin);
}

void takeback()
{
	if (history_len == 0) return;
	int hl = history_len;
	Move temp[MAX_MOVES];
	for (int i = 0;i < history_len;++i) temp[i] = History[i];
	int side = PlySide();
	init_board();
	for (int i = 0;i < hl - 1;++i) {
		set_side(other_color(PlySide()));
		temp[i].make();
		History[history_len++] = temp[i];
	}
}

bool make_move(Move &m)
{
	set_side(other_color(PlySide()));
	m.make();
	if (king_in_check(other_color(PlySide()))) {//illegal to make a move that leaves your king in check
		m.unmake();
		set_side(other_color(PlySide()));
		return false;
	}
	return true;
}

#define SAFETY_MARGIN 100
#define CLOCK_SAFETY_MARGIN 100

int control_period, control_period_original, time_base_min, time_base_sec, time_inc, _time_base;
int exact_time;
bool roll_over_check;
int roll_over_increment;
void xboard()
{
	char line[256], command[256];
	int m;
	int post = 0;

	control_period = 0; time_base_min = 0; time_base_sec = 0; time_inc = 0; _time_base = 0; Clock = 0, exact_time = 0;

	printf("\n");
	init_board();
	log_board();
	//	gen();
	computer_side = NO_COLOR;
	for (;;) {
		fflush(stdout);
		if (PlySide() == computer_side) {
			if (MaxDepth != MAX_PLY) {
				LOG(Log << "using depth " << MaxDepth << endl;);
				MaxTime = 1 << 25;
			}
			else
				if (exact_time != 0) {
					LOG(Log << "using exact time " << exact_time << endl);
					MaxTime = exact_time;
				}
				else {
					if (control_period != 0) {
						LOG(Log << "control_period " << control_period << " Clock " << Clock << " time_inc " << time_inc << endl);
						//MaxTime = (Clock- SAFETY_MARGIN) / (abs(control_period)*3>>1);
						MaxTime =(int)(.5+.95*(Clock - CLOCK_SAFETY_MARGIN) / (abs(control_period)));
						if (MaxTime <= 0) {
							if (time_inc > 0) MaxTime = 0;
							else MaxTime = (int)(.5 + .95*(Clock / abs(control_period)));
						}
						Clock -= MaxTime;
						if (Clock <= SAFETY_MARGIN) {
							if (time_inc > SAFETY_MARGIN) MaxTime += (int)(.5 + .95*(time_inc - SAFETY_MARGIN));
							else MaxTime += 7 * time_inc >> 3;
						}
						else if (time_inc > SAFETY_MARGIN)
							MaxTime += time_inc - SAFETY_MARGIN;
						else MaxTime += 7 * time_inc >> 3;
						if (control_period > 0) {
							--control_period;
							if (control_period == 0) control_period = control_period_original;
						}
						else {
							if (control_period < -30) ++control_period;
						}
					}
					else {
						LOG(Log << "Clock " << Clock << " time_inc " << time_inc << endl);
						MaxTime = (Clock - SAFETY_MARGIN) / 25;
						Clock -= MaxTime;
						if (Clock <= SAFETY_MARGIN) {
							if (time_inc > SAFETY_MARGIN) MaxTime += (int)(.5 + .95*(time_inc - SAFETY_MARGIN));
							else MaxTime += (time_inc >> 1);
						}
						else MaxTime += (int)(.5 + .95*(time_inc));
					}
				}
				LOG(Log << "MaxTime " << MaxTime << endl);
				think(post);
				if (pv[0].empty()) {
					//				set_side(other_color(PlySide()));//??
					//				print_result();
					computer_side = NO_COLOR;
					continue;
				}
				printf("move %s\n", move_str(pv[0]));
				set_side(other_color(PlySide()));//??
				pv[0].make();
				History[history_len++] = pv[0];

				//			print_result();
				log_board();
				continue;
		}
		if (!gets(line, 256))
			return;
		if (line[0] == '\n')
			continue;
		sscanf(line, "%s", command);
		LOG(Log << "recieved \"" << line << "\"\n");
		if (!strcmp(command, "xboard"))
			continue;
		if (!strcmp(command, "new")) {
			init_board();
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "quit"))
			return;
		if (!strcmp(command, "force")) {
			computer_side = NO_COLOR;
			continue;
		}
		if (!strcmp(command, "white")) {
			set_side(LIGHT);
			computer_side = DARK;
			continue;
		}
		if (!strcmp(command, "black")) {
			set_side(DARK);
			computer_side = LIGHT;
			continue;
		}
		char extra[256];
		if (!strcmp(command, "level")) {
			int read = sscanf(line, "level %d %d:%d %d", &control_period, &time_base_min, &time_base_sec, &time_inc);
			control_period_original = control_period;
			LOG(Log << "read " << read << endl);
			if (read < 4) {
				LOG(Log << "no seconds\n");
				time_base_sec = 0;
				sscanf(line, "level %d %d %d", &control_period, &time_base_min, &time_inc);
			}
			LOG(Log << "control_period " << control_period << " time_base_min " << time_base_min << "time_base_sec" << time_base_sec << " extra " << extra << " time_inc " << time_inc << endl);
			_time_base = (time_base_min * 60 + time_base_sec) * 1000;
			LOG(Log << " Clock was " << Clock << endl);
			Clock = _time_base;
			LOG(Log << " Clock assumed to be " << Clock << endl);
			//if (_time_base != 0 && control_period_original == 0) control_period = -50;
			if (control_period != 0) {
				roll_over_check = true;
				roll_over_increment = _time_base + time_inc;
			}
			time_inc *= 1000;
			exact_time = 0;
			continue;
		}
		if (!strcmp(command, "st")) {
			sscanf(line, "st %d", &exact_time);
			exact_time *= 1000;
			_time_base = 0; time_inc = 0;control_period = 0;
			LOG(Log << " exact time set " << exact_time << endl);
			//MaxTime = MaxTime / 2;
#ifndef DISABLE_TIME
			MaxDepth = MAX_PLY;
#endif
			continue;
		}
		if (!strcmp(command, "sd")) {
			sscanf(line, "sd %d", &MaxDepth);
		
			MaxTime = 1 << 25;
			continue;
		}
		if (!strcmp(command, "time")) {
			int clock_temp;
			sscanf(line, "time %d", &clock_temp);
			clock_temp *= 10;
			if (roll_over_check) {
				;			if (fabs((double)(clock_temp - Clock) / roll_over_increment - 1.0) < .1 && fabs((double)(clock_temp - Clock) / roll_over_increment - 1.0) < fabs((double)(clock_temp - Clock) / time_inc - 1.0)) {
					LOG(Log << "roll over assumed at " << control_period << endl);
					control_period = control_period_original;
				}
			}
			Clock = clock_temp;
			LOG(Log << " Clock " << Clock << endl);
			//MaxTime /= 30;
			//MaxTime = MaxTime / 2;
#ifndef DISABLE_TIME
			//			MaxDepth = 32;
#endif
			continue;
		}
		if (!strcmp(command, "otim")) {
			continue;
		}
		if (!strcmp(command, "go")) {
			computer_side = PlySide();
			continue;
		}
		if (!strcmp(command, "hint")) {
			think(0);
			if (pv[0].empty())
				continue;
			printf("Hint: %s\n", move_str(pv[0]));
			continue;
		}
		if (!strcmp(command, "undo")) {
			if (history_len == 0)
				continue;
			computer_side = NO_COLOR;
			takeback();
			continue;
		}
		if (!strcmp(command, "remove")) {
			if (history_len >= 2)
				takeback();
			takeback();
			continue;
		}
		if (!strcmp(command, "post")) {
			post = 2;
			continue;
		}
		if (!strcmp(command, "nopost")) {
			post = 0;
			continue;
		}
		Move move;
		LOG(Log << "Parse move " << line << endl);
		//m = parse_move(move, line);
		if (!parse_move(move, line) || !make_move(move)) {
			printf("Error (unknown command): %s\n", command);
			LOG(Log << "Error (unknown command): " << command << endl);
		}
		else {
			History[history_len++] = move;

			//			print_result();
			log_board();
		}
	}
}

void print_result()
{
	return;
	GenMoves(PlySide(), 0, -20);
	while (!MovesOrdered.empty()) {
		MovesOrdered.back().make();
		if (king_in_check(PlySide())) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			MovesOrdered.pop();
			continue;
		}
		MovesOrdered.back().unmake();
		MovesOrdered.clear();
		return;
	}
	//no legal moves
	if (king_in_check(PlySide())) {
		if (PlySide() == LIGHT) {
			printf("0-1 {Black mates}\n");
			LOG(Log << "0-1 {Black mates}\n");
		}
		else {
			printf("1-0 {White mates}\n");
			LOG(Log << "1-0 {White mates}\n");
		}
	}
	else {
		printf("1/2-1/2 {Stalemate}\n");
		LOG(Log << "1/2-1/2 {Stalemate}\n");
	}
	//no test for repetitions or 50 move rule yet {}{}{}
}

void test_init();
char s[256];
char s2[30];
void test_params();
void fen_problem_set();

int mainish()
{
	int computer_side;
	int m;

	printf("\n");
	printf("Small Chess by Josh Scholar\n");
	printf("version 1.0,\n");
	printf("\n");
	printf("\"help\" displays a list of commands.\n");
	printf("\n");

	computer_side = NO_COLOR;
	MaxTime = 1 << 25;
	MaxDepth = 7;
	char * p = s;
	char *p2;
	*p = 0;
	for (;;) {
		if (PlySide() == computer_side) {  /* computer's turn */
			print_board();
			log_board();

			//			board_consistent();						  /* think about the move and make it */
			//			eval();
			//			piece_threats();
			think(2);//1 for original format
			if (pv[0].empty()) {
				LOG(Log << "(no legal moves)\n");
				printf("(no legal moves)\n");
				computer_side = NO_COLOR;
				continue;
			}

			printf("Computer's move: %s\n", move_str(pv[0]));
			LOG(Log << "Computer's move: " << move_str(pv[0]) << (PlySide() == LIGHT ? " Light" : " Dark") << endl);
			//			board_consistent();

			set_side(other_color(PlySide()));//??
			pv[0].make();
			History[history_len++] = pv[0];

			print_result();
			continue;
		}

		/* get user input */
		printf("> ");
		while (whitespace(*p))++p;
		if (*p == 0) {
			gets(s, 256);
			p = s;
			while (whitespace(*p))++p;
		}
		s2[0] = 0;
		p2 = s2;
		while (!whitespace(*p) && *p != 0)*p2++ = *p++;
		*p2 = 0;
		// return 0;
		if (!strcmp(s2, "on")) {
			computer_side = PlySide();
			continue;
		}
		if (!strcmp(s2, "off")) {
			computer_side = NO_COLOR;
			continue;
		}
		if (!strcmp(s2, "tune")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			cout << HistoryParam << " " << HistoryNotBetaParam << endl;
			sscanf(s2, "%lf,%lf", &HistoryParam, &HistoryNotBetaParam);
			cout << "to:" << HistoryParam << " " << HistoryNotBetaParam << endl;
			test_params();
			continue;

		}
		if (!strcmp(s2, "st")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &MaxTime);
			MaxTime *= 1000;
#ifndef DISABLE_TIME
			MaxDepth = MAX_PLY;
#endif
			printf("Time %d\n", MaxTime);
			continue;
		}
		if (!strcmp(s2, "sd")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &MaxDepth);
			MaxTime = 1 << 25;
			continue;
		}
		if (!strcmp(s2, "undo")) {
			if (history_len == 0)
				continue;
			computer_side = NO_COLOR;
			takeback();
			continue;
		}
		if (!strcmp(s2, "new")) {
			computer_side = NO_COLOR;
			init_board();
			continue;
		}
		
		if (!strcmp(s2, "wac")) {
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &MaxTime);
			MaxTime *= 1000;
#ifndef DISABLE_TIME
			MaxDepth = MAX_PLY;
#endif
			printf("Time %d\n", MaxTime);
			fen_problem_set();
			continue;
		}

		if (!strcmp(s2, "test")) {
			test_init();
			continue;
		}
		if (!strcmp(s2, "perft")) {
			//			test_init();
			int depth;
			while (whitespace(*p))++p;
			p2 = s2;
			s2[0] = 0;
			while (!whitespace(*p) && *p != 0)*p2++ = *p++;
			*p2 = 0;
			sscanf(s2, "%d", &depth);
			cout << "perft " << depth << " =" << perft(depth) << endl;
			cout << "Checks = " << Checks << " Captures = " << CapturesC << " Checkmates = " << Checkmates << " en passant = " << Enpassants << " Castles = " << Castles << endl;
			continue;
		}
		if (!strcmp(s2, "d")) {
			print_board();
			continue;
		}
		if (!strcmp(s2, "bye")) {
			printf("Share and enjoy!\n");
			break;
		}
		if (!strcmp(s2, "xboard")) {
			MaxDepth = MAX_PLY;
			xboard();
			break;
		}
		if (!strcmp(s2, "help")) {
			printf("on - computer plays for the side to move\n");
			printf("off - computer stops playing\n");
			printf("st n - search for n seconds per move\n");
			printf("sd n - search n ply per move\n");
			printf("undo - takes back a move\n");
			printf("new - starts a new game\n");
			printf("d - display the board\n");
			printf("bye - exit the program\n");
			printf("Enter moves in coordinate notation, e.g., e2e4, e7e8Q\n");
			continue;
		}

		/* maybe the user entered a move? */
		Move move;
		m = parse_move(move, s2);
		if (!parse_move(move, s2) || !make_move(move))
			printf("Illegal move.\n");
		else {
			LOG(Log << "User move " << s2 << endl);
			log_board();
			History[history_len++] = move;

			print_result();
		}
	}
	//	close_book();
	return 0;
}

struct BadFen
{};

void init_fen()
{
	init_board();
	for (int i = a8;i <= h1;++i) {
		if (Board[i] != OFF_BOARD) {
			if (Board[i] != NO_SLOT) {
				sub_value(LIGHT, Board[i]);
				Board[i] = NO_SLOT;
			}
		}
	}
	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Players.pieces[i] = EMPTY;
}

PieceSlotType next_pawn(Colors c)
{
	int base = base_by_color(c);
	for (int i = PAWN1;i <= PAWN8;++i) {
		if (Players.pieces[i + base] == EMPTY) return (PieceSlotType)(i + base);
	}
	throw(BadFen());
}
bool find_fen_piece(PieceSlotType &p, int slot, PieceType t)
{
	if (Players.pieces[slot] == EMPTY) {
		Players.pieces[slot] = t;
		p = (PieceSlotType)slot;
		return true;
	}
	return false;
}
PieceSlotType next_fen_piece(char f)
{
	PieceSlotType p;
	Colors c = isupper(f) ? LIGHT : DARK;
	int base = base_by_color(c);
	switch (toupper(f))
	{
	case 'P':
		p = next_pawn(c);
		Players.pieces[p] = PAWN;
		return p;
	case 'R':
		find_fen_piece(p, ROOK1 + base, ROOK) || find_fen_piece(p, ROOK2 + base, ROOK) || find_fen_piece(p, next_pawn(c), ROOK);
		return p;
	case 'N':
		find_fen_piece(p, KNIGHT1 + base, KNIGHT) || find_fen_piece(p, KNIGHT2 + base, KNIGHT) || find_fen_piece(p, next_pawn(c), KNIGHT);
		return p;
	case 'B':
		find_fen_piece(p, BISHOP1 + base, BISHOP) || find_fen_piece(p, BISHOP2 + base, BISHOP) || find_fen_piece(p, next_pawn(c), BISHOP);
		return p;
	case 'Q':
		find_fen_piece(p, QUEENP + base, QUEEN) || find_fen_piece(p, next_pawn(c), QUEEN);
		return p;
	case 'K':
		find_fen_piece(p, KINGP + base, KING);
		return p;
	}
}

Pos next_fen_pos(Pos p)
{
	while (Board[++p] == OFF_BOARD);
	return p;
}
void scan_fen(const char *fen)
{
	init_fen();
	Pos p = a8;
	while (true) {
		while (Board[p] == OFF_BOARD) ++p;
		switch (*fen) {
		case '1': case '2':case '3':case '4':case '5':case '6':case '7':case '8':
			p += *fen - '0';
			break;
		case'/':
		case' ':
			break;
		default:
		{
			PieceSlotType s = next_fen_piece(*fen);
			Board[p] = s;
			Players.positions[s] = p;
			add_value(LIGHT, s);
			p = next_fen_pos(p);
		}
		}
		++fen;
		if (p > h1) break;
	}
	++fen;
	if (*fen == 'b') set_side(DARK);
	fen += 2;
	while (true) {
		switch (*fen) {
		case 'k':
			Players.pieces[DARK_ROOK2] = ROOK_NOT_MOVED;
			Players.pieces[DARK_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'q':
			Players.pieces[DARK_ROOK1] = ROOK_NOT_MOVED;
			Players.pieces[DARK_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'K':
			Players.pieces[LIGHT_ROOK2] = ROOK_NOT_MOVED;
			Players.pieces[LIGHT_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case 'Q':
			Players.pieces[LIGHT_ROOK1] = ROOK_NOT_MOVED;
			Players.pieces[LIGHT_KINGP] = KING_NOT_MOVED;
			++fen;
			continue;
		case '-':
			++fen;
		}
		break;
	}
	++fen;
	if (*fen != '-') {
		p = fen[0] - 'a' + 1 + 10 * (10 - (fen[1] - '0'));
		Players.pieces[Board[p]] = PAWN_JUST_ADVANCED;
		En_passant_history[MoveNumber + history_len] = p;
		En_passant_colors_history[MoveNumber + history_len] = color(Board[p]);
	}
	else En_passant_history[MoveNumber + history_len] = 0;
}
/*
8  . . . . . . . K
7  r B . . k . P .
6  P . . . . . . .
5  . . . . . . . P
4  . . . . P . . .
3  . . . . . . . .
2  . . p . . . . .
1  . . . . . . . .
a b c d e f g h
*/
int board_init[BOARD_SIZE]
{
	33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,15,33,33,28,11,32,32,31,32,5,32,33,33,0,32,32,32,32,32,32,32,33,33,32,32,32,32,32,32,32,7,33,33,32,32,32,32,4,32,32,32,33,33,32,32,32,32,32,32,32,32,33,33,32,32,18,32,32,32,32,32,33,33,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
};
int players_init[NUM_PIECE_SLOTS]
{
	4,0,0,0,4,4,0,4,0,0,0,7,0,0,0,2,0,0,4,0,0,0,0,0,0,0,0,0,9,0,0,3,
};

const char * test_fens[] = {
	"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -",
	"8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - -",
	"rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8",
	"r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1",

	"r1b3k1/6p1/P1n1pr1p/q1p5/1b1P4/2N2N2/PP1QBPPP/R3K2R b KQ - 0 1"
	"2nq1nk1/5p1p/4p1pQ/pb1pP1NP/1p1P2P1/1P4N1/P4PB1/6K1 w - - 0 1",
	"8/3r2p1/pp1Bp1p1/1kP5/1n2K3/6R1/1P3P2/8 w - - 0 1",
	"b1R2nk1/5ppp/1p3n2/5N2/1b2p3/1P2BP2/q3BQPP/6K1 w - - 0 1"
	"3rr1k1/pp3pbp/2bp1np1/q3p1B1/2B1P3/2N4P/PPPQ1PP1/3RR1K1 w - - 0 1"
	"r1b1qrk1/1ppn1pb1/p2p1npp/3Pp3/2P1P2B/2N5/PP1NBPPP/R2Q1RK1 b - - 0 1",
	"2R1r3/5k2/pBP1n2p/6p1/8/5P1P/2P3P1/7K w - - 0 1",
	"2r2rk1/1p1R1pp1/p3p2p/8/4B3/3QB1P1/q1P3KP/8 w - - 0 1",
	"r1bq1rk1/p4ppp/1pnp1n2/2p5/2PPpP2/1NP1P3/P3B1PP/R1BQ1RK1 b - - 0 1",

	"r3qb1k/1b4p1/p2pr2N/3n4/Pn2N3/2p3RP/1B3PP1/1B1QR1K1 w - - 0 27",
	nullptr
};

void test_params()
{
	long long total = 0;
	for (int i = 0;test_fens[i] != nullptr;++i) {
		scan_fen(test_fens[i]);
		//		print_board();
		//		log_board();
		cout << "board " << i << endl;
		think(2);
		total += Nodes;
	}
	Log << "total=" << log((double)total) << endl;
	cout << "total=" << log((double)total) << endl;
}

bool parse_algebraic_move(Move &m, const char *s, int &index)
{
	int start = index;
	PieceType from_type;
	bool castle = false;
	bool c_left = false;
	switch (s[index])
	{
	case 'R':
		from_type = ROOK;
		++index;
		break;
	case 'N':
		from_type = KNIGHT;
		++index;
		break;
	case 'B':
		from_type = BISHOP;
		++index;
		break;
	case 'Q':
		from_type = QUEEN;
		++index;
		break;
	case 'K':
		from_type = KING;
		++index;
		break;
	case 'a':case'b':case'c':case'd':case 'e':case'f':case'g':case 'h':
		from_type = PAWN;
		break;
	case 'O':
		if (s[++index] != '-') return false;
		if (s[++index] != 'O') return false;
		from_type = KING;
		if (s[++index] != '-') {
			c_left = false;
			castle = true;
			if (PlySide() == LIGHT) m=Move(e1, g1, CastleRight ATLINE);
			else m=Move(e8, g8, CastleRight ATLINE);
		}
		else {
			if (s[++index] != 'O') return false;
			c_left = true;
			castle = true;
			if (PlySide() == LIGHT) m = Move(e1, c1, CastleLeft ATLINE);
			else m = Move(e8, c8, CastleLeft ATLINE);
		}
		break;
	default:
		++index; return false;
	}

	Pos from = 0;
	char from_rank = 0, from_file = 0;
	Pos to = 0;
	bool capture = false;

	if (!castle) {
		if (s[index] >= '1'&&s[index] <= '8') {
			from_rank = s[index++];
		}
		else {
			if (s[index] >= 'a'&&s[index] <= 'h') {
				from_file = s[index++];
				if (s[index] >= '1'&&s[index] <= '8') {
					from_rank = s[index++];
					from  = from_file - 'a' + 1 + 10 * (10 - (from_rank - '0'));
					from_file = from_rank = 0;
				}
			}
		}
		if (s[index] == 'x') {
			++index;
			capture = true;
		}
		if (s[index] >= 'a'&&s[index] <= 'h') {
			char to_file = s[index++];
			if (s[index] >= '1'&&s[index] <= '8') {
				char to_rank = s[index++];
				to = to_file - 'a' + 1 + 10 * (10 - (to_rank - '0'));
			}
			else return false;
		}
		else {
			if (from == 0 || capture) return false;
			to = from;
			from = 0;
		}
	}
	PieceType promotion = from_type;
	bool check = false;
	switch (s[index])
	{
	case 'R':
		promotion = ROOK;
		++index;
		break;
	case 'N':
		promotion = KNIGHT;
		++index;
		break;
	case 'B':
		promotion = BISHOP;
		++index;
		break;
	case 'Q':
		promotion = QUEEN;
		++index;
		break;
	}
	if (s[index] == '+') {
		check = true;
		++index;
	}

	cout << " parsed " << piece_char(LIGHT, from_type) << " from file " << from_file << " from rank " << from_rank << " from " << PosToStandard[from]
		<< " capture " << (capture ?'x':' ') << " to " << PosToStandard[to] << " promotion " << piece_char(LIGHT, promotion) << " check " << (check?'+':' ') << endl;

	GenMoves(PlySide(), 0, 1);
	Move t;
	int found = false;

	while (!found && !MovesOrdered.empty()) {
		MovesOrdered.back().make();
		if (king_in_check(PlySide())) {//illegal to make a move that leaves your king in check
			MovesOrdered.back().unmake();
			MovesOrdered.pop();
			continue;
		}
		if (ComparisonPiece[MovesOrdered.back().initial] == from_type) {
			if (MovesOrdered.back().move_flags == CastleLeft || MovesOrdered.back().move_flags == CastleRight) {
				if (castle && MovesOrdered.back() == m) {
					found = true;
				}
			}else  if (ComparisonPiece[MovesOrdered.back().became]== promotion && MovesOrdered.back().to == to){
				if (from != 0) {
					if (MovesOrdered.back().from == from) {
						m = MovesOrdered.back();
						found = true;
					}
				}
				else {
					//assuming that 'x' is optional on a capture
					if ((capture && MovesOrdered.back().piece_taken != NO_SLOT)||!capture) {
						if (from_file == 0 && from_rank == 0) {
							m = MovesOrdered.back();
							found = true;
						}
						else if (from_file != 0) {
							if (from_file - 'a'+1 == SquareToColIndex[MovesOrdered.back().from]) {
								m = MovesOrdered.back();
								found = true;
							}
						}
						else if (from_rank != 0) {
							if (from_file - '1' == 8-SquareToRowIndex[MovesOrdered.back().from]) {
								m = MovesOrdered.back();
								found = true;
							}
						}
					}
				}
			}
		}
		MovesOrdered.back().unmake();
		MovesOrdered.pop();
	}
	MovesOrdered.clear();
	if (!found) {
		cout << "Move not found " << s+start << endl;
		print_board();
	}
	return found;
}

int fen_count;
int fen_correct;
#define MAX_PROBLEM_MOVES 5
void fen_problem(const char *fen, const char *moves, const char *descr)
{
	Move answers[MAX_PROBLEM_MOVES];
	cout << "Problem " << descr << endl;
	scan_fen(fen);
	int reader = 0;
	int moves_read = 0;
	for (int i = 0;i < MAX_PROBLEM_MOVES;++i) {
		int start = reader;
		if (parse_algebraic_move(answers[i], moves, reader)) {
			char move_buf[10];
			for (int j = 0;j < reader - start;++j) {
				move_buf[j] = moves[start + j];
				move_buf[j + 1] = 0;
			}
			cout << "Move " << move_buf << " read as " << move_str(answers[i]) << endl;
		}
		else {
			cout << "failed to read move at " << moves + start << endl;
			char t;
			cin>>t;
			return;
		}
		++moves_read;
		while (moves[reader] == ' ') ++reader;
		if (moves[reader] == 0) break;
	}
	think(2);
	++fen_count;
	bool found = false;
	for (int i = 0;i < moves_read;++i) {
		if (pv[0] == answers[i]) {
			cout << "Found answer! " << i + 1 << " = " << move_str(pv[0]) << endl;
			++fen_correct;
			found = true;
			break;
		}
	}
	if (!found) cout << "Move not in set "<< move_str(pv[0]) << endl;
	cout << "So far " << fen_correct << " out of " << fen_count << endl;
}

void fen_problem_set()
{
	fen_count=0;
	fen_correct=0;

fen_problem("2rr3k/pp3pp1/1nnqbN1p/3pN3/2pP4/2P3Q1/PPB4P/R4RK1 w - -", "Qg6", "WAC.001");
fen_problem("8/7p/5k2/5p2/p1p2P2/Pr1pPK2/1P1R3P/8 b - -", "Rxb2","WAC.002");
fen_problem("5rk1/1ppb3p/p1pb4/6q1/3P1p1r/2P1R2P/PP1BQ1P1/5RKN w - -","Rg3","WAC.003");
fen_problem("r1bq2rk/pp3pbp/2p1p1pQ/7P/3P4/2PB1N2/PP3PPR/2KR4 w - -","Qxh7+","WAC.004");
fen_problem("5k2/6pp/p1qN4/1p1p4/3P4/2PKP2Q/PP3r2/3R4 b - -","Qc4+", "WAC.005");
fen_problem("7k/p7/1R5K/6r1/6p1/6P1/8/8 w - -","Rb7", "WAC.006");
fen_problem("rnbqkb1r/pppp1ppp/8/4P3/6n1/7P/PPPNPPP1/R1BQKBNR b KQkq -","Ne3", "WAC.007");
fen_problem("r4q1k/p2bR1rp/2p2Q1N/5p2/5p2/2P5/PP3PPP/R5K1 w - -","Rf7", "WAC.008");
fen_problem("3q1rk1/p4pp1/2pb3p/3p4/6Pr/1PNQ4/P1PB1PP1/4RRK1 b - -","Bh2+", "WAC.009");
fen_problem("2br2k1/2q3rn/p2NppQ1/2p1P3/Pp5R/4P3/1P3PPP/3R2K1 w - -","Rxh7", "WAC.010");
fen_problem("r1b1kb1r/3q1ppp/pBp1pn2/8/Np3P2/5B2/PPP3PP/R2Q1RK1 w kq -","Bxc6", "WAC.011");
fen_problem("4k1r1/2p3r1/1pR1p3/3pP2p/3P2qP/P4N2/1PQ4P/5R1K b - -","Qxf3+", "WAC.012");
fen_problem("5rk1/pp4p1/2n1p2p/2Npq3/2p5/6P1/P3P1BP/R4Q1K w - -","Qxf8+", "WAC.013");
fen_problem("r2rb1k1/pp1q1p1p/2n1p1p1/2bp4/5P2/PP1BPR1Q/1BPN2PP/R5K1 w - -","Qxh7+", "WAC.014");
fen_problem("1R6/1brk2p1/4p2p/p1P1Pp2/P7/6P1/1P4P1/2R3K1 w - -","Rxb7", "WAC.015");
fen_problem("r4rk1/ppp2ppp/2n5/2bqp3/8/P2PB3/1PP1NPPP/R2Q1RK1 w - -","Nc3", "WAC.016");
fen_problem("1k5r/pppbn1pp/4q1r1/1P3p2/2NPp3/1QP5/P4PPP/R1B1R1K1 w - -","Ne5", "WAC.017");
fen_problem("R7/P4k2/8/8/8/8/r7/6K1 w - -","Rh8", "WAC.018");
fen_problem("r1b2rk1/ppbn1ppp/4p3/1QP4q/3P4/N4N2/5PPP/R1B2RK1 w - -","c6", "WAC.019");
fen_problem("r2qkb1r/1ppb1ppp/p7/4p3/P1Q1P3/2P5/5PPP/R1B2KNR b kq -","Bb5", "WAC.020");
fen_problem("5rk1/1b3p1p/pp3p2/3n1N2/1P6/P1qB1PP1/3Q3P/4R1K1 w - -","Qh6", "WAC.021");
fen_problem("r1bqk2r/ppp1nppp/4p3/n5N1/2BPp3/P1P5/2P2PPP/R1BQK2R w KQkq -","Ba2 Nxf7", "WAC.022");
fen_problem("r3nrk1/2p2p1p/p1p1b1p1/2NpPq2/3R4/P1N1Q3/1PP2PPP/4R1K1 w - -","g4", "WAC.023");
fen_problem("6k1/1b1nqpbp/pp4p1/5P2/1PN5/4Q3/P5PP/1B2B1K1 b - -","Bd4", "WAC.024");
fen_problem("3R1rk1/8/5Qpp/2p5/2P1p1q1/P3P3/1P2PK2/8 b - -","Qh4+", "WAC.025");
fen_problem("3r2k1/1p1b1pp1/pq5p/8/3NR3/2PQ3P/PP3PP1/6K1 b - -","Bf5", "WAC.026");
fen_problem("7k/pp4np/2p3p1/3pN1q1/3P4/Q7/1r3rPP/2R2RK1 w - -","Qf8+", "WAC.027");
fen_problem("1r1r2k1/4pp1p/2p1b1p1/p3R3/RqBP4/4P3/1PQ2PPP/6K1 b - -","Qe1+", "WAC.028");
fen_problem("r2q2k1/pp1rbppp/4pn2/2P5/1P3B2/6P1/P3QPBP/1R3RK1 w - -","c6", "WAC.029");
fen_problem("1r3r2/4q1kp/b1pp2p1/5p2/pPn1N3/6P1/P3PPBP/2QRR1K1 w - -","Nxd6", "WAC.030");
fen_problem("rb3qk1/pQ3ppp/4p3/3P4/8/1P3N2/1P3PPP/3R2K1 w - -","Qxa8 d6 dxe6 g3", "WAC.031");
fen_problem("6k1/p4p1p/1p3np1/2q5/4p3/4P1N1/PP3PPP/3Q2K1 w - -","Qd8+", "WAC.032");
fen_problem("8/p1q2pkp/2Pr2p1/8/P3Q3/6P1/5P1P/2R3K1 w - -","Qe5+ Qf4", "WAC.033");
fen_problem("7k/1b1r2p1/p6p/1p2qN2/3bP3/3Q4/P5PP/1B1R3K b - -","Bg1", "WAC.034");
fen_problem("r3r2k/2R3pp/pp1q1p2/8/3P3R/7P/PP3PP1/3Q2K1 w - -","Rxh7+", "WAC.035");
fen_problem("3r4/2p1rk2/1pQq1pp1/7p/1P1P4/P4P2/6PP/R1R3K1 b - -","Re1+", "WAC.036");
fen_problem("2r5/2rk2pp/1pn1pb2/pN1p4/P2P4/1N2B3/nPR1KPPP/3R4 b - -","Nxd4+", "WAC.037");
fen_problem("4k3/p4prp/1p6/2b5/8/2Q3P1/P2R1PKP/4q3 w - -","Qd3 Rd8+", "WAC.038");
fen_problem("r1br2k1/pp2bppp/2nppn2/8/2P1PB2/2N2P2/PqN1B1PP/R2Q1R1K w - -","Na4", "WAC.039");
fen_problem("3r1r1k/1p4pp/p4p2/8/1PQR4/6Pq/P3PP2/2R3K1 b - -","Rc8", "WAC.040");
fen_problem("1k6/5RP1/1P6/1K6/6r1/8/8/8 w - -","Ka5 Kc5 b7", "WAC.041");
fen_problem("r1b1r1k1/pp1n1pbp/1qp3p1/3p4/1B1P4/Q3PN2/PP2BPPP/R4RK1 w - -","Ba5", "WAC.042");
fen_problem("r2q3k/p2P3p/1p3p2/3QP1r1/8/B7/P5PP/2R3K1 w - -","Be7 Qxa8", "WAC.043");
fen_problem("3rb1k1/pq3pbp/4n1p1/3p4/2N5/2P2QB1/PP3PPP/1B1R2K1 b - -","dxc4", "WAC.044");
fen_problem("7k/2p1b1pp/8/1p2P3/1P3r2/2P3Q1/1P5P/R4qBK b - -","Qxa1", "WAC.045");
fen_problem("r1bqr1k1/pp1nb1p1/4p2p/3p1p2/3P4/P1N1PNP1/1PQ2PP1/3RKB1R w K -","Nb5", "WAC.046");
fen_problem("r1b2rk1/pp2bppp/2n1pn2/q5B1/2BP4/2N2N2/PP2QPPP/2R2RK1 b - -","Nxd4", "WAC.047");
fen_problem("1rbq1rk1/p1p1bppp/2p2n2/8/Q1BP4/2N5/PP3PPP/R1B2RK1 b - -","Rb4", "WAC.048");
fen_problem("2b3k1/4rrpp/p2p4/2pP2RQ/1pP1Pp1N/1P3P1P/1q6/6RK w - -","Qxh7+", "WAC.049");
fen_problem("k4r2/1R4pb/1pQp1n1p/3P4/5p1P/3P2P1/r1q1R2K/8 w - -","Rxb6+", "WAC.050");
fen_problem("r1bq1r2/pp4k1/4p2p/3pPp1Q/3N1R1P/2PB4/6P1/6K1 w - -","Rg4+", "WAC.051");
fen_problem("r1k5/1p3q2/1Qpb4/3N1p2/5Pp1/3P2Pp/PPPK3P/4R3 w - -","Re7 c4", "WAC.052");
fen_problem("6k1/6p1/p7/3Pn3/5p2/4rBqP/P4RP1/5QK1 b - -","Re1", "WAC.053");
fen_problem("r3kr2/1pp4p/1p1p4/7q/4P1n1/2PP2Q1/PP4P1/R1BB2K1 b q -","Qh1+", "WAC.054");
fen_problem("r3r1k1/pp1q1pp1/4b1p1/3p2B1/3Q1R2/8/PPP3PP/4R1K1 w - -","Qxg7+", "WAC.055");
fen_problem("r1bqk2r/pppp1ppp/5n2/2b1n3/4P3/1BP3Q1/PP3PPP/RNB1K1NR b KQkq -","Bxf2+", "WAC.056");
fen_problem("r3q1kr/ppp5/3p2pQ/8/3PP1b1/5R2/PPP3P1/5RK1 w - -","Rf8+", "WAC.057");
fen_problem("8/8/2R5/1p2qp1k/1P2r3/2PQ2P1/5K2/8 w - -","Qd1+", "WAC.058");
fen_problem("r1b2rk1/2p1qnbp/p1pp2p1/5p2/2PQP3/1PN2N1P/PB3PP1/3R1RK1 w - -","Nd5", "WAC.059");
fen_problem("rn1qr1k1/1p2np2/2p3p1/8/1pPb4/7Q/PB1P1PP1/2KR1B1R w - -","Qh8+", "WAC.060");
fen_problem("3qrbk1/ppp1r2n/3pP2p/3P4/2P4P/1P3Q2/PB6/R4R1K w - -","Qf7+", "WAC.061");
fen_problem("6r1/3Pn1qk/p1p1P1rp/2Q2p2/2P5/1P4P1/P3R2P/5RK1 b - -","Rxg3+", "WAC.062");
fen_problem("r1brnbk1/ppq2pp1/4p2p/4N3/3P4/P1PB1Q2/3B1PPP/R3R1K1 w - -","Nxf7", "WAC.063");
fen_problem("8/6pp/3q1p2/3n1k2/1P6/3NQ2P/5PP1/6K1 w - -","g4+", "WAC.064");
fen_problem("1r1r1qk1/p2n1p1p/bp1Pn1pQ/2pNp3/2P2P1N/1P5B/P6P/3R1RK1 w - -","Ne7+", "WAC.065");
fen_problem("1k1r2r1/ppq5/1bp4p/3pQ3/8/2P2N2/PP4P1/R4R1K b - -","Qxe5", "WAC.066");
fen_problem("3r2k1/p2q4/1p4p1/3rRp1p/5P1P/6PK/P3R3/3Q4 w - -","Rxd5", "WAC.067");
fen_problem("6k1/5ppp/1q6/2b5/8/2R1pPP1/1P2Q2P/7K w - -","Qxe3", "WAC.068");
fen_problem("2k5/pppr4/4R3/4Q3/2pp2q1/8/PPP2PPP/6K1 w - -","f3 h3", "WAC.069");
fen_problem("2kr3r/pppq1ppp/3p1n2/bQ2p3/1n1PP3/1PN1BN1P/1PP2PP1/2KR3R b - -","Na2+", "WAC.070");
fen_problem("2kr3r/pp1q1ppp/5n2/1Nb5/2Pp1B2/7Q/P4PPP/1R3RK1 w - -","Nxa7+", "WAC.071");
fen_problem("r3r1k1/pp1n1ppp/2p5/4Pb2/2B2P2/B1P5/P5PP/R2R2K1 w - -","e6", "WAC.072");
fen_problem("r1q3rk/1ppbb1p1/4Np1p/p3pP2/P3P3/2N4R/1PP1Q1PP/3R2K1 w - -","Qd2", "WAC.073");
fen_problem("5r1k/pp4pp/2p5/2b1P3/4Pq2/1PB1p3/P3Q1PP/3N2K1 b - -","Qf1+", "WAC.074");
fen_problem("r3r1k1/pppq1ppp/8/8/1Q4n1/7P/PPP2PP1/RNB1R1K1 b - -","Qd6", "WAC.075");
fen_problem("r1b1qrk1/2p2ppp/pb1pnn2/1p2pNB1/3PP3/1BP5/PP2QPPP/RN1R2K1 w - -","Bxf6", "WAC.076");
fen_problem("3r2k1/ppp2ppp/6q1/b4n2/3nQB2/2p5/P4PPP/RN3RK1 b - -","Ng3", "WAC.077");
fen_problem("r2q3r/ppp2k2/4nbp1/5Q1p/2P1NB2/8/PP3P1P/3RR1K1 w - -","Ng5+", "WAC.078");
fen_problem("r3k2r/pbp2pp1/3b1n2/1p6/3P3p/1B2N1Pq/PP1PQP1P/R1B2RK1 b kq -","Qxh2+", "WAC.079");
fen_problem("r4rk1/p1B1bpp1/1p2pn1p/8/2PP4/3B1P2/qP2QP1P/3R1RK1 w - -","Ra1", "WAC.080");
fen_problem("r4rk1/1bR1bppp/4pn2/1p2N3/1P6/P3P3/4BPPP/3R2K1 b - -","Bd6", "WAC.081");
fen_problem("3rr1k1/pp3pp1/4b3/8/2P1B2R/6QP/P3q1P1/5R1K w - -","Bh7+", "WAC.082");
fen_problem("3rr1k1/ppqbRppp/2p5/8/3Q1n2/2P3N1/PPB2PPP/3R2K1 w - -","Qxd7", "WAC.083");
fen_problem("r2q1r1k/2p1b1pp/p1n5/1p1Q1bN1/4n3/1BP1B3/PP3PPP/R4RK1 w - -","Qg8+", "WAC.084");
fen_problem("kr2R3/p4r2/2pq4/2N2p1p/3P2p1/Q5P1/5P1P/5BK1 w - -","Na6", "WAC.085");
fen_problem("8/p7/1ppk1n2/5ppp/P1PP4/2P1K1P1/5N1P/8 b - -","Ng4+", "WAC.086");
fen_problem("8/p3k1p1/4r3/2ppNpp1/PP1P4/2P3KP/5P2/8 b - -","Rxe5", "WAC.087");
fen_problem("r6k/p1Q4p/2p1b1rq/4p3/B3P3/4P3/PPP3P1/4RRK1 b - -","Rxg2+", "WAC.088");
fen_problem("1r3b1k/p4rpp/4pp2/3q4/2ppbPPQ/6RK/PP5P/2B1NR2 b - -","g5", "WAC.089");
fen_problem("3qrrk1/1pp2pp1/1p2bn1p/5N2/2P5/P1P3B1/1P4PP/2Q1RRK1 w - -","Nxg7", "WAC.090");
fen_problem("2qr2k1/4b1p1/2p2p1p/1pP1p3/p2nP3/PbQNB1PP/1P3PK1/4RB2 b - -","Be6", "WAC.091");
fen_problem("r4rk1/1p2ppbp/p2pbnp1/q7/3BPPP1/2N2B2/PPP4P/R2Q1RK1 b - -","Bxg4", "WAC.092");
fen_problem("r1b1k1nr/pp3pQp/4pq2/3pn3/8/P1P5/2P2PPP/R1B1KBNR w KQkq -","Bh6", "WAC.093");
fen_problem("8/k7/p7/3Qp2P/n1P5/3KP3/1q6/8 b - -","e4+", "WAC.094");
fen_problem("2r5/1r6/4pNpk/3pP1qp/8/2P1QP2/5PK1/R7 w - -","Ng4+", "WAC.095");
fen_problem("r1b4k/ppp2Bb1/6Pp/3pP3/1qnP1p1Q/8/PPP3P1/1K1R3R w - -","Qd8+ b3", "WAC.096");
fen_problem("6k1/5p2/p5np/4B3/3P4/1PP1q3/P3r1QP/6RK w - -","Qa8+", "WAC.097");
fen_problem("1r3rk1/5pb1/p2p2p1/Q1n1q2p/1NP1P3/3p1P1B/PP1R3P/1K2R3 b - -","Nxe4", "WAC.098");
fen_problem("r1bq1r1k/1pp1Np1p/p2p2pQ/4R3/n7/8/PPPP1PPP/R1B3K1 w - -","Rh5", "WAC.099");
fen_problem("8/k1b5/P4p2/1Pp2p1p/K1P2P1P/8/3B4/8 w - -","Be3 b6+", "WAC.100");
fen_problem("5rk1/p5pp/8/8/2Pbp3/1P4P1/7P/4RN1K b - -","Bc3", "WAC.101");
fen_problem("2Q2n2/2R4p/1p1qpp1k/8/3P3P/3B2P1/5PK1/r7 w - -","Qxf8+", "WAC.102");
fen_problem("6k1/2pb1r1p/3p1PpQ/p1nPp3/1q2P3/2N2P2/PrB5/2K3RR w - -","Qxg6+", "WAC.103");
fen_problem("b4r1k/pq2rp2/1p1bpn1p/3PN2n/2P2P2/P2B3K/1B2Q2N/3R2R1 w - -","Qxh5", "WAC.104");
fen_problem("r2r2k1/pb3ppp/1p1bp3/7q/3n2nP/PP1B2P1/1B1N1P2/RQ2NRK1 b - -","Bxg3 Qxh4", "WAC.105");
fen_problem("4rrk1/pppb4/7p/3P2pq/3Qn3/P5P1/1PP4P/R3RNNK b - -","Nf2+", "WAC.106");
fen_problem("5n2/pRrk2p1/P4p1p/4p3/3N4/5P2/6PP/6K1 w - -","Nb5", "WAC.107");
fen_problem("r5k1/1q4pp/2p5/p1Q5/2P5/5R2/4RKPP/r7 w - -","Qe5", "WAC.108");
fen_problem("rn2k1nr/pbp2ppp/3q4/1p2N3/2p5/QP6/PB1PPPPP/R3KB1R b KQkq -","c3", "WAC.109");
fen_problem("2kr4/bp3p2/p2p2b1/P7/2q5/1N4B1/1PPQ2P1/2KR4 b - -","Be3", "WAC.110");
fen_problem("6k1/p5p1/5p2/2P2Q2/3pN2p/3PbK1P/7P/6q1 b - -","Qf1+", "WAC.111");
fen_problem("r4kr1/ppp5/4bq1b/7B/2PR1Q1p/2N3P1/PP3P1P/2K1R3 w - -","Rxe6", "WAC.112");
fen_problem("rnbqkb1r/1p3ppp/5N2/1p2p1B1/2P5/8/PP2PPPP/R2QKB1R b KQkq -","Qxf6", "WAC.113");
fen_problem("r1b1rnk1/1p4pp/p1p2p2/3pN2n/3P1PPq/2NBPR1P/PPQ5/2R3K1 w - -","Bxh7+", "WAC.114");
fen_problem("4N2k/5rpp/1Q6/p3q3/8/P5P1/1P3P1P/5K2 w - -","Nd6", "WAC.115");
fen_problem("r2r2k1/2p2ppp/p7/1p2P1n1/P6q/5P2/1PB1QP1P/R5RK b - -","Rd2", "WAC.116");
fen_problem("3r1rk1/q4ppp/p1Rnp3/8/1p6/1N3P2/PP3QPP/3R2K1 b - -","Ne4", "WAC.117");
fen_problem("r5k1/pb2rpp1/1p6/2p4q/5R2/2PB2Q1/P1P3PP/5R1K w - -","Rh4", "WAC.118");
fen_problem("r2qr1k1/p1p2ppp/2p5/2b5/4nPQ1/3B4/PPP3PP/R1B2R1K b - -","Qxd3", "WAC.119");
fen_problem("r4rk1/1bn2qnp/3p1B1Q/p2P1pP1/1pp5/5N1P/PPB2P2/2KR3R w - -","Rhg1 g6", "WAC.120");
fen_problem("6k1/5p1p/2bP2pb/4p3/2P5/1p1pNPPP/1P1Q1BK1/1q6 b - -","Bxf3+", "WAC.121");
fen_problem("1k6/ppp4p/1n2pq2/1N2Rb2/2P2Q2/8/P4KPP/3r1B2 b - -","Rxf1+", "WAC.122");
fen_problem("6k1/1b2rp2/1p4p1/3P4/PQ4P1/2N2q2/5P2/3R2K1 b - -","Bxd5 Rc7 Re6", "WAC.123");
fen_problem("6k1/3r4/2R5/P5P1/1P4p1/8/4rB2/6K1 b - -","g3", "WAC.124");
fen_problem("r1bqr1k1/pp3ppp/1bp5/3n4/3B4/2N2P1P/PPP1B1P1/R2Q1RK1 b - -","Bxd4+", "WAC.125");
fen_problem("r5r1/pQ5p/1qp2R2/2k1p3/4P3/2PP4/P1P3PP/6K1 w - -","Rxc6+", "WAC.126");
fen_problem("2k4r/1pr1n3/p1p1q2p/5pp1/3P1P2/P1P1P3/1R2Q1PP/1RB3K1 w - -","Rxb7", "WAC.127");
fen_problem("6rk/1pp2Qrp/3p1B2/1pb1p2R/3n1q2/3P4/PPP3PP/R6K w - -","Qg6", "WAC.128");
fen_problem("3r1r1k/1b2b1p1/1p5p/2p1Pp2/q1B2P2/4P2P/1BR1Q2K/6R1 b - -","Bf3", "WAC.129");
fen_problem("6k1/1pp3q1/5r2/1PPp4/3P1pP1/3Qn2P/3B4/4R1K1 b - -","Qh6 Qh8", "WAC.130");
fen_problem("2rq1bk1/p4p1p/1p4p1/3b4/3B1Q2/8/P4PpP/3RR1K1 w - -","Re8", "WAC.131");
fen_problem("4r1k1/5bpp/2p5/3pr3/8/1B3pPq/PPR2P2/2R2QK1 b - -","Re1", "WAC.132");
fen_problem("r1b1k2r/1pp1q2p/p1n3p1/3QPp2/8/1BP3B1/P5PP/3R1RK1 w kq -","Bh4", "WAC.133");
fen_problem("3r2k1/p6p/2Q3p1/4q3/2P1p3/P3Pb2/1P3P1P/2K2BR1 b - -","Rd1+", "WAC.134");
fen_problem("3r1r1k/N2qn1pp/1p2np2/2p5/2Q1P2N/3P4/PP4PP/3R1RK1 b - -","Nd4", "WAC.135");
fen_problem("6kr/1q2r1p1/1p2N1Q1/5p2/1P1p4/6R1/7P/2R3K1 w - -","Rc8+", "WAC.136");
fen_problem("3b1rk1/1bq3pp/5pn1/1p2rN2/2p1p3/2P1B2Q/1PB2PPP/R2R2K1 w - -","Rd7", "WAC.137");
fen_problem("r1bq3r/ppppR1p1/5n1k/3P4/6pP/3Q4/PP1N1PP1/5K1R w - -","h5", "WAC.138");
fen_problem("rnb3kr/ppp2ppp/1b6/3q4/3pN3/Q4N2/PPP2KPP/R1B1R3 w - -","Nf6+", "WAC.139");
fen_problem("r2b1rk1/pq4p1/4ppQP/3pB1p1/3P4/2R5/PP3PP1/5RK1 w - -","Bc7 Rc7", "WAC.140");
fen_problem("4r1k1/p1qr1p2/2pb1Bp1/1p5p/3P1n1R/1B3P2/PP3PK1/2Q4R w - -","Qxf4", "WAC.141");
fen_problem("r2q3n/ppp2pk1/3p4/5Pr1/2NP1Qp1/2P2pP1/PP3K2/4R2R w - -","Re8 f6+", "WAC.142");
fen_problem("5b2/pp2r1pk/2pp1pRp/4rP1N/2P1P3/1P4QP/P3q1P1/5R1K w - -","Rxh6+", "WAC.143");
fen_problem("r2q1rk1/pp3ppp/2p2b2/8/B2pPPb1/7P/PPP1N1P1/R2Q1RK1 b - -","d3", "WAC.144");
fen_problem("r1bq4/1p4kp/3p1n2/p4pB1/2pQ4/8/1P4PP/4RRK1 w - -","Re8", "WAC.145");
fen_problem("8/8/2Kp4/3P1B2/2P2k2/5p2/8/8 w - -","Bc8 Bd3 Bh3", "WAC.146");
fen_problem("r2r2k1/ppqbppbp/2n2np1/2pp4/6P1/1P1PPNNP/PBP2PB1/R2QK2R b KQ -","Nxg4", "WAC.147");
fen_problem("2r1k3/6pr/p1nBP3/1p3p1p/2q5/2P5/P1R4P/K2Q2R1 w - -","Rxg7", "WAC.148");
fen_problem("6k1/6p1/2p4p/4Pp2/4b1qP/2Br4/1P2RQPK/8 b - -","Bxg2", "WAC.149");
fen_problem("r3r1k1/5p2/pQ1b2pB/1p6/4p3/6P1/Pq2BP1P/2R3K1 b - -","Ba3 Be5 Bf8 e3", "WAC.150");
fen_problem("8/3b2kp/4p1p1/pr1n4/N1N4P/1P4P1/1K3P2/3R4 w - -","Nc3", "WAC.151");
fen_problem("1br2rk1/1pqb1ppp/p3pn2/8/1P6/P1N1PN1P/1B3PP1/1QRR2K1 w - -","Ne4", "WAC.152");
fen_problem("2r3k1/q4ppp/p3p3/pnNp4/2rP4/2P2P2/4R1PP/2R1Q1K1 b - -","Nxd4", "WAC.153");
fen_problem("r1b2rk1/2p2ppp/p7/1p6/3P3q/1BP3bP/PP3QP1/RNB1R1K1 w - -","Qxf7+", "WAC.154");
fen_problem("5bk1/1rQ4p/5pp1/2pP4/3n1PP1/7P/1q3BB1/4R1K1 w - -","d6", "WAC.155");
fen_problem("r1b1qN1k/1pp3p1/p2p3n/4p1B1/8/1BP4Q/PP3KPP/8 w - -","Qxh6+", "WAC.156");
fen_problem("5rk1/p4ppp/2p1b3/3Nq3/4P1n1/1p1B2QP/1PPr2P1/1K2R2R w - -","Ne7+", "WAC.157");
fen_problem("5rk1/n1p1R1bp/p2p4/1qpP1QB1/7P/2P3P1/PP3P2/6K1 w - -","Rxg7+", "WAC.158");
fen_problem("r1b2r2/5P1p/ppn3pk/2p1p1Nq/1bP1PQ2/3P4/PB4BP/1R3RK1 w - -","Ne6+", "WAC.159");
fen_problem("qn1kr2r/1pRbb3/pP5p/P2pP1pP/3N1pQ1/3B4/3B1PP1/R5K1 w - -","Qxd7+", "WAC.160");
fen_problem("3r3k/3r1P1p/pp1Nn3/2pp4/7Q/6R1/Pq4PP/5RK1 w - -","Qxd8+", "WAC.161");
fen_problem("r3kbnr/p4ppp/2p1p3/8/Q1B3b1/2N1B3/PP3PqP/R3K2R w KQkq -","Bd5", "WAC.162");
fen_problem("5rk1/2p4p/2p4r/3P4/4p1b1/1Q2NqPp/PP3P1K/R4R2 b - -","Qg2+", "WAC.163");
fen_problem("8/6pp/4p3/1p1n4/1NbkN1P1/P4P1P/1PR3K1/r7 w - -","Rxc4+", "WAC.164");
fen_problem("1r5k/p1p3pp/8/8/4p3/P1P1R3/1P1Q1qr1/2KR4 w - -","Re2", "WAC.165");
fen_problem("r3r1k1/5pp1/p1p4p/2Pp4/8/q1NQP1BP/5PP1/4K2R b K -","d4", "WAC.166");
fen_problem("7Q/ppp2q2/3p2k1/P2Ppr1N/1PP5/7R/5rP1/6K1 b - -","Rxg2+", "WAC.167");
fen_problem("r3k2r/pb1q1p2/8/2p1pP2/4p1p1/B1P1Q1P1/P1P3K1/R4R2 b kq -","Qd2+", "WAC.168");
fen_problem("5rk1/1pp3bp/3p2p1/2PPp3/1P2P3/2Q1B3/4q1PP/R5K1 b - -","Bh6", "WAC.169");
fen_problem("5r1k/6Rp/1p2p3/p2pBp2/1qnP4/4P3/Q4PPP/6K1 w - -","Qxc4", "WAC.170");
fen_problem("2rq4/1b2b1kp/p3p1p1/1p1nNp2/7P/1B2B1Q1/PP3PP1/3R2K1 w - -","Bh6+", "WAC.171");
fen_problem("5r1k/p5pp/8/1P1pq3/P1p2nR1/Q7/5BPP/6K1 b - -","Qe1+", "WAC.172");
fen_problem("2r1b3/1pp1qrk1/p1n1P1p1/7R/2B1p3/4Q1P1/PP3PP1/3R2K1 w - -","Qh6+", "WAC.173");
fen_problem("2r2rk1/6p1/p3pq1p/1p1b1p2/3P1n2/PP3N2/3N1PPP/1Q2RR1K b - -","Nxg2", "WAC.174");
fen_problem("r5k1/pppb3p/2np1n2/8/3PqNpP/3Q2P1/PPP5/R4RK1 w - -","Nh5", "WAC.175");
fen_problem("r1bq3r/ppp2pk1/3p1pp1/8/2BbPQ2/2NP2P1/PPP4P/R4R1K b - -","Rxh2+", "WAC.176");
fen_problem("r1b3r1/4qk2/1nn1p1p1/3pPp1P/p4P2/1p3BQN/PKPBN3/3R3R b - -","Qa3+", "WAC.177");
fen_problem("3r2k1/p1rn1p1p/1p2pp2/6q1/3PQNP1/5P2/P1P4R/R5K1 w - -","Nxe6", "WAC.178");
fen_problem("r1b2r1k/pp4pp/3p4/3B4/8/1QN3Pn/PP3q1P/R3R2K b - -","Qg1+", "WAC.179");
fen_problem("r1q2rk1/p3bppb/3p1n1p/2nPp3/1p2P1P1/6NP/PP2QPB1/R1BNK2R b KQ -","Nxd5", "WAC.180");
fen_problem("r3k2r/2p2p2/p2p1n2/1p2p3/4P2p/1PPPPp1q/1P5P/R1N2QRK b kq -","Ng4", "WAC.181");
fen_problem("r1b2rk1/ppqn1p1p/2n1p1p1/2b3N1/2N5/PP1BP3/1B3PPP/R2QK2R w KQ -","Qh5", "WAC.182");
fen_problem("1r2k1r1/5p2/b3p3/1p2b1B1/3p3P/3B4/PP2KP2/2R3R1 w - -","Bf6", "WAC.183");
fen_problem("4kn2/r4p1r/p3bQ2/q1nNP1Np/1p5P/8/PPP3P1/2KR3R w - -","Qe7+", "WAC.184");
fen_problem("1r1rb1k1/2p3pp/p2q1p2/3PpP1Q/Pp1bP2N/1B5R/1P4PP/2B4K w - -","Qxh7+", "WAC.185");
fen_problem("r5r1/p1q2p1k/1p1R2pB/3pP3/6bQ/2p5/P1P1NPPP/6K1 w - -","Bf8+", "WAC.186");
fen_problem("6k1/5p2/p3p3/1p3qp1/2p1Qn2/2P1R3/PP1r1PPP/4R1K1 b - -","Nh3+", "WAC.187");
fen_problem("3RNbk1/pp3p2/4rQpp/8/1qr5/7P/P4P2/3R2K1 w - -","Qg7+", "WAC.188");
fen_problem("3r1k2/1ppPR1n1/p2p1rP1/3P3p/4Rp1N/5K2/P1P2P2/8 w - -","Re8+", "WAC.189");
fen_problem("8/p2b2kp/1q1p2p1/1P1Pp3/4P3/3B2P1/P2Q3P/2Nn3K b - -","Bh3", "WAC.190");
fen_problem("2r1Rn1k/1p1q2pp/p7/5p2/3P4/1B4P1/P1P1QP1P/6K1 w - -","Qc4", "WAC.191");
fen_problem("r3k3/ppp2Npp/4Bn2/2b5/1n1pp3/N4P2/PPP3qP/R2QKR2 b Qq -","Nd3+", "WAC.192");
fen_problem("5bk1/p4ppp/Qp6/4B3/1P6/Pq2P1P1/2rr1P1P/R4RK1 b - -","Qxe3", "WAC.193");
fen_problem("5rk1/ppq2ppp/2p5/4bN2/4P3/6Q1/PPP2PPP/3R2K1 w - -","Nh6+", "WAC.194");
fen_problem("3r1rk1/1p3p2/p3pnnp/2p3p1/2P2q2/1P5P/PB2QPPN/3RR1K1 w - -","g3", "WAC.195");
fen_problem("rr4k1/p1pq2pp/Q1n1pn2/2bpp3/4P3/2PP1NN1/PP3PPP/R1B1K2R b KQ -","Nb4", "WAC.196");
fen_problem("7k/1p4p1/7p/3P1n2/4Q3/2P2P2/PP3qRP/7K b - -","Qf1+", "WAC.197");
fen_problem("2br2k1/ppp2p1p/4p1p1/4P2q/2P1Bn2/2Q5/PP3P1P/4R1RK b - -","Rd3", "WAC.198");
fen_problem("r1br2k1/pp2nppp/2n5/1B1q4/Q7/4BN2/PP3PPP/2R2RK1 w - -","Bxc6 Rcd1 Rfd1", "WAC.199");
fen_problem("2rqrn1k/pb4pp/1p2pp2/n2P4/2P3N1/P2B2Q1/1B3PPP/2R1R1K1 w - -","Bxf6", "WAC.200");
fen_problem("2b2r1k/4q2p/3p2pQ/2pBp3/8/6P1/1PP2P1P/R5K1 w - -","Ra7", "WAC.201");
fen_problem("QR2rq1k/2p3p1/3p1pPp/8/4P3/8/P1r3PP/1R4K1 b - -","Rxa2", "WAC.202");
fen_problem("r4rk1/5ppp/p3q1n1/2p2NQ1/4n3/P3P3/1B3PPP/1R3RK1 w - -","Qh6", "WAC.203");
fen_problem("r1b1qrk1/1p3ppp/p1p5/3Nb3/5N2/P7/1P4PQ/K1R1R3 w - -","Rxe5", "WAC.204");
fen_problem("r3rnk1/1pq2bb1/p4p2/3p1Pp1/3B2P1/1NP4R/P1PQB3/2K4R w - -","Qxg5", "WAC.205");
fen_problem("1Qq5/2P1p1kp/3r1pp1/8/8/7P/p4PP1/2R3K1 b - -","Rc6", "WAC.206");
fen_problem("r1bq2kr/p1pp1ppp/1pn1p3/4P3/2Pb2Q1/BR6/P4PPP/3K1BNR w - -","Qxg7+", "WAC.207");
fen_problem("3r1bk1/ppq3pp/2p5/2P2Q1B/8/1P4P1/P6P/5RK1 w - -","Bf7+", "WAC.208");
fen_problem("4kb1r/2q2p2/r2p4/pppBn1B1/P6P/6Q1/1PP5/2KRR3 w k -","Rxe5+", "WAC.209");
fen_problem("3r1rk1/pp1q1ppp/3pn3/2pN4/5PP1/P5PQ/1PP1B3/1K1R4 w - -","Rh1", "WAC.210");
fen_problem("r1bqrk2/pp1n1n1p/3p1p2/P1pP1P1Q/2PpP1NP/6R1/2PB4/4RBK1 w - -","Qxf7+", "WAC.211");
fen_problem("rn1qr2Q/pbppk1p1/1p2pb2/4N3/3P4/2N5/PPP3PP/R4RK1 w - -","Qxg7+", "WAC.212");
fen_problem("3r1r1k/1b4pp/ppn1p3/4Pp1R/Pn5P/3P4/4QP2/1qB1NKR1 w - -","Rxh7+", "WAC.213");
fen_problem("r2r2k1/1p2qpp1/1np1p1p1/p3N3/2PPN3/bP5R/4QPPP/4R1K1 w - -","Ng5", "WAC.214");
fen_problem("3r2k1/pb1q1pp1/1p2pb1p/8/3N4/P2QB3/1P3PPP/1Br1R1K1 w - -","Qh7+", "WAC.215");
fen_problem("r2qr1k1/1b1nbppp/p3pn2/1p1pN3/3P1B2/2PB1N2/PP2QPPP/R4RK1 w - -","Nxf7 a4", "WAC.216");
fen_problem("r3kb1r/1pp3p1/p3bp1p/5q2/3QN3/1P6/PBP3P1/3RR1K1 w kq -","Qd7+", "WAC.217");
fen_problem("6k1/pp5p/2p3q1/6BP/2nPr1Q1/8/PP3R1K/8 w - -","Bh6", "WAC.218");
fen_problem("7k/p4q1p/1pb5/2p5/4B2Q/2P1B3/P6P/7K b - -","Qf1+", "WAC.219");
fen_problem("3rr1k1/ppp2ppp/8/5Q2/4n3/1B5R/PPP1qPP1/5RK1 b - -","Qxf1+", "WAC.220");
fen_problem("r3k3/P5bp/2N1bp2/4p3/2p5/6NP/1PP2PP1/3R2K1 w q -","Rd8+", "WAC.221");
fen_problem("2r1r2k/1q3ppp/p2Rp3/2p1P3/6QB/p3P3/bP3PPP/3R2K1 w - -","Bf6", "WAC.222");
fen_problem("r1bqk2r/pp3ppp/5n2/8/1b1npB2/2N5/PP1Q2PP/1K2RBNR w kq -","Nxe4", "WAC.223");
fen_problem("5rk1/p1q3pp/1p1r4/2p1pp1Q/1PPn1P2/3B3P/P2R2P1/3R2K1 b - -","Rh6 e4", "WAC.224");
fen_problem("4R3/4q1kp/6p1/1Q3b2/1P1b1P2/6KP/8/8 b - -","Qh4+", "WAC.225");
fen_problem("2b2rk1/p1p4p/2p1p1p1/br2N1Q1/1p2q3/8/PB3PPP/3R1RK1 w - -","Nf7", "WAC.226");
fen_problem("2k1rb1r/ppp3pp/2np1q2/5b2/2B2P2/2P1BQ2/PP1N1P1P/2KR3R b - -","d5", "WAC.227");
fen_problem("r4rk1/1bq1bp1p/4p1p1/p2p4/3BnP2/1N1B3R/PPP3PP/R2Q2K1 w - -","Bxe4", "WAC.228");
fen_problem("8/8/8/1p5r/p1p1k1pN/P2pBpP1/1P1K1P2/8 b - -","Rxh4 b4", "WAC.229");
fen_problem("2b5/1r6/2kBp1p1/p2pP1P1/2pP4/1pP3K1/1R3P2/8 b - -","Rb4", "WAC.230");
fen_problem("r4rk1/1b1nqp1p/p5p1/1p2PQ2/2p5/5N2/PP3PPP/R1BR2K1 w - -","Bg5", "WAC.231");
fen_problem("1R2rq1k/2p3p1/Q2p1pPp/8/4P3/8/P1r3PP/1R4K1 w - -","Qb5 Rxe8", "WAC.232");
fen_problem("5rk1/p1p2r1p/2pp2p1/4p3/PPPnP3/3Pq1P1/1Q1R1R1P/4NK2 b - -","Nb3", "WAC.233");
fen_problem("2kr1r2/p6p/5Pp1/2p5/1qp2Q1P/7R/PP6/1KR5 w - -","Rb3", "WAC.234");
fen_problem("5r2/1p1RRrk1/4Qq1p/1PP3p1/8/4B3/1b3P1P/6K1 w - -","Qe4 Qxf7+ Rxf7+", "WAC.235");
fen_problem("1R6/p5pk/4p2p/4P3/8/2r3qP/P3R1b1/4Q1K1 b - -","Rc1", "WAC.236");
fen_problem("r5k1/pQp2qpp/8/4pbN1/3P4/6P1/PPr4P/1K1R3R b - -","Rc1+", "WAC.237");
fen_problem("1k1r4/pp1r1pp1/4n1p1/2R5/2Pp1qP1/3P2QP/P4PB1/1R4K1 w - -","Bxb7", "WAC.238");
fen_problem("8/6k1/5pp1/Q6p/5P2/6PK/P4q1P/8 b - -","Qf1+", "WAC.239");
fen_problem("2b4k/p1b2p2/2p2q2/3p1PNp/3P2R1/3B4/P1Q2PKP/4r3 w - -","Qxc6", "WAC.240");
fen_problem("2rq1rk1/pp3ppp/2n2b2/4NR2/3P4/PB5Q/1P4PP/3R2K1 w - -","Qxh7+", "WAC.241");
fen_problem("r1b1r1k1/pp1nqp2/2p1p1pp/8/4N3/P1Q1P3/1P3PPP/1BRR2K1 w - -","Rxd7", "WAC.242");
fen_problem("1r3r1k/3p4/1p1Nn1R1/4Pp1q/pP3P1p/P7/5Q1P/6RK w - -","Qe2", "WAC.243");
fen_problem("r6r/pp3ppp/3k1b2/2pb4/B4Pq1/2P1Q3/P5PP/1RBR2K1 w - -","Qxc5+", "WAC.244");
fen_problem("4rrn1/ppq3bk/3pPnpp/2p5/2PB4/2NQ1RPB/PP5P/5R1K w - -","Qxg6+", "WAC.245");
fen_problem("6R1/4qp1p/ppr1n1pk/8/1P2P1QP/6N1/P4PP1/6K1 w - -","Qh5+", "WAC.246");
fen_problem("2k1r3/1p2Bq2/p2Qp3/Pb1p1p1P/2pP1P2/2P5/2P2KP1/1R6 w - -","Rxb5", "WAC.247");
fen_problem("5r1k/1p4pp/3q4/3Pp1R1/8/8/PP4PP/4Q1K1 b - -","Qc5+", "WAC.248");
fen_problem("r4rk1/pbq2pp1/1ppbpn1p/8/2PP4/1P1Q1N2/PBB2PPP/R3R1K1 w - -","c5 d5", "WAC.249");
fen_problem("1b5k/7P/p1p2np1/2P2p2/PP3P2/4RQ1R/q2r3P/6K1 w - -","Re8+", "WAC.250");
fen_problem("k7/p4p2/P1q1b1p1/3p3p/3Q4/7P/5PP1/1R4K1 w - -","Qe5 Qf4", "WAC.251");
fen_problem("1rb1r1k1/p1p2ppp/5n2/2pP4/5P2/2QB4/qNP3PP/2KRB2R b - -","Bg4 Re2", "WAC.252");
fen_problem("k5r1/p4b2/2P5/5p2/3P1P2/4QBrq/P5P1/4R1K1 w - -","Qe8+", "WAC.253");
fen_problem("r6k/pp3p1p/2p1bp1q/b3p3/4Pnr1/2PP2NP/PP1Q1PPN/R2B2RK b - -","Nxh3", "WAC.254");
fen_problem("3r3r/p4pk1/5Rp1/3q4/1p1P2RQ/5N2/P1P4P/2b4K w - -","Rfxg6+", "WAC.255");
fen_problem("3r1rk1/1pb1qp1p/2p3p1/p7/P2Np2R/1P5P/1BP2PP1/3Q1BK1 w - -","Nf5", "WAC.256");
fen_problem("4r1k1/pq3p1p/2p1r1p1/2Q1p3/3nN1P1/1P6/P1P2P1P/3RR1K1 w - -","Rxd4", "WAC.257");
fen_problem("r3brkn/1p5p/2p2Ppq/2Pp3B/3Pp2Q/4P1R1/6PP/5R1K w - -","Bxg6", "WAC.258");
fen_problem("r1bq1rk1/ppp2ppp/2np4/2bN1PN1/2B1P3/3p4/PPP2nPP/R1BQ1K1R w - -","Qh5", "WAC.259");
fen_problem("2r2b1r/p1Nk2pp/3p1p2/N2Qn3/4P3/q6P/P4PP1/1R3K1R w - -","Qe6+", "WAC.260");
fen_problem("r5k1/1bp3pp/p2p4/1p6/5p2/1PBP1nqP/1PP3Q1/R4R1K b - -","Nd4", "WAC.261");
fen_problem("6k1/p1B1b2p/2b3r1/2p5/4p3/1PP1N1Pq/P2R1P2/3Q2K1 b - -","Rh6", "WAC.262");
fen_problem("rnbqr2k/pppp1Qpp/8/b2NN3/2B1n3/8/PPPP1PPP/R1B1K2R w KQ -","Qg8+", "WAC.263");
fen_problem("r2r2k1/1R2qp2/p5pp/2P5/b1PN1b2/P7/1Q3PPP/1B1R2K1 b - -","Qe5 Rab8", "WAC.264");
fen_problem("2r1k2r/2pn1pp1/1p3n1p/p3PP2/4q2B/P1P5/2Q1N1PP/R4RK1 w k -","exf6", "WAC.265");
fen_problem("r3q2r/2p1k1p1/p5p1/1p2Nb2/1P2nB2/P7/2PNQbPP/R2R3K b - -","Rxh2+", "WAC.266");
fen_problem("2r1kb1r/pp3ppp/2n1b3/1q1N2B1/1P2Q3/8/P4PPP/3RK1NR w Kk -","Nc7+", "WAC.267");
fen_problem("2r3kr/ppp2n1p/7B/5q1N/1bp5/2Pp4/PP2RPPP/R2Q2K1 w - -","Re8+", "WAC.268");
fen_problem("2kr2nr/pp1n1ppp/2p1p3/q7/1b1P1B2/P1N2Q1P/1PP1BPP1/R3K2R w KQ -","axb4", "WAC.269");
fen_problem("2r1r1k1/pp1q1ppp/3p1b2/3P4/3Q4/5N2/PP2RPPP/4R1K1 w - -","Qg4", "WAC.270");
fen_problem("2kr4/ppp3Pp/4RP1B/2r5/5P2/1P6/P2p4/3K4 w - -","Rd6", "WAC.271");
fen_problem("nrq4r/2k1p3/1p1pPnp1/pRpP1p2/P1P2P2/2P1BB2/1R2Q1P1/6K1 w - -","Bxc5", "WAC.272");
fen_problem("2k4B/bpp1qp2/p1b5/7p/1PN1n1p1/2Pr4/P5PP/R3QR1K b - -","Ng3+ g3", "WAC.273");
fen_problem("8/1p6/p5R1/k7/Prpp4/K7/1NP5/8 w - - am Rd6);","Rb6 Rg5+", "WAC.274");
fen_problem("r1b2rk1/1p1n1ppp/p1p2q2/4p3/P1B1Pn2/1QN2N2/1P3PPP/3R1RK1 b - -","Nc5 Nxg2 b5", "WAC.275");
fen_problem("r5k1/pp1RR1pp/1b6/6r1/2p5/B6P/P4qPK/3Q4 w - -","Qd5+", "WAC.276");
fen_problem("1r4r1/p2kb2p/bq2p3/3p1p2/5P2/2BB3Q/PP4PP/3RKR2 b - -","Rg3 Rxg2", "WAC.277");
fen_problem("r2qkb1r/pppb2pp/2np1n2/5pN1/2BQP3/2N5/PPP2PPP/R1B1K2R w KQkq -","Bf7+", "WAC.278");
fen_problem("r7/4b3/2p1r1k1/1p1pPp1q/1P1P1P1p/PR2NRpP/2Q3K1/8 w - -","Nxf5 Rc3", "WAC.279");
fen_problem("r1r2bk1/5p1p/pn4p1/N2b4/3Pp3/B3P3/2q1BPPP/RQ3RK1 b - -","Bxa3", "WAC.280");
fen_problem("2R5/2R4p/5p1k/6n1/8/1P2QPPq/r7/6K1 w - -","Rxh7+", "WAC.281");
fen_problem("6k1/2p3p1/1p1p1nN1/1B1P4/4PK2/8/2r3b1/7R w - -","Rh8+", "WAC.282");
fen_problem("3q1rk1/4bp1p/1n2P2Q/3p1p2/6r1/Pp2R2N/1B4PP/7K w - -","Ng5", "WAC.283");
fen_problem("3r3k/pp4pp/8/1P6/3N4/Pn2P1qb/1B1Q2B1/2R3K1 w - -","Nf5", "WAC.284");
fen_problem("2rr3k/1b2bppP/p2p1n2/R7/3P4/1qB2P2/1P4Q1/1K5R w - -","Qxg7+", "WAC.285");
fen_problem("3r1k2/1p6/p4P2/2pP2Qb/8/1P1KB3/P6r/8 b - -","Rxd5+", "WAC.286");
fen_problem("rn3k1r/pp2bBpp/2p2n2/q5N1/3P4/1P6/P1P3PP/R1BQ1RK1 w - -","Qg4 Qh5", "WAC.287");
fen_problem("r1b2rk1/p4ppp/1p1Qp3/4P2N/1P6/8/P3qPPP/3R1RK1 w - -","Nf6+", "WAC.288");
fen_problem("2r3k1/5p1p/p3q1p1/2n3P1/1p1QP2P/1P4N1/PK6/2R5 b - -","Qe5", "WAC.289");
fen_problem("2k2r2/2p5/1pq5/p1p1n3/P1P2n1B/1R4Pp/2QR4/6K1 b - -","Ne2+", "WAC.290");
fen_problem("5r1k/3b2p1/p6p/1pRpR3/1P1P2q1/P4pP1/5QnP/1B4K1 w - -","h3", "WAC.291");
fen_problem("4r3/1Q1qk2p/p4pp1/3Pb3/P7/6PP/5P2/4R1K1 w - -","d6+", "WAC.292");
fen_problem("1nbq1r1k/3rbp1p/p1p1pp1Q/1p6/P1pPN3/5NP1/1P2PPBP/R4RK1 w - -","Nfg5", "WAC.293");
fen_problem("3r3k/1r3p1p/p1pB1p2/8/p1qNP1Q1/P6P/1P4P1/3R3K w - -","Bf8 Nf5 Qf4", "WAC.294");
fen_problem("4r3/p4r1p/R1p2pp1/1p1bk3/4pNPP/2P1K3/2P2P2/3R4 w - -","Rxd5+", "WAC.295");
fen_problem("3r4/1p2k2p/p1b1p1p1/4Q1Pn/2B3KP/4pP2/PP2R1N1/6q1 b - -","Rd4+ Rf8", "WAC.296");
fen_problem("3r1rk1/p3qp1p/2bb2p1/2p5/3P4/1P6/PBQN1PPP/2R2RK1 b - -","Bxg2 Bxh2+", "WAC.297");
fen_problem("3Q4/p3b1k1/2p2rPp/2q5/4B3/P2P4/7P/6RK w - -","Qh8+", "WAC.298");
fen_problem("1n2rr2/1pk3pp/pNn2p2/2N1p3/8/6P1/PP2PPKP/2RR4 w - -","Nca4", "WAC.299");
fen_problem("b2b1r1k/3R1ppp/4qP2/4p1PQ/4P3/5B2/4N1K1/8 w - -","g6", "WAC.300");
}
void test_init()
{
	init_board();
	//Position2 
	//	scan_fen("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -");
	//position 3
	//scan_fen("8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - -");
	//pos 5
	//	scan_fen("rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8");
	//pos 4
	//	scan_fen("r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1");
	//test pos 1
	//	scan_fen("r1b3k1/6p1/P1n1pr1p/q1p5/1b1P4/2N2N2/PP1QBPPP/R3K2R b KQ - 0 1");
	/*    Rxf3    2600
	cxd4    1900 y
	Nxd4    1900 x
	Bd7     1600
	Bxa6    1500
	Bxc3    1400 *
	Rg6     1400
	e5      1200

	*/
	//	scan_fen("2nq1nk1/5p1p/4p1pQ/pb1pP1NP/1p1P2P1/1P4N1/P4PB1/6K1 w - - 0 1");
	/*  Be4     2600
	Nxh7    1950
	hxg6    1900 *y
	Bf1     1400 x
	f4      1400
	Bxd5    1200

	*/
	scan_fen("rnbqkbnr/ppp1pppp/8/1B1p4/4P3/8/PPPP1PPP/RNBQK1NR_w_KQkq_-_1_2");
	//	scan_fen("8/3r2p1/pp1Bp1p1/1kP5/1n2K3/6R1/1P3P2/8 w - - 0 1");
	/*   c6      2500
	Rg6     2000
	Ke5     1900 xyz
	Rg5     1700
	Kd4     1200
	Be5     1200

	*/
	// 1985 - 1805 - 1855
	//	scan_fen("8/4kb1p/2p3pP/1pP1P1P1/1P3K2/1B6/8/8 w - - 0 1");
	/*   e6      2500 xy
	Bd1     1800Quie
	Bc2     1700
	Bxf7    1600*/
	//scan_fen("b1R2nk1/5ppp/1p3n2/5N2/1b2p3/1P2BP2/q3BQPP/6K1 w - - 0 1");
	/*  Bc5     2500 z
	Nh6     2100
	Bh6     1900
	Qg3     1750 xy
	Bxb6    1750
	Nxg7    1500
	Bc4     1400
	Rxf8    1200
	Qh4     1200*/
	//scan_fen("3rr1k1/pp3pbp/2bp1np1/q3p1B1/2B1P3/2N4P/PPPQ1PP1/3RR1K1 w - - 0 1");
	/*  Bxf6    2500 xy
	Bb5     1900
	Nd5     1700
	f4      1700
	a3      1200
	Re3     1200*/
	//scan_fen("r1b1qrk1/1ppn1pb1/p2p1npp/3Pp3/2P1P2B/2N5/PP1NBPPP/R2Q1RK1 b - - 0 1");
	/*  Nh7     2500
	Nxe4    1800
	g5      1700
	a5      1700
	Kh7     1500
	xy
	*/
	//scan_fen("2R1r3/5k2/pBP1n2p/6p1/8/5P1P/2P3P1/7K w - - 0 1");
	/* Bd8     2500 x
	Rxe8    1600 y
	*/
	//	scan_fen("2r2rk1/1p1R1pp1/p3p2p/8/4B3/3QB1P1/q1P3KP/8 w - - 0 1");
	/*   Bd4     2500 y
	Bg6     1800
	Bh7     1800
	Bxh6    1700
	Rxb7    1400
	x
	*/
	//	scan_fen("r1bq1rk1/p4ppp/1pnp1n2/2p5/2PPpP2/1NP1P3/P3B1PP/R1BQ1RK1 b - - 0 1");
	/*    Qd7     2600
	Ne8     2000
	h5      1800
	Ba6     1800
	a5      1800
	cxd4    1600 x
	d5      1500
	Re8     1400
	y
	*/
	//	scan_fen("r3qb1k/1b4p1/p2pr2N/3n4/Pn2N3/2p3RP/1B3PP1/1B1QR1K1 w - - 0 27");
	//	for (int i = 0;i < NUM_PIECE_SLOTS;++i) Players.pieces[i] = (PieceType)players_init[i];
	//	for (int i = 0;i < BOARD_SIZE;++i) {
	//		Board[i] = (PieceSlotType)board_init[i];
	//		if (Board[i] != NO_SLOT) Players.positions[Board[i]] = (Pos)i;
	//	}
	//	set_side(LIGHT);
	endgame_check();
	DisableBook = true;
	FakeLen = 51;
}

int main()
{
	init_direction_tables();
	init_log();
	init_zobrist();
	init_hash();
	init_board();
	mainish();
	close_log();
	return 0;
}

